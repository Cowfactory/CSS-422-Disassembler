00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/12/2018 10:07:26 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Team Visual Basic's Disassembler
00000000                             3  * Written by :  Henry Hong, Dylan Desmond, Austin Abeyta
00000000                             4  * Date       :  ?
00000000                             5  * Description:  CSS422 Final Project
00000000                             6  *               Machine code to Motorola 68000 Assembly
00000000                             7  *               Main Driver File
00000000                             8  *-----------------------------------------------------------
00000000                             9      
00001000                            10  START       ORG         $1000               ;Start @ address $1000
00001000  4EB9 00001016             11              JSR         DISP_INTRO          ;Display Intro Message
00001006  4EB9 0000143A             12              JSR         INPUT_ADDR          ;Take start and ending address as user input
0000100C  4EB9 00001042             13              JSR         MAIN_LOOP           ;Meat of the program: Check for validity, OPCODE match, and print to screen
00001012                            14                                                          
00001012  6000 00CE                 15              BRA         END                 ;If loop improperly terminated, base case BRA to END program         
00001016                            16  *-Intro Message---------------------------------------------
00001016  43F9 00001142             17  DISP_INTRO  LEA         M_INTRO,A1          ;Load intro msg
0000101C  103C 000E                 18              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001020  4E4F                      19              TRAP        #15                     
00001022                            20      
00001022  4E75                      21              RTS                             ;Return to main START section
00001024                            22              
00001024                            23  *-Press Enter to Continue message---------------------------            
00001024  43F9 000012FA             24  DISP_WAIT   LEA         M_WAIT,A1           ;Load wait message
0000102A  103C 000E                 25              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000102E  4E4F                      26              TRAP        #15
00001030                            27              
00001030  103C 0005                 28              MOVE.B      #5,D0               ;Trap Task 5 takes in a single character input (aka press enter)
00001034  4E4F                      29              TRAP        #15
00001036                            30              
00001036  103C 000B                 31              MOVE.B      #11,D0              ;Clear screen
0000103A  323C FF00                 32              MOVE.W      #$FF00,D1
0000103E  4E4F                      33              TRAP        #15
00001040                            34  
00001040  4E75                      35              RTS        
00001042                            36              
00001042                            37  *-Main Loop-------------------------------------------------
00001042  4EB8 1024                 38  MAIN_LOOP   JSR         DISP_WAIT           ;Display Press Enter to Continue msg
00001046  183C 001A                 39              MOVE.B      #26,D4              ;D4 loop var - print 26 lines per page
0000104A                            40              
0000104A  4EB9 000015D4             41  NEXT_OP     JSR         BUILD_STR           ;Build and accumulate the 0xADDR OPCODE $OPERAND string into memory @ OP_ADDR                            
00001050  4EB9 00001070             42              JSR         PRINT_OP            ;Print the built string to console 
00001056                            43              
00001056  4EB9 00001066             44              JSR         LOOP_COND           ;Check if address is still valid. END program if it isnt
0000105C                            45    
0000105C  5344                      46              SUBI        #1,D4               ;Decrement counter
0000105E  B83C 0000                 47              CMP.B       #0,D4               ;Is counter == 0?
00001062  67DE                      48              BEQ         MAIN_LOOP           ;Then print the next page
00001064                            49              
00001064  60E4                      50              BRA         NEXT_OP             ;Otherwise, in the same page, print the next OP         
00001066                            51  
00001066                            52              
00001066                            53  *-Loop Condition Logic--------------------------------------
00001066  DBC6                      54  LOOP_COND   ADD.L       D6,A5            ;Increment current address (A5) by the length of the last instruction + operand data (D6)
00001068  BCCD                      55              CMPA.W      A5,A6            ;If current address (A5) is now equal to or greater than end address (A6), end
0000106A  6D00 001A                 56              BLT         DSMBL_DONE           ;<---------- check conditional
0000106E                            57              
0000106E  4E75                      58              RTS            
00001070                            59             
00001070                            60  *-Print OPCODE STRING---------------------------------------
00001070  327C 1124                 61  PRINT_OP    MOVE.W      #OP_ADDR,A1         ;Move the OPCODE's beginning addr to A1
00001074  103C 000E                 62              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001078  4E4F                      63              TRAP        #15
0000107A                            64              
0000107A  327C 1436                 65              MOVE.W      #M_NEWLINE,A1       ;Print a new line after this OPCODE line is finished
0000107E  103C 000E                 66              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001082  4E4F                      67              TRAP        #15
00001084                            68              
00001084  4E75                      69              RTS
00001086                            70              
00001086                            71  *-Print to user DONE message--------------------------------
00001086  43F9 0000142E             72  DSMBL_DONE  LEA         M_DONE,A1           ;Print DONE message
0000108C  103C 000E                 73              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001090  4E4F                      74              TRAP        #15 
00001092                            75              
00001092  4EB9 00001098             76              JSR         PROMPT_NEW          ;Ask user if they want to restart
00001098                            77              
00001098                            78  *-Ask user if they want to start program again--------------            
00001098  43F9 000013DC             79  PROMPT_NEW  LEA         M_NPROMPT,A1        ;Ask user if they would like to run program again
0000109E  103C 000E                 80              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000010A2  4E4F                      81              TRAP        #15                     
000010A4                            82              
000010A4  4281                      83              CLR.L       D1                  ;Clear D1
000010A6  103C 0005                 84              MOVE.B      #5,D0               ;Read user input into D1
000010AA  4E4F                      85              TRAP        #15
000010AC                            86              
000010AC  B23C 0079                 87              CMP.B       #'y',D1             ;Is input y
000010B0  6700 0028                 88              BEQ         P_RESTART           ;if so restart program
000010B4                            89              
000010B4  B23C 0059                 90              CMP.B       #'Y',D1             ;Is input Y capital
000010B8  6700 0020                 91              BEQ         P_RESTART           ;if so restart program
000010BC                            92              
000010BC                            93        
000010BC                            94  
000010BC  B23C 006E                 95              CMP.B       #'n',D1             ;Is input n
000010C0  6700 0020                 96              BEQ         END                 ;if so restart program
000010C4                            97              
000010C4  B23C 004E                 98              CMP.B       #'N',D1             ;Is input N capital
000010C8  6700 0018                 99              BEQ         END                 ;if so restart program
000010CC                           100              
000010CC  43F9 0000141B            101              LEA         M_ERR_GEN,A1        ;Input is invalid! Prompt again
000010D2  103C 000E                102              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000010D6  4E4F                     103              TRAP        #15 
000010D8                           104              
000010D8  60BE                     105              BRA         PROMPT_NEW          ;Re prompt            
000010DA                           106  
000010DA  4EB8 1024                107  P_RESTART   JSR         DISP_WAIT
000010DE  6000 FF20                108              BRA         START 
000010E2                           109  *-END-------------------------------------------------------
000010E2  103C 0009                110  END         MOVE.B      #9,D0               ;End program
000010E6  4E4F                     111              TRAP        #15                      
000010E8                           112              
000010E8                           113  *-Variables and constants-----------------------------------
000010E8  =0000000D                114  CR          EQU         $0D
000010E8  =0000000A                115  LF          EQU         $0A
000010E8                           116  
000010E8  =00000002                117  BYTE        EQU         $2
000010E8  =00000004                118  WORD        EQU         $4
000010E8  =00000008                119  LONG        EQU         $8
000010E8                           120  
000010E8                           121  START_ADDR  DS.B        30                  ;Machine code start address stored here
00001106                           122  END_ADDR    DS.B        30                  ;Machine code end address stored here
00001124                           123  
00001124                           124  OP_ADDR     DS.B        30                  ;Storage to accumulate OPCODE address, name, and data string at            
00001142                           125  
00001142                           126  
00001142                           127  *-Strings---------------------------------------------------
00001142= 54 65 61 6D 20 56 ...    128  M_INTRO     DC.B        'Team Visual Basic',CR,LF
00001155= 4D 6F 74 6F 72 6F ...    129              DC.B        'Motorola 68000 Disassembler',CR,LF
00001172= 42 79 20 41 75 73 ...    130              DC.B        'By Austin Abeyta, Dylan Desmond, and Henry Hong',CR,LF,CR,LF,0 
000011A6                           131  
000011A6= 50 6C 65 61 73 65 ...    132  M_IN_RULES  DC.B        'Please limit address input to numeric (0-9) and/or alphabet A-F',CR,LF
000011E7= 50 6C 65 61 73 65 ...    133              DC.B        'Please limit address input to a range of [00005000-FFFFFFFF]!',CR,LF
00001226= 49 6E 70 75 74 20 ...    134              DC.B        'Input less than 8 digits will be padded on left',CR,LF    
00001257= 49 6E 70 75 74 20 ...    135              DC.B        'Input greater than 8 digits will be truncated on the right',CR,LF,CR,LF,0
00001296                           136              
00001296= 50 6C 65 61 73 65 ...    137  M_INPUT_S   DC.B        'Please Input the Starting Address (test code is ORG @ 7F00): ',CR,LF,0
000012D6= 50 6C 65 61 73 65 ...    138  M_INPUT_E   DC.B        'Please Input the Ending Address: ',CR,LF,0
000012FA                           139  
000012FA= 0D 0A 50 72 65 73 ...    140  M_WAIT      DC.B        CR,LF,'Press Enter to Continue!',CR,LF,0
00001317                           141  
00001317= 49 6E 70 75 74 20 ...    142  M_INV_INPUT DC.B        'Input address is invalid! Please re-enter: ',CR,LF,CR,LF,0
00001347                           143  
00001347= 45 52 52 3A 20 53 ...    144  M_ERR_ADDR1 DC.B        'ERR: START address > END address',CR,LF,0
0000136A= 45 52 52 3A 20 53 ...    145  M_ERR_ADDR2 DC.B        'ERR: START address too low, danger of overwriting program logic',CR,LF,0
000013AC= 45 52 52 3A 20 4F ...    146  M_ERR_ADDR3 DC.B        'ERR: ODD START address',CR,LF,0
000013C5= 45 52 52 3A 20 4F ...    147  M_ERR_ADDR4 DC.B        'ERR: ODD END address',CR,LF,0
000013DC                           148  
000013DC= 57 6F 75 6C 64 20 ...    149  M_NPROMPT   DC.B        'Would you like to run program again @ another address? (y/n)',CR,LF,0
0000141B= 0D 0A 49 6E 76 61 ...    150  M_ERR_GEN   DC.B        CR,LF,'Invalid input!',CR,LF,0  
0000142E= 44 6F 6E 65 21 0D ...    151  M_DONE      DC.B        'Done!',CR,LF,0  
00001436                           152  
00001436= 0D 0A 00                 153  M_NEWLINE   DC.B        '',CR,LF,0
00001439                           154                      
00001439                           155              
00001439                           156  
00001439                           157  *-Files-----------------------------------------------------
00001439                           158              INCLUDE     'TeamVisualBasic_Disassembler_Input.X68'            ;Include Input class file
00001439                           159  
0000143A  43F8 11A6                160  INPUT_ADDR  LEA         M_IN_RULES,A1       ;Load input restriction and rules msg
0000143E  103C 000E                161              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001442  4E4F                     162              TRAP        #15                 
00001444                           163  
00001444  43F8 1296                164              LEA         M_INPUT_S,A1        ;Load input request msg
00001448  103C 000E                165              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000144C  4E4F                     166              TRAP        #15
0000144E                           167              
0000144E  43F8 10E8                168              LEA         START_ADDR,A1
00001452  103C 0002                169              MOVE.B      #2,D0               ;Read string from keyboard and store in (A1)
00001456  4E4F                     170              TRAP        #15          
00001458                           171              
00001458  43F8 12D6                172              LEA         M_INPUT_E,A1        ;Load input request msg
0000145C  103C 000E                173              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001460  4E4F                     174              TRAP        #15
00001462                           175              
00001462  43F8 1106                176              LEA         END_ADDR,A1
00001466  103C 0002                177              MOVE.B      #2,D0               ;Read string from keyboard and store in (A1)
0000146A  4E4F                     178              TRAP        #15
0000146C                           179              
0000146C  4EB9 00001474            180              JSR         CNVRT_ADDR          ;Convert user ASCII input into usable hex addresses
00001472                           181  
00001472  4E75                     182              RTS                             ;Return to main START section
00001474                           183  
00001474                           184  
00001474  43F8 10E8                185  CNVRT_ADDR  LEA         START_ADDR,A1       ;Load start address into A1
00001478  163C 0008                186              MOVE.B      #8,D3               ;Load counter var into D3. Count down from 8
0000147C  4EB9 0000149E            187              JSR         C_LOOP
00001482  2A42                     188              MOVE.L      D2,A5               ;Save converted input in (A5)
00001484                           189              
00001484  4282                     190              CLR.L       D2                  ;Clear accumulator
00001486  43F8 1106                191              LEA         END_ADDR,A1         ;Load end address into A1
0000148A  163C 0008                192              MOVE.B      #8,D3               ;Load counter var into D3. Count down from 8
0000148E  4EB9 0000149E            193              JSR         C_LOOP
00001494  2C42                     194              MOVE.L      D2,A6               ;Save converted input in (A6)
00001496                           195                  
00001496  4EB9 0000151A            196              JSR         C_VALIDATE          ;Make sure input is not ODD and end addr is not before start
0000149C  4E75                     197              RTS                             ;Finish by RTSing back to main dissasembler file
0000149E                           198   
0000149E  1019                     199  C_LOOP      MOVE.B      (A1)+,D0            ;Load the ascii digit into D0
000014A0  B03C 00FF                200              CMP.B       #$FF,D0             ;If value is $FF, there is no digit
000014A4  6700 009A                201              BEQ         C_INVALID
000014A8  B03C 0000                202              CMP.B       #$00,D0             ;If value is $00, then probably done
000014AC  6700 0062                203              BEQ         CNVRT_DONE              
000014B0                           204              
000014B0  B63C 0000                205              CMP.B       #0,D3               ;If counter var == 0
000014B4  6700 005A                206              BEQ         CNVRT_DONE
000014B8  5303                     207              SUBI.B      #1,D3               ;Else, decrement counter var
000014BA                           208              
000014BA                           209              ;Determine whether num, upper, or lower case ascii a-f                                    
000014BA  B03C 0030                210              CMP.B       #$30,D0             ;If <30, not a number
000014BE  6D00 0080                211              BLT         C_INVALID           
000014C2  B03C 0046                212              CMP.B       #$46,D0             ;If >46, it's possibly a lowercase letter 
000014C6  6E00 0016                213              BGT         C_IS_LC             ;Check if it's a valid lower ascii letter
000014CA                           214              
000014CA  B03C 0040                215              CMP.B       #$40,D0             ;If <40, must be number
000014CE  6D00 0022                216              BLT         C_NUMERIC
000014D2  B03C 0041                217              CMP.B       #$41,D0             ;If >41, must be upper case ascii
000014D6  6E00 0024                218              BGT         C_ALPHA_U
000014DA                           219  
000014DA  6000 0064                220              BRA         C_INVALID           ;If none of the above, the input is not valid 
000014DE                           221              
000014DE  B03C 0061                222  C_IS_LC     CMP.B       #$61,D0             ;If >61, input is invalid
000014E2  6D00 005C                223              BLT         C_INVALID
000014E6  B03C 0066                224              CMP.B       #$66,D0             ;If >66, input is invalid
000014EA  6E00 0054                225              BGT         C_INVALID
000014EE                           226              
000014EE  6000 0016                227              BRA         C_ALPHA_L           ;Else must be a valid lowercase input
000014F2                           228  
000014F2  0400 0030                229  C_NUMERIC   SUBI.B      #$30,D0             ;Subtract 0x30 to convert to hex
000014F6  E98A                     230              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
000014F8  D400                     231              ADD.B       D0,D2               ;Accumulate digits into D2
000014FA  60A2                     232              BRA         C_LOOP  
000014FC                           233  
000014FC                           234  
000014FC  0400 0037                235  C_ALPHA_U   SUBI.B      #$37,D0             ;Subtract 0x37 to convert to hex
00001500  E98A                     236              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
00001502  D400                     237              ADD.B       D0,D2               ;Accumulate digits into D2
00001504  6098                     238              BRA         C_LOOP
00001506                           239  
00001506  0400 0057                240  C_ALPHA_L   SUBI.B      #$57,D0             ;Subtract 0x57 to convert to hex
0000150A  E98A                     241              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
0000150C  D400                     242              ADD.B       D0,D2               ;Accumulate digits into D2
0000150E  608E                     243              BRA         C_LOOP
00001510                           244          
00001510                           245                         
00001510  B63C 0008                246  CNVRT_DONE  CMP.B       #8,D3               ;If no input, invalid
00001514  6700 002A                247              BEQ         C_INVALID           
00001518                           248              
00001518  4E75                     249              RTS                             ;Else, done
0000151A                           250              
0000151A                           251  
0000151A  BDCD                     252  C_VALIDATE  CMPA.L      A5,A6               ;If end address < start address     
0000151C  6D00 002C                253              BLT         C_ERR1
00001520                           254                                                
00001520  BBFC 00005000            255              CMPA.L      #$00005000,A5       ;If start address is <0x5000
00001526  6D00 0036                256              BLT         C_ERR2
0000152A                           257              
0000152A  200D                     258              MOVE.L      A5,D0               ;Check rightmost input address bit
0000152C  0800 0000                259              BTST        #0,D0               ;If rightmost (least sig) bit is 1 (aka ODD address)
00001530  6600 0040                260              BNE         C_ERR3           
00001534                           261              
00001534  200E                     262              MOVE.L      A6,D0               ;Check rightmost input address bit
00001536  0800 0000                263              BTST        #0,D0               ;If rightmost (least sig) bit is 1 (aka ODD address)
0000153A  6600 004A                264              BNE         C_ERR4
0000153E                           265              
0000153E  4E75                     266              RTS                             ;If none of the above, input is valid
00001540                           267              
00001540  4EB9 0000159A            268  C_INVALID   JSR         C_ERR_BASE1         ;Clear screen and clear registers
00001546  6000 007E                269              BRA         C_ERR_BASE2         ;Print generic error msg and branch to start
0000154A                           270  
0000154A  4EB9 0000159A            271  C_ERR1      JSR         C_ERR_BASE1         ;Clear screen and registers
00001550  43F8 1347                272              LEA         M_ERR_ADDR1,A1      ;Load error message
00001554  103C 000E                273              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001558  4E4F                     274              TRAP        #15
0000155A                           275              
0000155A  6000 006A                276              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
0000155E                           277  
0000155E  4EB9 0000159A            278  C_ERR2      JSR         C_ERR_BASE1         ;Clear screen and registers
00001564  43F8 136A                279              LEA         M_ERR_ADDR2,A1      ;Load error message
00001568  103C 000E                280              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000156C  4E4F                     281              TRAP        #15
0000156E                           282              
0000156E  6000 0056                283              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
00001572                           284  
00001572                           285  
00001572                           286              
00001572  4EB9 0000159A            287  C_ERR3      JSR         C_ERR_BASE1         ;Clear screen and registers
00001578  43F8 13AC                288              LEA         M_ERR_ADDR3,A1      ;Load error message
0000157C  103C 000E                289              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001580  4E4F                     290              TRAP        #15
00001582                           291              
00001582  6000 0042                292              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
00001586                           293  
00001586  4EB9 0000159A            294  C_ERR4      JSR         C_ERR_BASE1         ;Clear screen and registers
0000158C  43F8 13C5                295              LEA         M_ERR_ADDR4,A1      ;Load error message
00001590  103C 000E                296              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001594  4E4F                     297              TRAP        #15
00001596                           298              
00001596  6000 002E                299              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
0000159A                           300  
0000159A                           301  
0000159A  103C 000B                302  C_ERR_BASE1 MOVE.B      #11,D0              ;Clear screen
0000159E  323C FF00                303              MOVE.W      #$FF00,D1
000015A2  4E4F                     304              TRAP        #15
000015A4                           305              
000015A4  4282                     306              CLR.L       D2
000015A6  4285                     307              CLR.L       D5
000015A8                           308                                
000015A8                           309  
000015A8  21FC FFFFFFFF 10E8       310              MOVE.L      #$FFFFFFFF,(START_ADDR)        
000015B0  21FC FFFFFFFF 1106       311              MOVE.L      #$FFFFFFFF,(END_ADDR)
000015B8  2A7C 00000000            312              MOVEA.L     #$00000000,A5       ;Clear registers
000015BE  2C7C 00000000            313              MOVEA.L     #$00000000,A6 
000015C4                           314       
000015C4  4E75                     315              RTS
000015C6                           316  
000015C6  43F8 1317                317  C_ERR_BASE2 LEA         M_INV_INPUT,A1      ;Load error message
000015CA  103C 000E                318              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000015CE  4E4F                     319              TRAP        #15
000015D0                           320              
000015D0  6000 FA2E                321              BRA         START 
000015D4                           322             
000015D4                           323  
000015D4                           324  
000015D4                           325  
000015D4                           326  -------------------- end include --------------------
000015D4                           327              INCLUDE     'TeamVisualBasic_Disassembler_OutputBuilder.X68'    ;Include OutputBuilder class file
000015D4                           328  
000015D4  4EB9 000015EC            329  BUILD_STR   JSR         PREPARE_OP          ;Define a location in memory to write an OPCODE string to
000015DA  4EB9 000015F2            330              JSR         GET_ADDR            ;Accumulate the OPCODE's address into the A4 string [0xADDR]
000015E0  4EB9 00001632            331              JSR         JT_START            ;Send OPCODE to jump table for decoding [OPCODE $OPERAND]
000015E6  18FC 0000                332              MOVE.B      #0,(A4)+            ;End the string with a 0 delimiter
000015EA                           333              
000015EA  4E75                     334              RTS                             ;Return back to main disassembler loop
000015EC                           335  
000015EC  387C 1124                336  PREPARE_OP  MOVE.W      #OP_ADDR,A4         ;Define a location in memory to write an OPCODE string to
000015F0  4E75                     337              RTS
000015F2                           338              
000015F2  200D                     339  GET_ADDR    MOVE.L      A5,D0               ;Save the address pointer into D0
000015F4  4282                     340              CLR.L       D2                  ;Clear D2
000015F6  143C 0008                341              MOVE.B      #8,D2               ;Counter var starts at 8
000015FA                           342              
000015FA  4EB9 0000160E            343  GA_LOOP     JSR         HEX_2_ASCII         ;Convert the hex to ascii for printing
00001600  5342                     344              SUBI        #1,D2               ;Decrement counter var
00001602  B43C 0000                345              CMP.B       #0,D2               ;Is counter var == 0?
00001606  6EF2                     346              BGT         GA_LOOP             ;If not, loop         
00001608                           347              
00001608  18FC 0009                348              MOVE.B      #09,(A4)+           ;Otherwise, we are done. Append a tab
0000160C  4E75                     349              RTS                             ;Return back to main disassembler loop    
0000160E                           350  
0000160E  E998                     351  HEX_2_ASCII ROL.L       #4,D0               ;Get the most significant hex digit into the right 4 bits
00001610  1200                     352              MOVE.B      D0,D1               ;Save that byte into D1
00001612  0241 000F                353              ANDI        #$0F,D1             ;Isolate the hex digit 
00001616                           354              
00001616  B23C 0009                355              CMP.B       #$9,D1              ;If hex digit is > 9
0000161A  6E00 0006                356              BGT         APPND_ALPHA         ;It is an alphabet ascii char. Branch
0000161E  6000 000A                357              BRA         APPND_NUM           ;Else it is a numeric ascii char. Branch
00001622                           358              
00001622  0601 0037                359  APPND_ALPHA ADDI.B      #$37,D1             ;Add $37 to make it a ascii alphabet char
00001626  18C1                     360              MOVE.B      D1,(A4)+            ;Append this character to string
00001628  4E75                     361              RTS           
0000162A                           362  
0000162A  0601 0030                363  APPND_NUM   ADDI.B      #$30,D1             ;Add $30 to make it a ascii numeric char
0000162E  18C1                     364              MOVE.B      D1,(A4)+            ;Append this character to string
00001630  4E75                     365              RTS
00001632                           366         
00001632                           367  
00001632                           368  
00001632                           369  
00001632                           370  
00001632                           371  
00001632                           372  -------------------- end include --------------------
00001632                           373              INCLUDE     'TeamVisualBasic_JumpTable.X68'                     ;Include Jump Table file
00001632                           374  
00001632  7E04                     375  JT_START    MOVE.L      #WORD,D7            *All OPCODEs takes up a WORD of space, save this into length counter D7
00001634  4286                     376              CLR.L       D6                  *Clear the D6 address increment counter
00001636  3015                     377              MOVE.W      (A5),D0             *Move OPCODE into D0 to bit shift
00001638                           378              
00001638  E848                     379              LSR.W       #4,D0               *Shift right 4 bits
0000163A  E848                     380              LSR.W       #4,D0               *shift right 4 bits
0000163C  E848                     381              LSR.W       #4,D0               *shift right 4 bits
0000163E                           382              
0000163E  0C40 0000                383              CMPI.W      #0,D0               *check if it falls into 0 bin
00001642  6700 007A                384              BEQ         BIN_0
00001646                           385      
00001646  0C40 0001                386              CMPI.W      #1,D0               *check if it is a MOVE
0000164A  6700 00A2                387              BEQ         BIN_MOVE
0000164E                           388              
0000164E  0C40 0002                389              CMPI.W      #2,D0               *check if it is a MOVE
00001652  6700 009A                390              BEQ         BIN_MOVE
00001656                           391              
00001656  0C40 0003                392              CMPI.W      #3,D0               *check if it is a MOVE
0000165A  6700 0092                393              BEQ         BIN_MOVE
0000165E                           394              
0000165E  0C40 0004                395              CMPI.W      #4,D0               *check if it falls into 4 bin
00001662  6700 00A6                396              BEQ         BIN_4
00001666                           397  
00001666  0C40 0005                398              CMPI.W      #5,D0               *check if it falls into 5 bin
0000166A  6700 00DC                399              BEQ         BIN_5
0000166E                           400  
0000166E  0C40 0006                401              CMPI.W      #6,D0               *check if it falls into 6 bin
00001672  6700 00D8                402              BEQ         BIN_6
00001676                           403  
00001676  0C40 0007                404              CMPI.W      #7,D0               *check if it falls into 7 bin
0000167A  6700 010A                405              BEQ         BIN_7
0000167E                           406  
0000167E  0C40 0008                407              CMPI.W      #8,D0               *check if it falls into 8 bin
00001682  6700 0106                408              BEQ         BIN_8
00001686                           409  
00001686  0C40 0009                410              CMPI.W      #9,D0               *check if it falls into 9 bin
0000168A  6700 0112                411              BEQ         BIN_9
0000168E                           412  
0000168E  0C40 000A                413              CMPI.W      #10,D0              *check if it falls into 10 bin
00001692  6700 010E                414              BEQ         BIN_10
00001696                           415  
00001696  0C40 000B                416              CMPI.W      #11,D0              *check if it falls into 11 bin
0000169A  6700 010A                417              BEQ         BIN_11
0000169E                           418  
0000169E  0C40 000C                419              CMPI.W      #12,D0              *check if it falls into 12 bin
000016A2  6700 0120                420              BEQ         BIN_12
000016A6                           421  
000016A6  0C40 000D                422              CMPI.W      #13,D0              *check if it falls into 12 bin
000016AA  6700 011C                423              BEQ         BIN_13
000016AE                           424  
000016AE  0C40 000E                425              CMPI.W      #14,D0              *check if it falls into 14 bin
000016B2  6700 0130                426              BEQ         BIN_14
000016B6                           427  
000016B6  0C40 000F                428              CMPI.W      #15,D0              *check if it falls into 15 bin
000016BA  6700 016E                429              BEQ         BIN_15
000016BE                           430  
000016BE  3015                     431  BIN_0       MOVE.W      (A5),D0             *reload opcode
000016C0  E048                     432              LSR.W       #8,D0               *shift bits to the right 8
000016C2  C07C 000F                433              AND.W       #$0F,D0             *Isolate the last 4 bits
000016C6                           434              
000016C6  0C40 000C                435              CMPI.W      #12,D0              *Check if the bit is C
000016CA  6700 0176                436              BEQ         CMPI                *if CMPI go to the subroutine
000016CE                           437              
000016CE  0C40 0000                438              CMPI.W      #0,D0               *Check if the bit is a 0
000016D2  6700 015A                439              BEQ         ORI                 *if ORI go to the subroutine
000016D6                           440              
000016D6  0C40 0008                441              CMPI.W      #8,D0               *Check if the bit is an 8
000016DA  6700 017E                442              BEQ         BCLR_IM             *if BCLR immediate go to subroutine
000016DE                           443              
000016DE  C07C 0001                444              AND.W       #$01,D0             *isolate the last bit
000016E2  0C40 0001                445              CMPI.W      #1,D0               *Check if the bit is a 1
000016E6  6700 018A                446              BEQ         BCLR_REG            *if BCLR register go to subroutine
000016EA                           447              
000016EA  6000 0416                448              BRA         DATA           
000016EE                           449  
000016EE  3015                     450  BIN_MOVE    MOVE.W      (A5),D0             *reload opcode
000016F0  EC48                     451              LSR.W       #6,D0               *shift bits to the right 6
000016F2  C07C 0007                452              AND.W       #$07,D0             *isolate the last 3 bits
000016F6  0C40 0001                453              CMPI.W      #1,D0               *check if the bits are 001
000016FA  6700 01AC                454              BEQ         MOVEA               *if MOVEA go to SUB
000016FE                           455              
000016FE  0C40 0007                456              CMPI.W      #7,D0               *check if the bits are 111
00001702  6700 03FE                457              BEQ         DATA                *if 111 must be DATA
00001706  6000 0182                458              BRA         MOVE                *otherwise must be MOVE
0000170A                           459              
0000170A  3015                     460  BIN_4       MOVE.W      (A5),D0             *reload opcode
0000170C  0C40 4E71                461              CMPI.W      #$4E71,D0           *check for no-op value
00001710  6700 01CC                462              BEQ         NOP                 *if NOP go to SUB
00001714                           463              
00001714  0C40 4E75                464              CMPI.W      #$4E75,D0           *Compare with a constant value for RTS      
00001718  6700 01D4                465              BEQ         RTS                 *if RTS go to RTS subroutine
0000171C                           466              
0000171C  E848                     467              LSR.W       #4,D0               *shift right 4 bits
0000171E  E848                     468              LSR.W       #4,D0               *shift right 4 bits
00001720  C07C 000F                469              AND.W       #$0F,D0             *bitmask first 4 bits  
00001724  0C40 000E                470              CMPI.W      #$E,D0              *compare final masked bits
00001728  6700 0204                471              BEQ         JSR                 *if it equals E it is JSR
0000172C                           472              
0000172C  0C40 0004                473              CMPI.W      #$4,D0              *check for defining bits
00001730  6700 020A                474              BEQ         NEG                 *branch to NEG routine
00001734                           475              
00001734  C07C 0001                476              AND.W       #$1,D0
00001738  0C40 0001                477              CMPI.W      #1,D0
0000173C  6700 01C6                478              BEQ         LEA
00001740                           479              
00001740  0C40 0000                480              CMPI.W      #0,D0
00001744  6700 01CC                481              BEQ         MOVEM
00001748                           482              
00001748  6000 0206                483  BIN_5       BRA         SUBQ                *SUBQ is the only option for this bin so branch to SUB
0000174C                           484  
0000174C  3015                     485  BIN_6       MOVE.W      (A5),D0             *reload fresh op code
0000174E  E848                     486              LSR.W       #4,D0               *shift right 4
00001750  E848                     487              LSR.W       #4,D0               *shift right 4
00001752  C07C 000F                488              AND.W       #$0F,D0             *Finds the condition code of the branch statement through bitmask
00001756                           489              
00001756  0C40 0000                490              CMPI.W      #0,D0               *check if the 4 bits == 0000
0000175A  6700 0252                491              BEQ         BRA_SUB             *branch to BRA SUB
0000175E                           492              
0000175E  0C40 0004                493              CMPI.W      #4,D0
00001762  6700 022E                494              BEQ         BCC                 *branch to BCC code 
00001766                           495                                                                       
00001766  0C40 000D                496              CMPI.W      #$D,D0
0000176A  6700 0234                497              BEQ         BLT                 *branch to BLT SUB            
0000176E                           498                                                                   
0000176E  0C40 0008                499              CMPI.W      #8,D0
00001772  6700 0210                500              BEQ         BVC                 *branch to BVC code
00001776                           501              
00001776  0C40 0005                502              CMPI.W      #5,D0
0000177A  6700 01FA                503              BEQ         BCS                 *branch to BCS code
0000177E                           504              
0000177E  0C40 000C                505              CMPI.W      #$C,D0
00001782  6700 01E4                506              BEQ         BGE                 *branch to BGE code
00001786                           507  
00001786  6000 037A                508  BIN_7       BRA        DATA                *If it goes into this bin it is DATA
0000178A                           509  
0000178A  3015                     510  BIN_8       MOVE.W      (A5),D0
0000178C  EC48                     511              LSR.W       #6,D0
0000178E  C07C 0007                512              AND.W       #$07,D0   
00001792  0C40 0007                513              CMPI.W      #7,D0
00001796  6700 0224                514              BEQ         DIVS_W
0000179A                           515              
0000179A  6000 0238                516              BRA         OR  
0000179E                           517              
0000179E  6000 0244                518  BIN_9       BRA         SUB                 *SUB is the only option for this bin so branch to SUB
000017A2                           519  
000017A2  6000 035E                520  BIN_10      BRA         DATA                *If it goes into this bin it is DATA
000017A6                           521  
000017A6  3015                     522  BIN_11      MOVE.W      (A5),D0             *reload opcode into D0
000017A8  E848                     523              LSR.W       #4,D0               *shift bits to the right 4
000017AA  E848                     524              LSR.W       #4,D0               *Shift bits to the right 4
000017AC  C07C 0001                525              AND.W       #$01,D0             *isolate the last bit
000017B0  0C40 0001                526              CMPI.W      #1,D0               *check if the bit is a 1
000017B4  6700 0242                527              BEQ         EOR                 *if EOR go to the SUB
000017B8                           528              
000017B8  0C40 0000                529              CMPI.W      #0,D0               *check if the bit is a 0
000017BC  6700 024E                530              BEQ         CMP                 *if CMP go to the SUB
000017C0                           531              
000017C0  6000 0340                532              BRA         DATA                *if neither EOR or CMP must be DATA
000017C4                           533              
000017C4  6000 025A                534  BIN_12      BRA         MULS_W              *MULS is the only option for this bin so branch to SUB
000017C8                           535  
000017C8  3015                     536  BIN_13      MOVE.W      (A5),D0             *reload opcode into D0
000017CA  EC48                     537              LSR.W       #6,D0               *shift bits to the right 6
000017CC  C07C 0007                538              AND.W       #$07,D0             *isolate the last 3 bits
000017D0  0C40 0003                539              CMPI.W      #$3,D0              *check if the bits are 011
000017D4  6700 0276                540              BEQ         ADDA                *if ADDA go to SUB        
000017D8                           541              
000017D8  0C40 0007                542              CMPI.W      #$7,D0              *check if the bits are 111
000017DC  6700 026E                543              BEQ         ADDA                *if ADDA go to SUB 
000017E0                           544                                                          
000017E0  6000 0256                545              BRA         ADD                 *if bits are not ADDA must be ADD and go to SUB
000017E4                           546              
000017E4  3015                     547  BIN_14      MOVE.W      (A5),D0             *Reload the opcode
000017E6  E648                     548              LSR.W       #3,D0               *shift bits down
000017E8  C07C 0003                549              AND.W       #$03,D0             *mask bits
000017EC  0C40 0001                550              CMPI.W      #1,D0               *determin which kind of shift it is
000017F0  6700 026C                551              BEQ         LOGIC_REG           *bra to logic shift register mode
000017F4                           552              
000017F4  0C40 0000                553              CMPI.W      #0,D0
000017F8  6700 027A                554              BEQ         ARITH_REG           *bra to arthimetic shift register mode
000017FC                           555              
000017FC  0C40 0003                556              CMPI.W      #3,D0
00001800  6700 0288                557              BEQ         ROTATE_REG          *bra to rotate register mode  
00001804                           558  
00001804  3015                     559              MOVE.W      (A5),D0             *Reload the opcode
00001806  E848                     560              LSR.W       #4,D0               *shift bits down
00001808  EA48                     561              LSR.W       #5,D0               *shift bits a total of 9
0000180A  C07C 0007                562              AND.W       #$07,D0             *mask bits
0000180E  0C40 0001                563              CMPI.W      #1,D0               *determin which kind of shift it is
00001812  6700 028C                564              BEQ         LOGIC_MEM           *bra to logic shift memory mode
00001816                           565              
00001816  0C40 0000                566              CMPI.W      #0,D0
0000181A  6700 029A                567              BEQ         ARITH_MEM           *bra to arthimetic shift memory mode
0000181E                           568              
0000181E  0C40 0003                569              CMPI.W      #3,D0
00001822  6700 02A8                570              BEQ         ROTATE_MEM          *bra to rotate MEM mode    
00001826                           571              
00001826  6000 02DA                572              BRA         DATA                *if not a shift must be DATA 
0000182A                           573                                                                  
0000182A                           574  
0000182A  6000 02D6                575  BIN_15      BRA        DATA                *IF it goes into this bin it is DATA
0000182E                           576                                                                                               
0000182E                           577  
0000182E                           578  
0000182E  18FC 004F                579  ORI         MOVE.B      #'O',(A4)+          *Load OPCODE string into (A4)
00001832  18FC 0052                580              MOVE.B      #'R',(A4)+
00001836  18FC 0049                581              MOVE.B      #'I',(A4)+
0000183A                           582              
0000183A  4EB9 00001B8C            583              JSR         GET_SIZE_67
00001840                           584           
00001840  4E75                     585              RTS                             *Return to OutputBuilder file
00001842                           586              
00001842  18FC 0043                587  CMPI        MOVE.B      #'C',(A4)+          *Load OPCODE string into (A4)
00001846  18FC 004D                588              MOVE.B      #'M',(A4)+
0000184A  18FC 0050                589              MOVE.B      #'P',(A4)+
0000184E  18FC 0049                590              MOVE.B      #'I',(A4)+
00001852                           591              
00001852  4EB9 00001B8C            592              JSR         GET_SIZE_67 
00001858                           593     
00001858  4E75                     594              RTS                             *Return to OutputBuilder file
0000185A                           595              
0000185A  18FC 0042                596  BCLR_IM     MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
0000185E  18FC 0043                597              MOVE.B      #'C',(A4)+
00001862  18FC 004C                598              MOVE.B      #'L',(A4)+
00001866  18FC 0052                599              MOVE.B      #'R',(A4)+
0000186A                           600              
0000186A  4EB9 00001C4C            601              JSR         APPND_BYTE          *must be a byte if it is a BCLR on immediate data
00001870                           602              
00001870  4E75                     603              RTS                             *Return to OutputBuilder file
00001872                           604              
00001872  18FC 0042                605  BCLR_REG    MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001876  18FC 0043                606              MOVE.B      #'C',(A4)+
0000187A  18FC 004C                607              MOVE.B      #'L',(A4)+
0000187E  18FC 0052                608              MOVE.B      #'R',(A4)+
00001882                           609              
00001882  4EB9 00001C64            610              JSR         APPND_LONG          *must be a long if it is a BCLR on a register
00001888                           611              
00001888  4E75                     612              RTS                             *Return to OutputBuilder file
0000188A                           613  
0000188A                           614  
0000188A  18FC 004D                615  MOVE        MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
0000188E  18FC 004F                616              MOVE.B      #'O',(A4)+
00001892  18FC 0056                617              MOVE.B      #'V',(A4)+
00001896  18FC 0045                618              MOVE.B      #'E',(A4)+
0000189A                           619              
0000189A  4EB9 00001BCC            620              JSR         MOVE_SIZE           *Append size
000018A0  4EB9 00001C70            621              JSR         DECODE_A            *Append Decode information
000018A6                           622              
000018A6  4E75                     623              RTS                             *Return to OutputBuilder file
000018A8                           624             
000018A8                           625              
000018A8  18FC 004D                626  MOVEA       MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
000018AC  18FC 004F                627              MOVE.B      #'O',(A4)+
000018B0  18FC 0056                628              MOVE.B      #'V',(A4)+
000018B4  18FC 0045                629              MOVE.B      #'E',(A4)+
000018B8  18FC 0041                630              MOVE.B      #'A',(A4)+
000018BC                           631              
000018BC  3015                     632              MOVE.W      (A5),D0             *reload OPCODE into D0
000018BE  E848                     633              LSR.W       #4,D0               *Isolate leftmost hex digit
000018C0  E848                     634              LSR.W       #4,D0
000018C2  E848                     635              LSR.W       #4,D0               *shift bits a total of 12 right
000018C4  C07C 0003                636              AND.W       #$03,D0             *isolate the last 2 bits
000018C8                           637              
000018C8  0C40 0001                638              CMPI.W      #1,D0               *If == 1, invalid OPCODE
000018CC  6700 0234                639              BEQ         DATA                *Operation not supported for MOVEA
000018D0                           640              
000018D0  4EB9 00001BCC            641              JSR         MOVE_SIZE           *Append size
000018D6  4EB9 00001C70            642              JSR         DECODE_A            *Append Decode information
000018DC                           643  
000018DC  4E75                     644              RTS                             *Return to OutputBuilder file
000018DE                           645  
000018DE  5447                     646  NOP         ADDI        #BYTE,D7            *NOP is 2 Bytes; Increment length var by 2
000018E0  18FC 004E                647              MOVE.B      #'N',(A4)+          *Load OPCODE string into (A4)
000018E4  18FC 004F                648              MOVE.B      #'O',(A4)+
000018E8  18FC 0050                649              MOVE.B      #'P',(A4)+
000018EC                           650              
000018EC  4E75                     651              RTS                             *Return to OutputBuilder file
000018EE                           652              
000018EE                           653              
000018EE  18FC 0052                654  RTS         MOVE.B      #'R',(A4)+          *Load OPCODE string into (A4)
000018F2  18FC 0054                655              MOVE.B      #'T',(A4)+
000018F6  18FC 0053                656              MOVE.B      #'S',(A4)+ 
000018FA                           657  
000018FA  1C3C 0004                658              MOVE.B      #WORD,D6            *Increment the size counter D6 by a WORD 
000018FE  1E3C 0004                659              MOVE.B      #WORD,D7            *Increment the size counter D7 by a WORD
00001902                           660              
00001902  4E75                     661              RTS                             *Return to OutputBuilder file
00001904                           662              
00001904  18FC 004C                663  LEA         MOVE.B      #'L',(A4)+          *Load OPCODE string into (A4)
00001908  18FC 0045                664              MOVE.B      #'E',(A4)+
0000190C  18FC 0041                665              MOVE.B      #'A',(A4)+   
00001910                           666          
00001910  4E75                     667              RTS                             *Return to OutputBuilder file
00001912                           668              
00001912  18FC 004D                669  MOVEM       MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
00001916  18FC 004F                670              MOVE.B      #'O',(A4)+
0000191A  18FC 0056                671              MOVE.B      #'V',(A4)+   
0000191E  18FC 0045                672              MOVE.B      #'E',(A4)+
00001922  18FC 004D                673              MOVE.B      #'M',(A4)+
00001926                           674  
00001926  4EB9 00001BB0            675              JSR         MOVEM_SIZE          *Append size
0000192C                           676              
0000192C  4E75                     677              RTS                             *Return to OutputBuilder file
0000192E                           678              
0000192E  18FC 004A                679  JSR         MOVE.B      #'J',(A4)+          *Load OPCODE string into (A4)
00001932  18FC 0053                680              MOVE.B      #'S',(A4)+
00001936  18FC 0052                681              MOVE.B      #'R',(A4)+   
0000193A                           682          
0000193A                           683  
0000193A  4E75                     684              RTS                             *Return to OutputBuilder file
0000193C                           685              
0000193C  18FC 004E                686  NEG         MOVE.B      #'N',(A4)+          *Load OPCODE string into (A4)
00001940  18FC 0045                687              MOVE.B      #'E',(A4)+
00001944  18FC 0047                688              MOVE.B      #'G',(A4)+   
00001948                           689          
00001948  4EB9 00001B8C            690              JSR         GET_SIZE_67         *Append size
0000194E                           691              
0000194E  4E75                     692              RTS                             *Return to OutputBuilder file
00001950                           693               
00001950                           694              
00001950  18FC 0053                695  SUBQ        MOVE.B      #'S',(A4)+          *Load OPCODE string into (A4)
00001954  18FC 0055                696              MOVE.B      #'U',(A4)+
00001958  18FC 0042                697              MOVE.B      #'B',(A4)+   
0000195C  18FC 0051                698              MOVE.B      #'Q',(A4)+ 
00001960                           699                                         
00001960  4EB9 00001B8C            700              JSR         GET_SIZE_67         *Append size
00001966                           701              
00001966  4E75                     702              RTS                             *Return to OutputBuilder file
00001968                           703             
00001968  18FC 0042                704  BGE         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
0000196C  18FC 0047                705              MOVE.B      #'G',(A4)+
00001970  18FC 0045                706              MOVE.B      #'E',(A4)+   
00001974                           707          
00001974  4E75                     708              RTS                             *Return to OutputBuilder file
00001976                           709              
00001976  18FC 0042                710  BCS         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
0000197A  18FC 0043                711              MOVE.B      #'C',(A4)+
0000197E  18FC 0053                712              MOVE.B      #'S',(A4)+   
00001982                           713          
00001982  4E75                     714              RTS                             *Return to OutputBuilder file
00001984                           715              
00001984  18FC 0042                716  BVC         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001988  18FC 0056                717              MOVE.B      #'V',(A4)+
0000198C  18FC 0043                718              MOVE.B      #'C',(A4)+   
00001990                           719          
00001990  4E75                     720              RTS                             *Return to OutputBuilder file
00001992                           721              
00001992  18FC 0042                722  BCC         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001996  18FC 0043                723              MOVE.B      #'C',(A4)+
0000199A  18FC 0043                724              MOVE.B      #'C',(A4)+   
0000199E                           725          
0000199E  4E75                     726              RTS                             *Return to OutputBuilder file
000019A0                           727              
000019A0  18FC 0042                728  BLT         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
000019A4  18FC 004C                729              MOVE.B      #'L',(A4)+
000019A8  18FC 0054                730              MOVE.B      #'T',(A4)+   
000019AC                           731          
000019AC  4E75                     732              RTS                             *Return to OutputBuilder file
000019AE                           733  
000019AE  18FC 0042                734  BRA_SUB     MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
000019B2  18FC 0052                735              MOVE.B      #'R',(A4)+
000019B6  18FC 0041                736              MOVE.B      #'A',(A4)+   
000019BA                           737          
000019BA  4E75                     738              RTS                             *Return to OutputBuilder file
000019BC                           739              
000019BC  18FC 0044                740  DIVS_W      MOVE.B      #'D',(A4)+          *Load OPCODE string into (A4)
000019C0  18FC 0049                741              MOVE.B      #'I',(A4)+
000019C4  18FC 0056                742              MOVE.B      #'V',(A4)+   
000019C8  18FC 0053                743              MOVE.B      #'S',(A4)+
000019CC                           744              
000019CC  4EB9 00001C58            745              JSR         APPND_WORD
000019D2                           746          
000019D2  4E75                     747              RTS                             *Return to OutputBuilder file
000019D4                           748              
000019D4  18FC 004F                749  OR          MOVE.B      #'O',(A4)+          *Load OPCODE string into (A4)
000019D8  18FC 0052                750              MOVE.B      #'R',(A4)+
000019DC                           751             
000019DC  4EB9 00001BF4            752              JSR         SIZE_678            *Append size
000019E2                           753              
000019E2  4E75                     754              RTS                             *Return to OutputBuilder file
000019E4                           755              
000019E4  18FC 0053                756  SUB         MOVE.B      #'S',(A4)+          *Load OPCODE string into (A4)
000019E8  18FC 0055                757              MOVE.B      #'U',(A4)+
000019EC  18FC 0042                758              MOVE.B      #'B',(A4)+   
000019F0                           759  
000019F0  4EB9 00001BF4            760              JSR         SIZE_678            *Append size
000019F6                           761              
000019F6  4E75                     762              RTS                             *Return to OutputBuilder file
000019F8                           763              
000019F8  18FC 0045                764  EOR         MOVE.B      #'E',(A4)+          *Load OPCODE string into (A4)
000019FC  18FC 004F                765              MOVE.B      #'O',(A4)+
00001A00  18FC 0052                766              MOVE.B      #'R',(A4)+   
00001A04                           767  
00001A04  4EB9 00001B8C            768              JSR         GET_SIZE_67         *Append size
00001A0A                           769              
00001A0A  4E75                     770              RTS                             *Return to OutputBuilder file
00001A0C                           771  
00001A0C  18FC 0043                772  CMP         MOVE.B      #'C',(A4)+          *Load OPCODE string into (A4)
00001A10  18FC 004D                773              MOVE.B      #'M',(A4)+
00001A14  18FC 0050                774              MOVE.B      #'P',(A4)+   
00001A18                           775  
00001A18  4EB9 00001B8C            776              JSR         GET_SIZE_67         *Append size
00001A1E  4E75                     777              RTS                             *Return to OutputBuilder file
00001A20                           778  
00001A20  18FC 004D                779  MULS_W      MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
00001A24  18FC 0055                780              MOVE.B      #'U',(A4)+
00001A28  18FC 004C                781              MOVE.B      #'L',(A4)+   
00001A2C  18FC 0053                782              MOVE.B      #'S',(A4)+
00001A30                           783              
00001A30  4EB9 00001C58            784              JSR         APPND_WORD
00001A36                           785              
00001A36  4E75                     786              RTS                             *Return to OutputBuilder file
00001A38                           787              
00001A38  18FC 0041                788  ADD         MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
00001A3C  18FC 0044                789              MOVE.B      #'D',(A4)+
00001A40  18FC 0044                790              MOVE.B      #'D',(A4)+   
00001A44                           791              
00001A44  4EB9 00001BF4            792              JSR         SIZE_678            *Append size
00001A4A  4E75                     793              RTS                             *Return to OutputBuilder file
00001A4C                           794              
00001A4C                           795  
00001A4C                           796  
00001A4C  18FC 0041                797  ADDA        MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
00001A50  18FC 0044                798              MOVE.B      #'D',(A4)+
00001A54  18FC 0044                799              MOVE.B      #'D',(A4)+
00001A58  18FC 0041                800              MOVE.B      #'A',(A4)+   
00001A5C                           801                  
00001A5C  4E75                     802              RTS                             *Return to OutputBuilder file
00001A5E                           803       
00001A5E  18FC 004C                804  LOGIC_REG   MOVE.B      #'L',(A4)+          *Load OPCODE string into (A4)
00001A62  18FC 0053                805              MOVE.B      #'S',(A4)+
00001A66                           806                     
00001A66  4EB9 00001AE2            807              JSR         RIGHTORLEFT         *Append (L/R)
00001A6C  4EB9 00001B8C            808              JSR         GET_SIZE_67         *Append Size
00001A72                           809              
00001A72  4E75                     810              RTS                             *Return to OutputBuilder file           
00001A74                           811  
00001A74  18FC 0041                812  ARITH_REG   MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
00001A78  18FC 0053                813              MOVE.B      #'S',(A4)+
00001A7C                           814              
00001A7C  4EB9 00001AE2            815              JSR         RIGHTORLEFT         *Append (L/R)
00001A82  4EB9 00001B8C            816              JSR         GET_SIZE_67         *Append Size
00001A88                           817  
00001A88  4E75                     818              RTS         
00001A8A                           819                  
00001A8A  18FC 0052                820  ROTATE_REG  MOVE.B      #'R',(A4)+          *Load OPCODE string into (A4)
00001A8E  18FC 004F                821              MOVE.B      #'O',(A4)+
00001A92                           822            
00001A92  4EB9 00001AE2            823              JSR         RIGHTORLEFT         *Append (L/R)
00001A98  4EB9 00001B8C            824              JSR         GET_SIZE_67         *Append Size
00001A9E                           825              
00001A9E  4E75                     826              RTS
00001AA0                           827              
00001AA0  18FC 004C                828  LOGIC_MEM   MOVE.B      #'L',(A4)+          *Load OPCODE string into (A4)
00001AA4  18FC 0053                829              MOVE.B      #'S',(A4)+
00001AA8                           830                     
00001AA8  4EB9 00001AE2            831              JSR         RIGHTORLEFT         *Append (L/R)
00001AAE  4EB9 00001C58            832              JSR         APPND_WORD          *only supports word sized operations on memory
00001AB4                           833              
00001AB4  4E75                     834              RTS                             *Return to OutputBuilder file           
00001AB6                           835  
00001AB6  18FC 0041                836  ARITH_MEM   MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
00001ABA  18FC 0053                837              MOVE.B      #'S',(A4)+
00001ABE                           838              
00001ABE  4EB9 00001AE2            839              JSR         RIGHTORLEFT         *Append (L/R)
00001AC4  4EB9 00001C58            840              JSR         APPND_WORD          *only supports word sized operations on memory
00001ACA                           841  
00001ACA  4E75                     842              RTS         
00001ACC                           843                  
00001ACC  18FC 0052                844  ROTATE_MEM  MOVE.B      #'R',(A4)+          *Load OPCODE string into (A4)
00001AD0  18FC 004F                845              MOVE.B      #'O',(A4)+
00001AD4                           846            
00001AD4  4EB9 00001AE2            847              JSR         RIGHTORLEFT         *Append (L/R)
00001ADA  4EB9 00001C58            848              JSR         APPND_WORD          *only supports word sized operations on memory
00001AE0                           849              
00001AE0  4E75                     850              RTS
00001AE2                           851                
00001AE2  3010                     852  RIGHTORLEFT MOVE.W      (A0),D0             *reload op
00001AE4  E148                     853              LSL.W       #8,D0               *shift until dr bit is reached
00001AE6  B07C 0000                854              CMP.W       #0,D0               *check if left
00001AEA  6700 000A                855              BEQ         LEFT
00001AEE                           856              
00001AEE  B07C 0001                857              CMP.W       #1,D0               *check if right
00001AF2  6700 0008                858              BEQ         RIGHT  
00001AF6                           859                                                
00001AF6  18FC 004C                860  LEFT        MOVE.B      #'L',(A4)+          *Load directional string 'L' into (A4)
00001AFA  4E75                     861              RTS                      
00001AFC                           862                       
00001AFC  18FC 0052                863  RIGHT       MOVE.B      #'R',(A4)+          *Load directional string 'R' into (A4)
00001B00  4E75                     864              RTS
00001B02                           865                                    
00001B02  18FC 0044                866  DATA        MOVE.B      #'D',(A4)+          *Write DATA into string
00001B06  18FC 0041                867              MOVE.B      #'A',(A4)+          
00001B0A  18FC 0054                868              MOVE.B      #'T',(A4)+          
00001B0E  18FC 0041                869              MOVE.B      #'A',(A4)+         
00001B12  18FC 0009                870              MOVE.B      #09,(A4)+           *Write a tab into string
00001B16                           871              
00001B16  1C3C 0004                872              MOVE.B      #WORD,D6            *Increment the size counter D6 by a WORD 
00001B1A  1E3C 0004                873              MOVE.B      #WORD,D7            *Increment the size counter D7 by a WORD 
00001B1E  4EB9 00001B36            874              JSR         WRITE_DATA          *Write D7 worth of OPCODE data that couldn't be decoded
00001B24                           875                                    
00001B24  4E75                     876              RTS                             *Return program flow back to Dissasembler file
00001B26                           877              
00001B26  5507                     878  P_OPERAND   SUBI.B      #2,D7               *Subtract 2 from D7 size counter to account for and skip OPCODE's data 
00001B28  544D                     879              ADDA        #2,A5               *Increment current address pointer to skip over OPCODE
00001B2A  4EB9 00001B36            880              JSR         WRITE_DATA          *WRITE_DATA writes everything after the OPCODE to (A4)
00001B30                           881              
00001B30  5407                     882              ADDI.B      #2,D7               *Add the 2 back to D7 size counter
00001B32  554D                     883              SUBA        #2,A5               *Decrement current address point to point to the start of opcode again
00001B34                           884              
00001B34  4E75                     885              RTS
00001B36                           886              
00001B36  2607                     887  WRITE_DATA  MOVE.L      D7,D3               *D3 is counter var. Same size as the length specified in D7
00001B38  0C03 0000                888  WRITE_LOOP  CMPI.B      #0,D3               *is D3 == 0?
00001B3C  6700 004A                889              BEQ         WRITE_DONE          *then we are done writing the string 
00001B40                           890              
00001B40  5543                     891              SUBI        #BYTE,D3            *Decrement counter var by 1 byte                       
00001B42                           892  
00001B42  1415                     893              MOVE.B      (A5),D2             *Move 1 byte of OPCODE/OPERAND data into D2                   
00001B44  E84A                     894              LSR.W       #4,D2               *Isolate left 4 bits of first byte in D1             
00001B46  4EB9 00001B5C            895              JSR         WRITE_DIGIT         *Save the left 4 bits in the byte as an ascii char
00001B4C                           896          
00001B4C  1415                     897              MOVE.B      (A5),D2             *Move 1 byte of OPCODE/OPERAND data into D2   
00001B4E  0202 000F                898              ANDI.B      #$0F,D2             *Isolate right 4 of the first byte in D2                                     
00001B52  4EB9 00001B5C            899              JSR         WRITE_DIGIT         *Save the right 4 bits in the byte as an ascii char
00001B58                           900              
00001B58  524D                     901              ADDA        #1,A5               *Increment A5
00001B5A                           902              
00001B5A  60DC                     903              BRA         WRITE_LOOP          *Go to start of loop, and write the next bytes worth of digits          
00001B5C                           904                     
00001B5C  B43C 0009                905  WRITE_DIGIT CMP.B       #$09,D2             *Is D2 alphabet or number?
00001B60  6E00 0006                906              BGT         W_ALPHA             *If D2 > #$09, it's alphabet
00001B64  6000 000A                907              BRA         W_NUM               *Else its numeric             
00001B68                           908              
00001B68  4EB9 00001B78            909  W_ALPHA     JSR         CNVRT_ALPHA         *Convert the half byte to ascii, and write to string
00001B6E  4E75                     910              RTS                             *Go back to write_loop
00001B70                           911  
00001B70  4EB9 00001B78            912  W_NUM       JSR         CNVRT_ALPHA         *Convert the half byte to ascii, and write to string
00001B76  4E75                     913              RTS                             *Go back to write_loop           
00001B78                           914              
00001B78  0602 0037                915  CNVRT_ALPHA ADDI.B      #$37,D2             *Convert to ASCII
00001B7C  18C2                     916              MOVE.B      D2,(A4)+            *Write to string
00001B7E  4E75                     917              RTS
00001B80                           918  
00001B80  0602 0030                919  CNVRT_NUM   ADDI.B      #$30,D2             *Convert to ASCII
00001B84  18C2                     920              MOVE.B      D2,(A4)+            *Write to string
00001B86  4E75                     921              RTS           
00001B88                           922              
00001B88  9AC7                     923  WRITE_DONE  SUB.W       D7,A5               *Bring A5 pointer back to where it was before writing the DATA
00001B8A  4E75                     924              RTS                             *Finished writing       
00001B8C                           925  
00001B8C                           926  
00001B8C  3015                     927  GET_SIZE_67 MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001B8E  EC48                     928              LSR.W       #6,D0               *shift bits right 6
00001B90  C07C 0003                929              AND.W       #$03,D0             *Isolate last 2 bits
00001B94  0C40 0000                930              CMPI.W      #0,D0
00001B98  6700 00B2                931              BEQ         APPND_BYTE          *Is a Byte operation
00001B9C  0C40 0001                932              CMPI.W      #1,D0
00001BA0  6700 00B6                933              BEQ         APPND_WORD          *Is a Word operation
00001BA4  0C40 0002                934              CMPI.W      #2,D0
00001BA8  6700 00BA                935              BEQ         APPND_LONG          *Is a Long operation
00001BAC  6000 FF54                936              BRA         DATA                *Not a valid size must be data 
00001BB0                           937  
00001BB0  3015                     938  MOVEM_SIZE  MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001BB2  EC48                     939              LSR.W       #6,D0               *shift bits right 6
00001BB4  C07C 0001                940              AND.W       #$01,D0             *isolate last bit
00001BB8  0C40 0000                941              CMPI.W      #0,D0
00001BBC  6700 009A                942              BEQ         APPND_WORD          *is a word operation
00001BC0  0C40 0001                943              CMPI.W      #1,D0
00001BC4  6700 009E                944              BEQ         APPND_LONG          *is a long operation
00001BC8  6000 FF38                945              BRA         DATA
00001BCC                           946              
00001BCC  3015                     947  MOVE_SIZE   MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001BCE  E848                     948              LSR.W       #4,D0               *shift bits right 4
00001BD0  E848                     949              LSR.W       #4,D0
00001BD2  E848                     950              LSR.W       #4,D0               *shift bits a total of 12 right
00001BD4  C07C 0003                951              AND.W       #$03,D0             *isolate the last 2 bits
00001BD8  0C40 0001                952              CMPI.W      #1,D0               
00001BDC  6700 006E                953              BEQ         APPND_BYTE          *is a byte operation
00001BE0  0C40 0003                954              CMPI.W      #3,D0               
00001BE4  6700 0072                955              BEQ         APPND_WORD          *is a word operation
00001BE8  0C40 0002                956              CMPI.W      #2,D0               
00001BEC  6700 0076                957              BEQ         APPND_LONG          *is a long operation
00001BF0  6000 FF10                958              BRA         DATA
00001BF4                           959              
00001BF4  3015                     960  SIZE_678    MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001BF6  EC48                     961              LSR.W       #6,D0               *shift the bits right 6
00001BF8  C07C 0007                962              AND.W       #$07,D0             *isolate the last 3 bits
00001BFC  0C40 0000                963              CMPI.W      #0,D0               
00001C00  6700 004A                964              BEQ         APPND_BYTE          *is a byte operation
00001C04  0C40 0004                965              CMPI.W      #4,D0
00001C08  6700 0042                966              BEQ         APPND_BYTE          *is a byte operation
00001C0C  0C40 0001                967              CMPI.W      #1,D0               
00001C10  6700 0046                968              BEQ         APPND_WORD          *is a word operation
00001C14  0C40 0005                969              CMPI.W      #5,D0               
00001C18  6700 003E                970              BEQ         APPND_WORD          *is a word operation
00001C1C  0C40 0002                971              CMPI.W      #2,D0
00001C20  6700 0042                972              BEQ         APPND_LONG          *is a long operation
00001C24  0C40 0006                973              CMPI.W      #6,D0
00001C28  6700 003A                974              BEQ         APPND_LONG          *is a long operation
00001C2C  6000 FED4                975              BRA         DATA                *is not one of the supported sizes
00001C30                           976              
00001C30  3015                     977  ADDA_SIZE   MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001C32  EC48                     978              LSR.W       #6,D0               *shift the bits right 6
00001C34  C07C 0007                979              AND.W       #$07,D0             *isolate the last 3 bits
00001C38  0C40 0003                980              CMPI.W      #3,D0
00001C3C  6700 001A                981              BEQ         APPND_WORD          *is a word operation
00001C40  0C40 0007                982              CMPI.W      #7,D0
00001C44  6700 001E                983              BEQ         APPND_LONG          *is a long operation
00001C48  6000 FEB8                984              BRA         DATA                *is not one of the supported sizes
00001C4C                           985                     
00001C4C                           986  
00001C4C  18FC 002E                987  APPND_BYTE  MOVE.B      #'.',(A4)+
00001C50  18FC 0042                988              MOVE.B      #'B',(A4)+          *load size into (A4)
00001C54  5407                     989              ADDI.B      #2,D7               *add OPCODE length to D7
00001C56  4E75                     990              RTS
00001C58                           991  
00001C58  18FC 002E                992  APPND_WORD  MOVE.B      #'.',(A4)+
00001C5C  18FC 0057                993              MOVE.B      #'W',(A4)+          *load size into (A4)
00001C60  5807                     994              ADDI.B      #4,D7               *add OPCODE length to D7
00001C62  4E75                     995              RTS
00001C64                           996  
00001C64  18FC 002E                997  APPND_LONG  MOVE.B      #'.',(A4)+
00001C68  18FC 004C                998              MOVE.B      #'L',(A4)+          *load size into (A4)
00001C6C  5007                     999              ADDI.B      #8,D7               *add OPCODE length to D7
00001C6E  4E75                    1000              RTS                
00001C70                          1001              
00001C70                          1002              INCLUDE     'TeamVisualBasic_OP_Decoder.X68'    ;Helper file for jump table
00001C70                          1003  
00001C70                          1004  
00001C70                          1005  
00001C70  18FC 0009               1006  DECODE_A    MOVE.B      #9,(A4)+          *tab after op code
00001C74  3C3C 0002               1007              MOVE.W      #2,D6               *Initilize opcode length to 2
00001C78  3415                    1008              MOVE.W      (A5),D2             *Copy OPCODE into D2
00001C7A  E64A                    1009              LSR.W       #3,D2               *Shift right 3 - isolate Src Mode
00001C7C  C47C 0007               1010              AND.W       #$0007,D2           *Mask out other bits
00001C80  4EB9 00001E28           1011              JSR         GET_SRCMODE         *Append SRC string to (A4)          
00001C86  18FC 002C               1012              MOVE.B      #',',(A4)+
00001C8A                          1013              
00001C8A  3415                    1014              MOVE.W      (A5),D2             *Recopy OPCODE into D2  
00001C8C  EC4A                    1015              LSR.W       #6,D2               *Shift right 6 - isolate Dest Mode
00001C8E  C47C 0007               1016              AND.W       #$0007,D2           *Mask out other bits
00001C92  4EB9 00001E68           1017              JSR         GET_DSTMODE         *Append DST string to (A4)
00001C98                          1018              
00001C98  4E75                    1019              RTS                             *Return back to jump table
00001C9A                          1020  
00001C9A                          1021                 
00001C9A  18FC 0009               1022  DECODE_B    MOVE.B      #9,(A4)+          *tab after op code
00001C9E  3C3C 0002               1023              MOVE.W      #2,D6               *Initilize opcode length to 2
00001CA2  3415                    1024              MOVE.W      (A5),D2
00001CA4  EC4A                    1025              LSR.W       #6,D2
00001CA6  C478 0003               1026              AND.W       $0003,D2
00001CAA  B47C 0003               1027              CMP.W       #3,D2
00001CAE  6700 002E               1028              BEQ         B_ADDMODE
00001CB2  3415                    1029              MOVE.W      (A5),D2             
00001CB4  EA4A                    1030              LSR.W       #5,D2
00001CB6  C47C 0003               1031              AND.W       #$0003,D2
00001CBA  B47C 0001               1032              CMP.W       #1,D2
00001CBE  6700 003C               1033              BEQ         B_SCOUNT
00001CC2  B47C 0002               1034              CMP.W       #2,D2
00001CC6  6700 004C               1035              BEQ         B_DATAREG
00001CCA  18FC 0044               1036              MOVE.B      #'D',(A4)+
00001CCE  3415                    1037              MOVE.W      (A5),D2
00001CD0  C47C 0007               1038              AND.W       #$0007,D2
00001CD4  3A02                    1039              MOVE.W      D2,D5
00001CD6  4EB9 0000205C           1040              JSR         PrintD5Num
00001CDC  4E75                    1041              RTS
00001CDE                          1042  
00001CDE                          1043  B_ADDMODE
00001CDE  3415                    1044             MOVE.W       (A5),D2
00001CE0  E64A                    1045             LSR.W        #3,D2
00001CE2  C47C 0007               1046             AND.W        #$0007,D2
00001CE6  4EB9 00001E68           1047             JSR          GET_DSTMODE
00001CEC  3415                    1048             MOVE.W       (A5),D2
00001CEE  C47C 0007               1049             AND.W        #$0007,D2
00001CF2  3A02                    1050             MOVE.W       D2,D5
00001CF4  4EB9 0000205C           1051             JSR          PrintD5Num
00001CFA  4E75                    1052             RTS
00001CFC                          1053              
00001CFC                          1054              
00001CFC                          1055  
00001CFC  3415                    1056  B_SCOUNT    MOVE.W      (A5),D2
00001CFE  EC4A                    1057              LSR.W       #6,D2
00001D00  E64A                    1058              LSR.W       #3,D2
00001D02  C47C 0007               1059              AND.W       #$0007,D2
00001D06  3A02                    1060              MOVE.W      D2,D5
00001D08  18FC 0023               1061              MOVE.B      #'#',(A4)+
00001D0C  4EB9 0000205C           1062              JSR         PrintD5Num
00001D12  4E75                    1063              RTS
00001D14                          1064     
00001D14  18FC 0044               1065  B_DATAREG   MOVE.B      #'D',(A4)+
00001D18  3415                    1066              MOVE.W      (A5),D2
00001D1A  EC4A                    1067              LSR.W       #6,D2
00001D1C  E64A                    1068              LSR.W       #3,D2
00001D1E  C47C 0007               1069              AND.W       #$0007,D2
00001D22  3A02                    1070              MOVE.W      D2,D5
00001D24  4EB9 0000205C           1071              JSR         PrintD5Num
00001D2A  4E75                    1072              RTS
00001D2C                          1073         
00001D2C                          1074  
00001D2C                          1075  
00001D2C                          1076    
00001D2C  18FC 0009               1077  DECODE_C    MOVE.B      #9,(A4)+          *tab after op code
00001D30  3C3C 0002               1078              MOVE.W      #2,D6               *Initilize opcode length to 2
00001D34  3415                    1079              MOVE.W      (A5),D2
00001D36                          1080              *ENTER PRINT DATA CODE HERE
00001D36  4EB9 00001D3C           1081              JSR         C_SRC
00001D3C                          1082              
00001D3C                          1083  
00001D3C                          1084  
00001D3C                          1085  
00001D3C  3415                    1086  C_SRC       MOVE.W      (A5),D2
00001D3E  E64A                    1087              LSR.W       #3,D2
00001D40  C47C 0007               1088              AND.W       #$0007,D2
00001D44  4EB9 00001E68           1089              JSR         GET_DSTMODE
00001D4A  3415                    1090              MOVE.W      (A5),D2
00001D4C  C47C 0007               1091              AND.W       #$0007,D2
00001D50  4EB9 00001E28           1092              JSR         GET_SRCMODE
00001D56  4E75                    1093              RTS
00001D58                          1094  
00001D58                          1095  
00001D58                          1096     
00001D58  18FC 0009               1097  DECODE_D    MOVE.B      #9,(A4)+          *tab after op code
00001D5C  3C3C 0002               1098              MOVE.W      #2,D6               *Initilize opcode length to 2   
00001D60  1C3C 0023               1099              MOVE.B      #'#',D6
00001D64  1C3C 0024               1100              MOVE.B      #'$',D6     
00001D68  343C 0002               1101              MOVE.W      #2,D2               *move counter to 2 since only 2 HEX values used
00001D6C  E14A                    1102              LSL.W       #8,D2               *set up data for printers
00001D6E  4EB9 000020A4           1103              JSR         GD_LOOP             *print hex the 2 bits
00001D74  4E75                    1104              RTS
00001D76                          1105  
00001D76                          1106    
00001D76  18FC 0039               1107  DECODE_E    MOVE.B      #'9',(A4)+          *tab after op code
00001D7A  3C3C 0002               1108              MOVE.W      #2,D6               *Initilize opcode length to 2
00001D7E  3415                    1109              MOVE.W      (A5),D2
00001D80  E74A                    1110              LSL.W       #3,D2               *GRAB SOURCE MODE BITS
00001D82  C47C 0007               1111              AND.W       #$0007,D2           *Mask out other bits
00001D86  4EB9 00001E28           1112              JSR         GET_SRCMODE         *Append SRC string to (A4)          
00001D8C  18FC 002C               1113              MOVE.B      #',',(A4)+          *Addd comma for out put
00001D90  3415                    1114              MOVE.W      (A5),D2
00001D92  ED4A                    1115              LSL.W       #6,D2               *logical shift left to get data bits to d2
00001D94  E74A                    1116              LSL.W       #3,D2
00001D96  C478 0007               1117              AND.W       $0007,D2            *mask out other bits
00001D9A  18FC 0044               1118              MOVE.B      #'D',(A4)+          *Push D into register
00001D9E  3A02                    1119              MOVE.W      D2,D5
00001DA0  4EB9 0000205C           1120              JSR         PrintD5Num          *print register number
00001DA6                          1121                    
00001DA6                          1122  
00001DA6                          1123  
00001DA6                          1124    
00001DA6  3C3C 0002               1125  DECODE_F    MOVE.W      #2,D6               *Initilize opcode length to 2
00001DAA  3415                    1126              MOVE.W      (A5),D2             *Copy opcode into d2
00001DAC  ED4A                    1127              LSL.W       #6,D2               *Shift to grab op mode
00001DAE  C47C 0007               1128              AND.W       #$0007,D2           *Mask other bits
00001DB2  4EB9 00001DC6           1129              JSR         F_OPMODE
00001DB8  3415                    1130              MOVE.W      (A5),D2             *Recopy OPCODE into D2  
00001DBA  EC4A                    1131              LSR.W       #6,D2               *Shift right 6 - isolate Dest Mode
00001DBC  C47C 0007               1132              AND.W       #$0007,D2           *Mask out other bits
00001DC0  4EB9 00001E68           1133              JSR         GET_DSTMODE         *Append DST string to (A4)
00001DC6                          1134  
00001DC6                          1135  
00001DC6                          1136             *Check for the size of the OPCODE
00001DC6                          1137              
00001DC6                          1138  F_OPMODE
00001DC6                          1139  
00001DC6                          1140  
00001DC6  3C3C 0002               1141  D_MOVEQ     MOVE.W      #2,D6               *Initilize opcode length to 2
00001DCA  3015                    1142              MOVE.W      (A5),D0             *grab op code from a5
00001DCC  18FC 0023               1143              MOVE.B      #'#',(A4)+          *preload source string for literal
00001DD0  18FC 0024               1144              MOVE.B      #'$',(A4)+          *preload source string for hex
00001DD4  343C 0002               1145              MOVE.W      #2,D2               *move 8 to counter since this si long data 8 hex values are required
00001DD8  E14A                    1146              LSL.W       #8,D2               *shift over 8 so bits in high order for print
00001DDA  4EB9 000020A4           1147              JSR         GD_LOOP
00001DE0  4EB8 1D14               1148              JSR         B_DATAREG           *grabs and prints data reg 
00001DE4  4E75                    1149              RTS
00001DE6                          1150  
00001DE6  3C3C 0002               1151  D_ADDQ      MOVE.W      #2,D6               *Initilize opcode length to 2
00001DEA  3015                    1152              MOVE.W      (A5),D0             *grab op code from a5
00001DEC  18FC 0023               1153              MOVE.B      #'#',(A4)+          *preload source string for literal
00001DF0  18FC 0024               1154              MOVE.B      #'$',(A4)+          *preload source string for hex
00001DF4  343C 0001               1155              MOVE.W      #1,D2               *move counter to 1 since only 1 bit is used
00001DF8  E54A                    1156              LSL.W       #2,D2               *set up data for printer
00001DFA  0642 C000               1157              ADD.W       #$C000,D2           *mask out first bits
00001DFE  4EB9 000020A4           1158              JSR         GD_LOOP             *print hex the 2 bits
00001E04  3415                    1159              MOVE.W      (A5),D2             *reload op code from a5
00001E06  E74A                    1160              LSL.W       #3,D2               *shift so source mode is in LSBs  
00001E08  C47C 0007               1161              AND.W       #$0007,D2           *mask out other bits
00001E0C  4EB9 00001E28           1162              JSR         GET_SRCMODE         *print source mode
00001E12  4E75                    1163              RTS
00001E14                          1164              
00001E14  3C3C 0002               1165  D_JSR       MOVE.W      #2,D6               *Initilize opcode length to 2
00001E18  3415                    1166              MOVE.W      (A5),D2             *reload op code from a5
00001E1A  E74A                    1167              LSL.W       #3,D2               *shift so source mode is in LSBs  
00001E1C  C47C 0007               1168              AND.W       #$0007,D2           *mask out other bits
00001E20  4EB9 00001E28           1169              JSR         GET_SRCMODE         *print source mode
00001E26  4E75                    1170              RTS
00001E28                          1171  
00001E28                          1172  
00001E28                          1173              
00001E28                          1174              
00001E28                          1175            
00001E28                          1176              
00001E28                          1177               
00001E28                          1178  
00001E28                          1179  
00001E28  B47C 0000               1180  GET_SRCMODE CMP.W       #0,D2
00001E2C  6700 007A               1181              BEQ         SregMode        *register mode: Dn
00001E30  B47C 0001               1182              CMP.W       #1,D2
00001E34  6700 0084               1183              BEQ         SaddMode        *address mode ---An
00001E38  B47C 0002               1184              CMP.W       #2,D2
00001E3C  6700 008E               1185              BEQ         SaddINmode      *addres indirect mode ---(An)
00001E40  B47C 0003               1186              CMP.W       #3,D2
00001E44  6700 00A0               1187              BEQ         SaddINpre       *addess indirect pre dec ----(An)
00001E48  B47C 0004               1188              CMP.W       #4,D2
00001E4C  6700 00B6               1189              BEQ         SaddINpost      *address indirect post inc --- (An)+
00001E50  B47C 0005               1190              CMP.W       #5,D2
00001E54  6700 00CC               1191              BEQ         S16An           *source number of word size --- (d16,An)
00001E58  B47C 0006               1192              CMP.W       #6,D2
00001E5C  6700 00C4               1193              BEQ         S8AnXn          *source number byte size --- (d8,An,Xn)
00001E60  B47C 0007               1194              CMP.W       #7,D2
00001E64  6700 00BC               1195              BEQ         S_DATA_MODE     *immediate data
00001E68                          1196      
00001E68                          1197  
00001E68  B47C 0000               1198  GET_DSTMODE CMP.W       #0,D2
00001E6C  6700 00F6               1199              BEQ         DregMode        *register mode ---Dn
00001E70  B47C 0001               1200              CMP.W       #1,D2
00001E74  6700 0100               1201              BEQ         DaddMode        *address mode ---An
00001E78  B47C 0002               1202              CMP.W       #2,D2
00001E7C  6700 010A               1203              BEQ         DaddINmode      *addres indirect mode ---(An)
00001E80  B47C 0003               1204              CMP.W       #3,D2
00001E84  6700 011C               1205              BEQ         DaddINpre       *addess indirect pre dec ----(An)
00001E88  B47C 0004               1206              CMP.W       #4,D2
00001E8C  6700 0132               1207              BEQ         DaddINpost      *address indirect post inc --- (An)+
00001E90  B47C 0005               1208              CMP.W       #5,D2
00001E94  6700 0148               1209              BEQ         D16An           *source number of word size --- (d16,An)
00001E98  B47C 0006               1210              CMP.W       #6,D2
00001E9C  6700 0140               1211              BEQ         D8AnXn          *source number byte size --- (d8,An,Xn)
00001EA0  B47C 0007               1212              CMP.W       #7,D2           
00001EA4  6700 0138               1213              BEQ         D_DATA_MODE     *Source is immediate data following the opcode
00001EA8                          1214      
00001EA8                          1215   
00001EA8  18FC 0044               1216  SregMode    MOVE.B      #'D',(A4)+
00001EAC  4EB9 00002044           1217              JSR         T1_GrabSreg
00001EB2  4EB9 0000205C           1218              JSR         PrintD5Num   
00001EB8  4E75                    1219              RTS  
00001EBA                          1220          
00001EBA  18FC 0041               1221  SaddMode    MOVE.B      #'A',(A4)+
00001EBE  4EB9 00002044           1222              JSR         T1_GrabSreg
00001EC4  4EB9 0000205C           1223              JSR         PrintD5Num
00001ECA  4E75                    1224              RTS
00001ECC                          1225      
00001ECC                          1226      
00001ECC                          1227      
00001ECC  18FC 0028               1228  SaddInMode  MOVE.B      #'(',(A4)+
00001ED0  18FC 0041               1229              MOVE.B      #'A',(A4)+
00001ED4  4EB9 00002044           1230              JSR         T1_GrabSreg
00001EDA  4EB9 0000205C           1231              JSR         PrintD5Num
00001EE0  18FC 0029               1232              MOVE.B      #')',(A4)+
00001EE4  4E75                    1233              RTS
00001EE6                          1234      
00001EE6  18FC 002D               1235  SaddINpre   MOVE.B      #'-',(A4)+
00001EEA  18FC 0028               1236              MOVE.B      #'(',(A4)+
00001EEE  18FC 0041               1237              MOVE.B      #'A',(A4)+
00001EF2  4EB9 00002044           1238              JSR         T1_GrabSreg
00001EF8  4EB9 0000205C           1239              JSR         PrintD5Num
00001EFE  18FC 0029               1240              MOVE.B      #')',(A4)+
00001F02  4E75                    1241              RTS
00001F04                          1242      
00001F04  18FC 0028               1243  SaddINpost  MOVE.B      #'(',(A4)+
00001F08  18FC 0041               1244              MOVE.B      #'A',(A4)+
00001F0C  4EB9 00002044           1245              JSR         T1_GrabSreg
00001F12  4EB9 0000205C           1246              JSR         PrintD5Num
00001F18  18FC 0029               1247              MOVE.B      #')',(A4)+
00001F1C  18FC 002B               1248              MOVE.B      #'+',(A4)+
00001F20  4E75                    1249              RTS
00001F22                          1250      
00001F22                          1251  S16An
00001F22                          1252  S8AnXn
00001F22  4EB9 0000204E           1253  S_DATA_MODE JSR         T1_GrabDreg
00001F28  0C45 0001               1254              CMPI.W      #1,D5
00001F2C  6700 00CA               1255              BEQ         LONG_DATA
00001F30  0C45 0002               1256              CMPI.W      #2,D5
00001F34  6700 00C2               1257              BEQ         LONG_DATA
00001F38  BA7C 0000               1258              CMP.W       #0,D5  
00001F3C  6700 00D2               1259              BEQ         WORD_DATA
00001F40  BA7C 0004               1260              CMP.W       #4,D5
00001F44  6700 0002               1261              BEQ         IMMEDIATE_D
00001F48                          1262              
00001F48  18FC 0023               1263  IMMEDIATE_D MOVE.B      #'#',(A4)+              *add the # to data string to immediate data
00001F4C                          1264              
00001F4C  BE7C 0008               1265              CMP.W       #8,D7
00001F50  6700 00BE               1266              BEQ         WORD_DATA               *means the immediate data is a word value
00001F54                          1267              
00001F54  BE7C 000C               1268              CMP.W       #12,D7       
00001F58  6700 009E               1269              BEQ         LONG_DATA               *means the immediate data is a long value
00001F5C                          1270              
00001F5C  BE7C 0008               1271              CMP.W       #8,D7
00001F60  6700 00C6               1272              BEQ         BYTE_DATA             *means the immediate data is a long value
00001F64                          1273              
00001F64                          1274               
00001F64  18FC 0044               1275  DregMode    MOVE.B      #'D',(A4)+
00001F68  4EB9 0000204E           1276              JSR         T1_GrabDreg
00001F6E  4EB9 0000205C           1277              JSR         PrintD5Num   
00001F74  4E75                    1278              RTS
00001F76                          1279           
00001F76  18FC 0041               1280  DaddMode    MOVE.B      #'A',(A4)+
00001F7A  4EB9 0000204E           1281              JSR         T1_GrabDreg
00001F80  4EB9 0000205C           1282              JSR         PrintD5Num
00001F86  4E75                    1283              RTS
00001F88                          1284      
00001F88                          1285      
00001F88                          1286      
00001F88  18FC 0028               1287  DaddInMode  MOVE.B      #'(',(A4)+
00001F8C  18FC 0041               1288              MOVE.B      #'A',(A4)+
00001F90  4EB9 0000204E           1289              JSR         T1_GrabDreg
00001F96  4EB9 0000205C           1290              JSR         PrintD5Num
00001F9C  18FC 0029               1291              MOVE.B      #')',(A4)+
00001FA0  4E75                    1292              RTS
00001FA2                          1293      
00001FA2  18FC 002D               1294  DaddINpre   MOVE.B      #'-',(A4)+
00001FA6  18FC 0028               1295              MOVE.B      #'(',(A4)+
00001FAA  18FC 0041               1296              MOVE.B      #'A',(A4)+
00001FAE  4EB9 0000204E           1297              JSR         T1_GrabDreg
00001FB4  4EB9 0000205C           1298              JSR         PrintD5Num
00001FBA  18FC 0029               1299              MOVE.B      #')',(A4)+
00001FBE  4E75                    1300              RTS
00001FC0                          1301      
00001FC0  18FC 0028               1302  DaddINpost  MOVE.B      #'(',(A4)+
00001FC4  18FC 0041               1303              MOVE.B      #'A',(A4)+
00001FC8  4EB9 0000204E           1304              JSR         T1_GrabDreg
00001FCE  4EB9 0000205C           1305              JSR         PrintD5Num
00001FD4  18FC 0029               1306              MOVE.B      #')',(A4)+
00001FD8  18FC 002B               1307              MOVE.B      #'+',(A4)+
00001FDC  4E75                    1308              RTS
00001FDE                          1309      
00001FDE                          1310  D16An
00001FDE                          1311              
00001FDE                          1312  D8AnXn
00001FDE                          1313  
00001FDE  4EB9 0000204E           1314  D_DATA_MODE JSR         T1_GrabDreg
00001FE4  0C45 0001               1315              CMPI.W      #1,D5
00001FE8  6700 000E               1316              BEQ         LONG_DATA
00001FEC  0C45 0000               1317              CMPI.W      #0,D5
00001FF0  6700 001E               1318              BEQ         WORD_DATA
00001FF4  0C45 0007               1319              CMPI.W      #7,D5
00001FF8                          1320              *BEQ         DATA_SIZE
00001FF8                          1321              
00001FF8                          1322  
00001FF8                          1323  
00001FF8  18FC 0024               1324  LONG_DATA   MOVE.B      #'$',(A4)+       *prepare the string for a long hex value
00001FFC  264D                    1325              MOVE.L      A5,A3
00001FFE                          1326      
00001FFE  D7C6                    1327              ADD.L       D6,A3           *Add opcode data length this increments the address past the op code and existing data
00002000  2013                    1328              MOVE.L      (A3),D0
00002002                          1329              
00002002  343C 0008               1330              MOVE.W      #8,D2           *move 8 to counter since this si long data 8 hex values are required
00002006  4EB9 000020A4           1331              JSR         GD_LOOP
0000200C  5846                    1332              ADD.W       #4,D6           *since it is long data increment the address by 4 bits *d6 is opcode length counter
0000200E  4E75                    1333              RTS
00002010                          1334  
00002010  18FC 0024               1335  WORD_DATA   MOVE.B      #'$',(A4)+       *prepare the string for a long hex value
00002014  264D                    1336              MOVE.L      A5,A3    
00002016                          1337              
00002016  D7C6                    1338              ADD.L       D6,A3           *Add opcode data length to incement past opcode and data
00002018  2013                    1339              MOVE.L      (A3),D0         *Add correct data into d0 register for printing
0000201A                          1340              
0000201A  343C 0004               1341              MOVE.W      #4,D2           *move 4 to counter since this it word data 4 hex values are required
0000201E                          1342              
0000201E  4EB9 000020A4           1343              JSR         GD_LOOP
00002024  5446                    1344              ADD.W       #2,D6           *since it is long data increment the address by 4 bits *d6 is opcode length counter
00002026  4E75                    1345              RTS
00002028                          1346  
00002028  18FC 0024               1347  BYTE_DATA   MOVE.B      #'$',(A4)+       *prepare the string for a long hex value
0000202C  264D                    1348              MOVE.L      A5,A3    
0000202E                          1349              
0000202E  D7C6                    1350              ADD.L       D6,A3           *Add opcode data length to incement past opcode and data
00002030  2013                    1351              MOVE.L      (A3),D0         *Add correct data into d0 register for printing
00002032                          1352              
00002032  343C 0002               1353              MOVE.W      #2,D2           *move 2 to counter since this is byte data 2 hex values are required
00002036  E188                    1354              LSL.L       #8,D0           *shift data over 8 bits for rotate in print to hex function
00002038  E988                    1355              LSL.L       #4,D0           *shift data over 4 bits so beginning of byte is in the highest order
0000203A  4EB9 000020A4           1356              JSR         GD_LOOP
00002040  5446                    1357              ADD.W       #2,D6           *since it is long data increment the address by 4 bits *d6 is opcode length counter
00002042  4E75                    1358              RTS
00002044                          1359              
00002044                          1360              
00002044  3415                    1361  T1_GrabSreg MOVE.W      (A5),D2         *recopy op code
00002046  C47C 0007               1362              AND.W       #$0007,D2       *mask other bits
0000204A  3A02                    1363              MOVE.W      D2,D5           *copy D2 to D5
0000204C  4E75                    1364              RTS
0000204E                          1365      
0000204E  3415                    1366  T1_GrabDreg MOVE.W      (A5),D2         *type one grab register bits
00002050  EC4A                    1367              LSR.W       #6,D2           *shift bits over
00002052  E64A                    1368              LSR.W       #3,D2           
00002054  C47C 0007               1369              AND.W       #$0007,D2       *mask so only relevent bits left
00002058  3A02                    1370              MOVE.W      D2,D5           *move to d5 for printing
0000205A  4E75                    1371              RTS
0000205C                          1372      
0000205C  BA3C 0000               1373  PrintD5Num  CMP.B       #0,D5           *print the numeber in d5
00002060  6700 0050               1374              BEQ         PRINT0
00002064  BA3C 0001               1375              CMP.B       #1,D5
00002068  6700 004E               1376              BEQ         PRINT1
0000206C  BA3C 0002               1377              CMP.B       #2,D5
00002070  6700 004C               1378              BEQ         PRINT2
00002074  BA3C 0003               1379              CMP.B       #3,D5
00002078  6700 004A               1380              BEQ         PRINT3
0000207C  BA3C 0004               1381              CMP.B       #4,D5
00002080  6700 0048               1382              BEQ         PRINT4
00002084  BA3C 0005               1383              CMP.B       #5,D5
00002088  6700 0046               1384              BEQ         PRINT5
0000208C  BA3C 0006               1385              CMP.B       #6,D5
00002090  6700 0044               1386              BEQ         PRINT6
00002094  BA3C 0007               1387              CMP.B       #7,D5
00002098  6700 0042               1388              BEQ         PRINT7
0000209C  BA3C 0008               1389              CMP.B       #8,D5
000020A0  6700 0040               1390              BEQ         PRINT8  
000020A4                          1391  
000020A4  4EB8 160E               1392  GD_LOOP     JSR         HEX_2_ASCII
000020A8  5342                    1393              SUBI        #1,D2
000020AA  B43C 0000               1394              CMP.B       #0,D2
000020AE  6EF4                    1395              BGT         GD_LOOP
000020B0  4E75                    1396              RTS
000020B2                          1397  
000020B2                          1398  
000020B2                          1399  
000020B2                          1400      
000020B2  18FC 0030               1401  PRINT0      MOVE.B      #'0',(A4)+
000020B6  4E75                    1402              RTS
000020B8                          1403      
000020B8  18FC 0031               1404  PRINT1      MOVE.B      #'1',(A4)+
000020BC  4E75                    1405              RTS
000020BE                          1406      
000020BE  18FC 0032               1407  PRINT2      MOVE.B      #'2',(A4)+
000020C2  4E75                    1408              RTS
000020C4                          1409      
000020C4  18FC 0033               1410  PRINT3      MOVE.B      #'3',(A4)+
000020C8  4E75                    1411              RTS
000020CA                          1412      
000020CA  18FC 0034               1413  PRINT4      MOVE.B      #'4',(A4)+
000020CE  4E75                    1414              RTS
000020D0                          1415      
000020D0  18FC 0035               1416  PRINT5      MOVE.B      #'5',(A4)+
000020D4  4E75                    1417              RTS
000020D6                          1418  
000020D6  18FC 0036               1419  PRINT6      MOVE.B      #'6',(A4)+
000020DA  4E75                    1420              RTS
000020DC                          1421      
000020DC  18FC 0037               1422  PRINT7      MOVE.B      #'7',(A4)+
000020E0  4E75                    1423              RTS  
000020E2                          1424         
000020E2  18FC 0038               1425  PRINT8      MOVE.B      #'8',(A4)+
000020E6  4E75                    1426              RTS
000020E8                          1427      
000020E8                          1428  
000020E8                          1429  
000020E8                          1430  
000020E8                          1431  
000020E8                          1432  
000020E8                          1433  
000020E8                          1434  -------------------- end include --------------------
000020E8                          1435              
000020E8                          1436  
000020E8                          1437  
000020E8                          1438  
000020E8                          1439  
000020E8                          1440  
000020E8                          1441  
000020E8                          1442  
000020E8                          1443  
000020E8                          1444  
000020E8                          1445  
000020E8                          1446  
000020E8                          1447  
000020E8                          1448  
000020E8                          1449  
000020E8                          1450  
000020E8                          1451  
000020E8                          1452  
000020E8                          1453  
000020E8                          1454  -------------------- end include --------------------
000020E8                          1455              
000020E8                          1456              END         START               ;last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1A38
ADDA                1A4C
ADDA_SIZE           1C30
APPND_ALPHA         1622
APPND_BYTE          1C4C
APPND_LONG          1C64
APPND_NUM           162A
APPND_WORD          1C58
ARITH_MEM           1AB6
ARITH_REG           1A74
BCC                 1992
BCLR_IM             185A
BCLR_REG            1872
BCS                 1976
BGE                 1968
BIN_0               16BE
BIN_10              17A2
BIN_11              17A6
BIN_12              17C4
BIN_13              17C8
BIN_14              17E4
BIN_15              182A
BIN_4               170A
BIN_5               1748
BIN_6               174C
BIN_7               1786
BIN_8               178A
BIN_9               179E
BIN_MOVE            16EE
BLT                 19A0
BRA_SUB             19AE
BUILD_STR           15D4
BVC                 1984
BYTE                2
BYTE_DATA           2028
B_ADDMODE           1CDE
B_DATAREG           1D14
B_SCOUNT            1CFC
CMP                 1A0C
CMPI                1842
CNVRT_ADDR          1474
CNVRT_ALPHA         1B78
CNVRT_DONE          1510
CNVRT_NUM           1B80
CR                  D
C_ALPHA_L           1506
C_ALPHA_U           14FC
C_ERR1              154A
C_ERR2              155E
C_ERR3              1572
C_ERR4              1586
C_ERR_BASE1         159A
C_ERR_BASE2         15C6
C_INVALID           1540
C_IS_LC             14DE
C_LOOP              149E
C_NUMERIC           14F2
C_SRC               1D3C
C_VALIDATE          151A
D16AN               1FDE
D8ANXN              1FDE
DADDINMODE          1F88
DADDINPOST          1FC0
DADDINPRE           1FA2
DADDMODE            1F76
DATA                1B02
DECODE_A            1C70
DECODE_B            1C9A
DECODE_C            1D2C
DECODE_D            1D58
DECODE_E            1D76
DECODE_F            1DA6
DISP_INTRO          1016
DISP_WAIT           1024
DIVS_W              19BC
DREGMODE            1F64
DSMBL_DONE          1086
D_ADDQ              1DE6
D_DATA_MODE         1FDE
D_JSR               1E14
D_MOVEQ             1DC6
END                 10E2
END_ADDR            1106
EOR                 19F8
F_OPMODE            1DC6
GA_LOOP             15FA
GD_LOOP             20A4
GET_ADDR            15F2
GET_DSTMODE         1E68
GET_SIZE_67         1B8C
GET_SRCMODE         1E28
HEX_2_ASCII         160E
IMMEDIATE_D         1F48
INPUT_ADDR          143A
JSR                 192E
JT_START            1632
LEA                 1904
LEFT                1AF6
LF                  A
LOGIC_MEM           1AA0
LOGIC_REG           1A5E
LONG                8
LONG_DATA           1FF8
LOOP_COND           1066
MAIN_LOOP           1042
MOVE                188A
MOVEA               18A8
MOVEM               1912
MOVEM_SIZE          1BB0
MOVE_SIZE           1BCC
MULS_W              1A20
M_DONE              142E
M_ERR_ADDR1         1347
M_ERR_ADDR2         136A
M_ERR_ADDR3         13AC
M_ERR_ADDR4         13C5
M_ERR_GEN           141B
M_INPUT_E           12D6
M_INPUT_S           1296
M_INTRO             1142
M_INV_INPUT         1317
M_IN_RULES          11A6
M_NEWLINE           1436
M_NPROMPT           13DC
M_WAIT              12FA
NEG                 193C
NEXT_OP             104A
NOP                 18DE
OP_ADDR             1124
OR                  19D4
ORI                 182E
PREPARE_OP          15EC
PRINT0              20B2
PRINT1              20B8
PRINT2              20BE
PRINT3              20C4
PRINT4              20CA
PRINT5              20D0
PRINT6              20D6
PRINT7              20DC
PRINT8              20E2
PRINTD5NUM          205C
PRINT_OP            1070
PROMPT_NEW          1098
P_OPERAND           1B26
P_RESTART           10DA
RIGHT               1AFC
RIGHTORLEFT         1AE2
ROTATE_MEM          1ACC
ROTATE_REG          1A8A
RTS                 18EE
S16AN               1F22
S8ANXN              1F22
SADDINMODE          1ECC
SADDINPOST          1F04
SADDINPRE           1EE6
SADDMODE            1EBA
SIZE_678            1BF4
SREGMODE            1EA8
START               1000
START_ADDR          10E8
SUB                 19E4
SUBQ                1950
S_DATA_MODE         1F22
T1_GRABDREG         204E
T1_GRABSREG         2044
WORD                4
WORD_DATA           2010
WRITE_DATA          1B36
WRITE_DIGIT         1B5C
WRITE_DONE          1B88
WRITE_LOOP          1B38
W_ALPHA             1B68
W_NUM               1B70
