00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/8/2018 11:00:26 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Team Visual Basic's Disassembler
00000000                             3  * Written by :  Henry Hong, Dylan Desmond, Austin Abeyta
00000000                             4  * Date       :  ?
00000000                             5  * Description:  CSS422 Final Project
00000000                             6  *               Machine code to Motorola 68000 Assembly
00000000                             7  *               Main Driver File
00000000                             8  *-----------------------------------------------------------
00000000                             9      
00001000                            10  START       ORG         $1000               ;Start @ address $1000             
00001000  4EB9 00001016             11              JSR         DISP_INTRO          ;Display Intro Message
00001006  4EB9 00001430             12              JSR         INPUT_ADDR          ;Take start and ending address as user input
0000100C  4EB9 00001042             13              JSR         MAIN_LOOP           ;Meat of the program: Check for validity, OPCODE match, and print to screen
00001012                            14                                                          
00001012  6000 00C8                 15              BRA         END                 ;If loop improperly terminated, base case BRA to END program         
00001016                            16  *-Intro Message---------------------------------------------
00001016  43F9 0000113C             17  DISP_INTRO  LEA         M_INTRO,A1          ;Load intro msg
0000101C  103C 000E                 18              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001020  4E4F                      19              TRAP        #15                     
00001022                            20      
00001022  4E75                      21              RTS                             ;Return to main START section
00001024                            22              
00001024                            23  *-Press Enter to Continue message---------------------------            
00001024  43F9 000012F4             24  DISP_WAIT   LEA         M_WAIT,A1           ;Load wait message
0000102A  103C 000E                 25              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000102E  4E4F                      26              TRAP        #15
00001030                            27              
00001030  103C 0005                 28              MOVE.B      #5,D0               ;Trap Task 5 takes in a single character input (aka press enter)
00001034  4E4F                      29              TRAP        #15
00001036                            30              
00001036  103C 000B                 31              MOVE.B      #11,D0              ;Clear screen
0000103A  323C FF00                 32              MOVE.W      #$FF00,D1
0000103E  4E4F                      33              TRAP        #15
00001040                            34  
00001040  4E75                      35              RTS        
00001042                            36              
00001042                            37  *-Main Loop-------------------------------------------------
00001042  4EB8 1024                 38  MAIN_LOOP   JSR         DISP_WAIT           ;Display Press Enter to Continue msg
00001046  183C 0014                 39              MOVE.B      #20,D4              ;D4 loop var - print 20 lines per page
0000104A                            40              
0000104A  4EB9 000015CC             41  NEXT_OP     JSR         BUILD_STR           ;Build and accumulate the 0xADDR OPCODE $OPERAND string into memory @ OP_ADDR                            
00001050  4EB9 00001070             42              JSR         PRINT_OP            ;Print the built string to console 
00001056                            43              
00001056  4EB9 00001066             44              JSR         LOOP_COND           ;Check if address is still valid. END program if it isnt
0000105C                            45    
0000105C  5344                      46              SUBI        #1,D4               ;Decrement counter
0000105E  B83C 0000                 47              CMP.B       #0,D4               ;Is counter == 0?
00001062  67DE                      48              BEQ         MAIN_LOOP           ;Then print the next page
00001064                            49              
00001064  60E4                      50              BRA         NEXT_OP             ;Otherwise, in the same page, print the next OP         
00001066                            51  
00001066                            52              
00001066                            53  *-Loop Condition Logic--------------------------------------
00001066  DBC7                      54  LOOP_COND   ADD.L       D7,A5            ;Increment current address (A5) by the length of the last instruction + operand data (D7)
00001068  BCCD                      55              CMP.W       A5,A6            ;If current address (A5) is now equal to or greater than end address (A6), end
0000106A  6C00 001A                 56              BGE         DSMBL_DONE           ;<---------- check conditional
0000106E                            57              
0000106E  4E75                      58              RTS            
00001070                            59             
00001070                            60  *-Print OPCODE STRING---------------------------------------
00001070  327C 111E                 61  PRINT_OP    MOVE.W      #OP_ADDR,A1         ;Move the OPCODE's beginning addr to A1
00001074  103C 000E                 62              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001078  4E4F                      63              TRAP        #15
0000107A                            64              
0000107A  327C 142C                 65              MOVE.W      #M_NEWLINE,A1       ;Print a new line after this OPCODE line is finished
0000107E  103C 000E                 66              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001082  4E4F                      67              TRAP        #15
00001084                            68              
00001084  4E75                      69              RTS
00001086                            70              
00001086                            71  *-Print to user DONE message--------------------------------
00001086  43F9 00001424             72  DSMBL_DONE  LEA         M_DONE,A1           ;Print DONE message
0000108C  103C 000E                 73              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001090  4E4F                      74              TRAP        #15 
00001092                            75              
00001092  4EB8 1024                 76              JSR         DISP_WAIT           ;Tell user to press enter to continue then clear screen
00001096  4EB9 0000109C             77              JSR         PROMPT_NEW          ;Ask user if they want to restart
0000109C                            78              
0000109C                            79  *-Ask user if they want to start program again--------------            
0000109C  43F9 000013D4             80  PROMPT_NEW  LEA         M_NPROMPT,A1        ;Ask user if they would like to run program again
000010A2  103C 000E                 81              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000010A6  4E4F                      82              TRAP        #15                     
000010A8                            83              
000010A8  103C 0005                 84              MOVE.B      #5,D0               ;Read user input into D1
000010AC  4E4F                      85              TRAP        #15
000010AE                            86              
000010AE  B23C 0079                 87              CMP.B       #'y',D1             ;Is input y
000010B2  6700 FF4C                 88              BEQ         START               ;if so restart program
000010B6                            89              
000010B6  B23C 0059                 90              CMP.B       #'Y',D1             ;Is input Y capital
000010BA  6700 FF44                 91              BEQ         START               ;if so restart program
000010BE                            92      
000010BE  B23C 006E                 93              CMP.B       #'n',D1             ;Is input n
000010C2  6700 0018                 94              BEQ         END                 ;if so restart program
000010C6                            95              
000010C6  B23C 004E                 96              CMP.B       #'N',D1             ;Is input N capital
000010CA  6700 0010                 97              BEQ         END                 ;if so restart program
000010CE                            98              
000010CE  43F9 00001413             99              LEA         M_ERR_GEN,A1        ;Input is invalid! Prompt again
000010D4  103C 000E                100              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000010D8  4E4F                     101              TRAP        #15 
000010DA                           102              
000010DA  60C0                     103              BRA         PROMPT_NEW          ;Re prompt            
000010DC                           104  
000010DC                           105  
000010DC                           106  *-END-------------------------------------------------------
000010DC  103C 0009                107  END         MOVE.B      #9,D0               ;End program
000010E0  4E4F                     108              TRAP        #15                      
000010E2                           109              
000010E2                           110  *-Variables and constants-----------------------------------
000010E2  =0000000D                111  CR          EQU         $0D
000010E2  =0000000A                112  LF          EQU         $0A
000010E2                           113  
000010E2  =00000002                114  BYTE        EQU         $2
000010E2  =00000004                115  WORD        EQU         $4
000010E2  =00000008                116  LONG        EQU         $8
000010E2                           117  
000010E2                           118  START_ADDR  DS.B        30                  ;Machine code start address stored here
00001100                           119  END_ADDR    DS.B        30                  ;Machine code end address stored here
0000111E                           120  
0000111E                           121  OP_ADDR     DS.B        30                  ;Storage to accumulate OPCODE address, name, and data string at            
0000113C                           122  
0000113C                           123  
0000113C                           124  *-Strings---------------------------------------------------
0000113C= 54 65 61 6D 20 56 ...    125  M_INTRO     DC.B        'Team Visual Basic',CR,LF
0000114F= 4D 6F 74 6F 72 6F ...    126              DC.B        'Motorola 68000 Disassembler',CR,LF
0000116C= 42 79 20 41 75 73 ...    127              DC.B        'By Austin Abeyta, Dylan Desmond, and Henry Hong',CR,LF,CR,LF,0 
000011A0                           128  
000011A0= 50 6C 65 61 73 65 ...    129  M_IN_RULES  DC.B        'Please limit address input to numeric (0-9) and/or alphabet A-F',CR,LF
000011E1= 50 6C 65 61 73 65 ...    130              DC.B        'Please limit address input to a range of [00005000-FFFFFFFF]!',CR,LF
00001220= 49 6E 70 75 74 20 ...    131              DC.B        'Input less than 8 digits will be padded on left',CR,LF    
00001251= 49 6E 70 75 74 20 ...    132              DC.B        'Input greater than 8 digits will be truncated on the right',CR,LF,CR,LF,0
00001290                           133              
00001290= 50 6C 65 61 73 65 ...    134  M_INPUT_S   DC.B        'Please Input the Starting Address (test code is ORG @ 7F00): ',CR,LF,0
000012D0= 50 6C 65 61 73 65 ...    135  M_INPUT_E   DC.B        'Please Input the Ending Address: ',CR,LF,0
000012F4                           136  
000012F4= 50 72 65 73 73 20 ...    137  M_WAIT      DC.B        'Press Enter to Continue!',CR,LF,0
0000130F                           138  
0000130F= 49 6E 70 75 74 20 ...    139  M_INV_INPUT DC.B        'Input address is invalid! Please re-enter: ',CR,LF,CR,LF,0
0000133F                           140  
0000133F= 45 52 52 3A 20 53 ...    141  M_ERR_ADDR1 DC.B        'ERR: START address > END address',CR,LF,0
00001362= 45 52 52 3A 20 53 ...    142  M_ERR_ADDR2 DC.B        'ERR: START address too low, danger of overwriting program logic',CR,LF,0
000013A4= 45 52 52 3A 20 4F ...    143  M_ERR_ADDR3 DC.B        'ERR: ODD START address',CR,LF,0
000013BD= 45 52 52 3A 20 4F ...    144  M_ERR_ADDR4 DC.B        'ERR: ODD END address',CR,LF,0
000013D4                           145  
000013D4= 57 6F 75 6C 64 20 ...    146  M_NPROMPT   DC.B        'Would you like to run program again @ another address? (y/n)',CR,LF,0
00001413= 49 6E 76 61 6C 69 ...    147  M_ERR_GEN   DC.B        'Invalid input!',CR,LF,0  
00001424= 44 6F 6E 65 21 0D ...    148  M_DONE      DC.B        'Done!',CR,LF,0  
0000142C                           149  
0000142C= 0D 0A 00                 150  M_NEWLINE   DC.B        '',CR,LF,0
0000142F                           151                      
0000142F                           152              
0000142F                           153  
0000142F                           154  *-Files-----------------------------------------------------
0000142F                           155              INCLUDE     'TeamVisualBasic_Disassembler_Input.X68'            ;Include Input class file
0000142F                           156  
00001430  43F8 11A0                157  INPUT_ADDR  LEA         M_IN_RULES,A1       ;Load input restriction and rules msg
00001434  103C 000E                158              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001438  4E4F                     159              TRAP        #15                 
0000143A                           160  
0000143A  43F8 1290                161              LEA         M_INPUT_S,A1        ;Load input request msg
0000143E  103C 000E                162              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001442  4E4F                     163              TRAP        #15
00001444                           164              
00001444  43F8 10E2                165              LEA         START_ADDR,A1
00001448  103C 0002                166              MOVE.B      #2,D0               ;Read string from keyboard and store in (A1)
0000144C  4E4F                     167              TRAP        #15          
0000144E                           168              
0000144E  43F8 12D0                169              LEA         M_INPUT_E,A1        ;Load input request msg
00001452  103C 000E                170              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001456  4E4F                     171              TRAP        #15
00001458                           172              
00001458  43F8 1100                173              LEA         END_ADDR,A1
0000145C  103C 0002                174              MOVE.B      #2,D0               ;Read string from keyboard and store in (A1)
00001460  4E4F                     175              TRAP        #15
00001462                           176              
00001462  4EB9 0000146A            177              JSR         CNVRT_ADDR          ;Convert user ASCII input into usable hex addresses
00001468                           178  
00001468  4E75                     179              RTS                             ;Return to main START section
0000146A                           180  
0000146A                           181  
0000146A  43F8 10E2                182  CNVRT_ADDR  LEA         START_ADDR,A1       ;Load start address into A1
0000146E  163C 0008                183              MOVE.B      #8,D3               ;Load counter var into D3. Count down from 8
00001472  4EB9 00001494            184              JSR         C_LOOP
00001478  2A42                     185              MOVE.L      D2,A5               ;Save converted input in (A5)
0000147A                           186              
0000147A  4282                     187              CLR.L       D2                  ;Clear accumulator
0000147C  43F8 1100                188              LEA         END_ADDR,A1         ;Load end address into A1
00001480  163C 0008                189              MOVE.B      #8,D3               ;Load counter var into D3. Count down from 8
00001484  4EB9 00001494            190              JSR         C_LOOP
0000148A  2C42                     191              MOVE.L      D2,A6               ;Save converted input in (A6)
0000148C                           192                  
0000148C  4EB9 00001510            193              JSR         C_VALIDATE          ;Make sure input is not ODD and end addr is not before start
00001492  4E75                     194              RTS                             ;Finish by RTSing back to main dissasembler file
00001494                           195   
00001494  1019                     196  C_LOOP      MOVE.B      (A1)+,D0            ;Load the ascii digit into D0
00001496  B03C 00FF                197              CMP.B       #$FF,D0             ;If value is $FF, there is no digit
0000149A  6700 009A                198              BEQ         C_INVALID
0000149E  B03C 0000                199              CMP.B       #$00,D0             ;If value is $00, then probably done
000014A2  6700 0062                200              BEQ         CNVRT_DONE              
000014A6                           201              
000014A6  B63C 0000                202              CMP.B       #0,D3               ;If counter var == 0
000014AA  6700 005A                203              BEQ         CNVRT_DONE
000014AE  5303                     204              SUBI.B      #1,D3               ;Else, decrement counter var
000014B0                           205              
000014B0                           206              ;Determine whether num, upper, or lower case ascii a-f                                    
000014B0  B03C 0030                207              CMP.B       #$30,D0             ;If <30, not a number
000014B4  6D00 0080                208              BLT         C_INVALID           
000014B8  B03C 0046                209              CMP.B       #$46,D0             ;If >46, it's possibly a lowercase letter 
000014BC  6E00 0016                210              BGT         C_IS_LC             ;Check if it's a valid lower ascii letter
000014C0                           211              
000014C0  B03C 0040                212              CMP.B       #$40,D0             ;If <40, must be number
000014C4  6D00 0022                213              BLT         C_NUMERIC
000014C8  B03C 0041                214              CMP.B       #$41,D0             ;If >41, must be upper case ascii
000014CC  6E00 0024                215              BGT         C_ALPHA_U
000014D0                           216  
000014D0  6000 0064                217              BRA         C_INVALID           ;If none of the above, the input is not valid 
000014D4                           218              
000014D4  B03C 0061                219  C_IS_LC     CMP.B       #$61,D0             ;If >61, input is invalid
000014D8  6D00 005C                220              BLT         C_INVALID
000014DC  B03C 0066                221              CMP.B       #$66,D0             ;If >66, input is invalid
000014E0  6E00 0054                222              BGT         C_INVALID
000014E4                           223              
000014E4  6000 0016                224              BRA         C_ALPHA_L           ;Else must be a valid lowercase input
000014E8                           225  
000014E8  0400 0030                226  C_NUMERIC   SUBI.B      #$30,D0             ;Subtract 0x30 to convert to hex
000014EC  E98A                     227              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
000014EE  D400                     228              ADD.B       D0,D2               ;Accumulate digits into D2
000014F0  60A2                     229              BRA         C_LOOP  
000014F2                           230  
000014F2                           231  
000014F2  0400 0037                232  C_ALPHA_U   SUBI.B      #$37,D0             ;Subtract 0x37 to convert to hex
000014F6  E98A                     233              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
000014F8  D400                     234              ADD.B       D0,D2               ;Accumulate digits into D2
000014FA  6098                     235              BRA         C_LOOP
000014FC                           236  
000014FC  0400 0057                237  C_ALPHA_L   SUBI.B      #$57,D0             ;Subtract 0x57 to convert to hex
00001500  E98A                     238              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
00001502  D400                     239              ADD.B       D0,D2               ;Accumulate digits into D2
00001504  608E                     240              BRA         C_LOOP
00001506                           241          
00001506                           242                         
00001506  B63C 0008                243  CNVRT_DONE  CMP.B       #8,D3               ;If no input, invalid
0000150A  6700 002A                244              BEQ         C_INVALID           
0000150E                           245              
0000150E  4E75                     246              RTS                             ;Else, done
00001510                           247              
00001510                           248  
00001510  BDCD                     249  C_VALIDATE  CMPA.L      A5,A6               ;If end address < start address     
00001512  6D00 002C                250              BLT         C_ERR1
00001516                           251                                                
00001516  BBFC 00005000            252              CMPA.L      #$00005000,A5       ;If start address is <0x5000
0000151C  6D00 0036                253              BLT         C_ERR2
00001520                           254              
00001520  200D                     255              MOVE.L      A5,D0               ;Check rightmost input address bit
00001522  0800 0000                256              BTST        #0,D0               ;If rightmost (least sig) bit is 1 (aka ODD address)
00001526  6600 0040                257              BNE         C_ERR3           
0000152A                           258              
0000152A  200E                     259              MOVE.L      A6,D0               ;Check rightmost input address bit
0000152C  0800 0000                260              BTST        #0,D0               ;If rightmost (least sig) bit is 1 (aka ODD address)
00001530  6600 004A                261              BNE         C_ERR4
00001534                           262              
00001534  4E75                     263              RTS                             ;If none of the above, input is valid
00001536                           264              
00001536  4EB9 00001590            265  C_INVALID   JSR         C_ERR_BASE1         ;Clear screen and clear registers
0000153C  6000 0080                266              BRA         C_ERR_BASE2         ;Print generic error msg and branch to start
00001540                           267  
00001540  4EB9 00001590            268  C_ERR1      JSR         C_ERR_BASE1         ;Clear screen and registers
00001546  43F8 133F                269              LEA         M_ERR_ADDR1,A1      ;Load error message
0000154A  103C 000E                270              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000154E  4E4F                     271              TRAP        #15
00001550                           272              
00001550  6000 006C                273              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
00001554                           274  
00001554  4EB9 00001590            275  C_ERR2      JSR         C_ERR_BASE1         ;Clear screen and registers
0000155A  43F8 1362                276              LEA         M_ERR_ADDR2,A1      ;Load error message
0000155E  103C 000E                277              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001562  4E4F                     278              TRAP        #15
00001564                           279              
00001564  6000 0058                280              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
00001568                           281  
00001568                           282  
00001568                           283              
00001568  4EB9 00001590            284  C_ERR3      JSR         C_ERR_BASE1         ;Clear screen and registers
0000156E  43F8 13A4                285              LEA         M_ERR_ADDR3,A1      ;Load error message
00001572  103C 000E                286              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001576  4E4F                     287              TRAP        #15
00001578                           288              
00001578  6000 0044                289              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
0000157C                           290  
0000157C  4EB9 00001590            291  C_ERR4      JSR         C_ERR_BASE1         ;Clear screen and registers
00001582  43F8 13BD                292              LEA         M_ERR_ADDR4,A1      ;Load error message
00001586  103C 000E                293              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000158A  4E4F                     294              TRAP        #15
0000158C                           295              
0000158C  6000 0030                296              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
00001590                           297  
00001590                           298  
00001590  103C 000B                299  C_ERR_BASE1 MOVE.B      #11,D0              ;Clear screen
00001594  323C FF00                300              MOVE.W      #$FF00,D1
00001598  4E4F                     301              TRAP        #15
0000159A                           302              
0000159A  4282                     303              CLR.L       D2
0000159C  4285                     304              CLR.L       D5
0000159E  4286                     305              CLR.L       D6
000015A0                           306                                
000015A0                           307  
000015A0  21FC FFFFFFFF 10E2       308              MOVE.L      #$FFFFFFFF,(START_ADDR)        
000015A8  21FC FFFFFFFF 1100       309              MOVE.L      #$FFFFFFFF,(END_ADDR)
000015B0  2A7C 00000000            310              MOVEA.L     #$00000000,A5       ;Clear registers
000015B6  2C7C 00000000            311              MOVEA.L     #$00000000,A6 
000015BC                           312       
000015BC  4E75                     313              RTS
000015BE                           314  
000015BE  43F8 130F                315  C_ERR_BASE2 LEA         M_INV_INPUT,A1      ;Load error message
000015C2  103C 000E                316              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000015C6  4E4F                     317              TRAP        #15
000015C8                           318              
000015C8  6000 FA36                319              BRA         START 
000015CC                           320             
000015CC                           321  
000015CC                           322  
000015CC                           323  -------------------- end include --------------------
000015CC                           324              INCLUDE     'TeamVisualBasic_Disassembler_OutputBuilder.X68'    ;Include OutputBuilder class file
000015CC                           325  
000015CC  4EB9 000015E0            326  BUILD_STR   JSR         PREPARE_OP          ;Define a location in memory to write an OPCODE string to
000015D2  4EB9 000015E6            327              JSR         GET_ADDR            ;Accumulate the OPCODE's address into the A4 string [0xADDR]
000015D8  4EB9 00001626            328              JSR         JT_START            ;Send OPCODE to jump table for decoding [OPCODE $OPERAND]
000015DE                           329              
000015DE  4E75                     330              RTS                             ;Return back to main disassembler loop
000015E0                           331  
000015E0  387C 111E                332  PREPARE_OP  MOVE.W      #OP_ADDR,A4         ;Define a location in memory to write an OPCODE string to
000015E4  4E75                     333              RTS
000015E6                           334              
000015E6  200D                     335  GET_ADDR    MOVE.L      A5,D0               ;Save the address pointer into D0
000015E8  4282                     336              CLR.L       D2                  ;Clear D2
000015EA  143C 0008                337              MOVE.B      #8,D2               ;Counter var starts at 8
000015EE                           338              
000015EE  4EB9 00001602            339  GA_LOOP     JSR         HEX_2_ASCII         ;Convert the hex to ascii for printing
000015F4  5342                     340              SUBI        #1,D2               ;Decrement counter var
000015F6  B43C 0000                341              CMP.B       #0,D2               ;Is counter var == 0?
000015FA  6EF2                     342              BGT         GA_LOOP             ;If not, loop         
000015FC                           343              
000015FC  18FC 0009                344              MOVE.B      #09,(A4)+           ;Otherwise, we are done. Append a tab
00001600  4E75                     345              RTS                             ;Return back to main disassembler loop    
00001602                           346  
00001602  E998                     347  HEX_2_ASCII ROL.L       #4,D0               ;Get the most significant hex digit into the right 4 bits
00001604  1200                     348              MOVE.B      D0,D1               ;Save that byte into D1
00001606  0241 000F                349              ANDI        #$0F,D1             ;Isolate the hex digit 
0000160A                           350              
0000160A  B23C 0009                351              CMP.B       #$9,D1              ;If hex digit is > 9
0000160E  6E00 0006                352              BGT         APPND_ALPHA         ;It is an alphabet ascii char. Branch
00001612  6000 000A                353              BRA         APPND_NUM           ;Else it is a numeric ascii char. Branch
00001616                           354              
00001616  0601 0037                355  APPND_ALPHA ADDI.B      #$37,D1             ;Add $37 to make it a ascii alphabet char
0000161A  18C1                     356              MOVE.B      D1,(A4)+            ;Append this character to string
0000161C  4E75                     357              RTS           
0000161E                           358  
0000161E  0601 0030                359  APPND_NUM   ADDI.B      #$30,D1             ;Add $30 to make it a ascii numeric char
00001622  18C1                     360              MOVE.B      D1,(A4)+            ;Append this character to string
00001624  4E75                     361              RTS
00001626                           362         
00001626                           363  
00001626                           364  
00001626                           365  -------------------- end include --------------------
00001626                           366              INCLUDE     'TeamVisualBasic_JumpTable.X68'                     ;Include Jump Table file
00001626                           367  
00001626  3015                     368  JT_START    MOVE.W      (A5),D0             *move op code into d0 to bit shift
00001628  E848                     369              LSR.W       #4,D0               *Shift right 4 bits
0000162A  E848                     370              LSR.W       #4,D0               *shift right 4 bits
0000162C  E848                     371              LSR.W       #4,D0               *shift right 4 bits
0000162E                           372              
0000162E  0C40 0000                373              CMPI.W      #0,D0               *check if it falls into 0 bin
00001632  6700 007A                374              BEQ         BIN_0
00001636                           375      
00001636  0C40 0001                376              CMPI.W      #1,D0               *check if it is a MOVE
0000163A  6700 00A2                377              BEQ         BIN_MOVE
0000163E                           378              
0000163E  0C40 0002                379              CMPI.W      #2,D0               *check if it is a MOVE
00001642  6700 009A                380              BEQ         BIN_MOVE
00001646                           381              
00001646  0C40 0003                382              CMPI.W      #3,D0               *check if it is a MOVE
0000164A  6700 0092                383              BEQ         BIN_MOVE
0000164E                           384              
0000164E  0C40 0004                385              CMPI.W      #4,D0               *check if it falls into 4 bin
00001652  6700 00A6                386              BEQ         BIN_4
00001656                           387  
00001656  0C40 0005                388              CMPI.W      #5,D0               *check if it falls into 5 bin
0000165A  6700 00DC                389              BEQ         BIN_5
0000165E                           390  
0000165E  0C40 0006                391              CMPI.W      #6,D0               *check if it falls into 6 bin
00001662  6700 00D8                392              BEQ         BIN_6
00001666                           393  
00001666  0C40 0007                394              CMPI.W      #7,D0               *check if it falls into 7 bin
0000166A  6700 010A                395              BEQ         BIN_7
0000166E                           396  
0000166E  0C40 0008                397              CMPI.W      #8,D0               *check if it falls into 8 bin
00001672  6700 0106                398              BEQ         BIN_8
00001676                           399  
00001676  0C40 0009                400              CMPI.W      #9,D0               *check if it falls into 9 bin
0000167A  6700 0112                401              BEQ         BIN_9
0000167E                           402  
0000167E  0C40 000A                403              CMPI.W      #10,D0              *check if it falls into 10 bin
00001682  6700 010E                404              BEQ         BIN_10
00001686                           405  
00001686  0C40 000B                406              CMPI.W      #11,D0              *check if it falls into 11 bin
0000168A  6700 010A                407              BEQ         BIN_11
0000168E                           408  
0000168E  0C40 000C                409              CMPI.W      #12,D0              *check if it falls into 12 bin
00001692  6700 0120                410              BEQ         BIN_12
00001696                           411  
00001696  0C40 000D                412              CMPI.W      #13,D0              *check if it falls into 12 bin
0000169A  6700 011C                413              BEQ         BIN_13
0000169E                           414  
0000169E  0C40 000E                415              CMPI.W      #14,D0              *check if it falls into 14 bin
000016A2  6700 0130                416              BEQ         BIN_14
000016A6                           417  
000016A6  0C40 000F                418              CMPI.W      #15,D0              *check if it falls into 15 bin
000016AA  6700 014C                419              BEQ         BIN_15
000016AE                           420  
000016AE  3015                     421  BIN_0       MOVE.W      (A5),D0             *reload opcode
000016B0  E048                     422              LSR.W       #8,D0               *shift bits to the right 8
000016B2  C07C 000F                423              AND.W       #$0F,D0             *Isolate the last 4 bits
000016B6                           424              
000016B6  0C40 000C                425              CMPI.W      #12,D0              *Check if the bit is C
000016BA  6700 014C                426              BEQ         CMPI                *if CMPI go to the subroutine
000016BE                           427              
000016BE  0C40 0000                428              CMPI.W      #0,D0               *Check if the bit is a 0
000016C2  6700 0138                429              BEQ         ORI                 *if ORI go to the subroutine
000016C6                           430              
000016C6  0C40 0008                431              CMPI.W      #8,D0               *Check if the bit is an 8
000016CA  6700 0148                432              BEQ         BCLR                *if BCLR immediate go to subroutine
000016CE                           433              
000016CE  C07C 0001                434              AND.W       #$01,D0             *isolate the last bit
000016D2  0C40 0001                435              CMPI.W      #1,D0               *Check if the bit is a 1
000016D6  6700 013C                436              BEQ         BCLR                *if BCLR register go to subroutine
000016DA                           437              
000016DA  6000 02BA                438              BRA         DATA           
000016DE                           439  
000016DE  3015                     440  BIN_MOVE    MOVE.W      (A5),D0             *reload opcode
000016E0  EC48                     441              LSR.W       #6,D0               *shift bits to the right 6
000016E2  C07C 0007                442              AND.W       #$07,D0             *isolate the last 3 bits
000016E6  0C40 0001                443              CMPI.W      #1,D0               *check if the bits are 001
000016EA  6700 013A                444              BEQ         MOVEA               *if MOVEA go to SUB
000016EE                           445              
000016EE  0C40 0007                446              CMPI.W      #7,D0               *check if the bits are 111
000016F2  6700 02A2                447              BEQ         DATA                *if 111 must be DATA
000016F6  6000 0122                448              BRA         MOVE                *otherwise must be MOVE
000016FA                           449              
000016FA  3015                     450  BIN_4       MOVE.W      (A5),D0             *reload opcode
000016FC  0C40 4E71                451              CMPI.W      #$4E71,D0           *check for no-op value
00001700  6700 0144                452              BEQ         NOP                 *if NOP go to SUB
00001704                           453              
00001704  0C40 4E75                454              CMPI.W      #$4E75,D0           *Compare with a constant value for RTS      
00001708  6700 0158                455              BEQ         RTS                 *if RTS go to RTS subroutine
0000170C                           456              
0000170C  E848                     457              LSR.W       #4,D0               *shift right 4 bits
0000170E  E848                     458              LSR.W       #4,D0               *shift right 4 bits
00001710  C07C 000F                459              AND.W       #$0F,D0             *bitmask first 4 bits  
00001714  0C40 000E                460              CMPI.W      #$E,D0              *compare final masked bits
00001718  6700 0178                461              BEQ         JSR                 *if it equals E it is JSR
0000171C                           462              
0000171C  0C40 0004                463              CMPI.W      #$4,D0              *check for defining bits
00001720  6700 017A                464              BEQ         NEG                 *branch to NEG routine
00001724                           465              
00001724  C07C 0001                466              AND.W       #$1,D0
00001728  0C40 0001                467              CMPI.W      #1,D0
0000172C  6700 014E                468              BEQ         LEA
00001730                           469              
00001730  0C40 0000                470              CMPI.W      #0,D0
00001734  6700 0150                471              BEQ         MOVEM
00001738                           472              
00001738  6000 016E                473  BIN_5       BRA         SUBQ                *SUBQ is the only option for this bin so branch to SUB
0000173C                           474  
0000173C  3015                     475  BIN_6       MOVE.W      (A5),D0             *reload fresh op code
0000173E  E848                     476              LSR.W       #4,D0               *shift right 4
00001740  E848                     477              LSR.W       #4,D0               *shift right 4
00001742  C07C 000F                478              AND.W       #$0F,D0             *Finds the condition code of the branch statement through bitmask
00001746                           479              
00001746  0C40 0000                480              CMPI.W      #0,D0               *check if the 4 bits == 0000
0000174A  6700 019C                481              BEQ         BRA_SUB             *branch to BRA SUB
0000174E                           482              
0000174E  0C40 0004                483              CMPI.W      #4,D0
00001752  6700 0180                484              BEQ         BCC                 *branch to BCC code 
00001756                           485                                                                       
00001756  0C40 000D                486              CMPI.W      #$D,D0
0000175A  6700 0182                487              BEQ         BLT                 *branch to BLT SUB            
0000175E                           488                                                                   
0000175E  0C40 0008                489              CMPI.W      #8,D0
00001762  6700 0166                490              BEQ         BVC                 *branch to BVC code
00001766                           491              
00001766  0C40 0005                492              CMPI.W      #5,D0
0000176A  6700 0154                493              BEQ         BCS                 *branch to BCS code
0000176E                           494              
0000176E  0C40 000C                495              CMPI.W      #$C,D0
00001772  6700 0140                496              BEQ         BGE                 *branch to BGE code
00001776                           497  
00001776  6000 021E                498  BIN_7       BRA        DATA                *If it goes into this bin it is DATA
0000177A                           499  
0000177A  3015                     500  BIN_8       MOVE.W      (A5),D0
0000177C  EC48                     501              LSR.W       #6,D0
0000177E  C07C 0007                502              AND.W       #$07,D0   
00001782  0C40 0007                503              CMPI.W      #7,D0
00001786  6700 016A                504              BEQ         DIVS
0000178A                           505              
0000178A  6000 016C                506              BRA         OR  
0000178E                           507              
0000178E  6000 0174                508  BIN_9       BRA         SUB                 *SUB is the only option for this bin so branch to SUB
00001792                           509  
00001792  6000 0202                510  BIN_10      BRA        DATA                *If it goes into this bin it is DATA
00001796                           511  
00001796  3015                     512  BIN_11      MOVE.W      (A5),D0             *reload opcode into D0
00001798  E848                     513              LSR.W       #4,D0               *shift bits to the right 4
0000179A  E848                     514              LSR.W       #4,D0               *Shift bits to the right 4
0000179C  C07C 0001                515              AND.W       #$01,D0             *isolate the last bit
000017A0  0C40 0001                516              CMPI.W      #1,D0               *check if the bit is a 1
000017A4  6700 016A                517              BEQ         EOR                 *if EOR go to the SUB
000017A8                           518              
000017A8  0C40 0000                519              CMPI.W      #0,D0               *check if the bit is a 0
000017AC  6700 016E                520              BEQ         CMP                 *if CMP go to the SUB
000017B0                           521              
000017B0  6000 01E4                522              BRA         DATA                *if neither EOR or CMP must be DATA
000017B4                           523              
000017B4  6000 0172                524  BIN_12      BRA         MULS                *MULS is the only option for this bin so branch to SUB
000017B8                           525  
000017B8  3015                     526  BIN_13      MOVE.W      (A5),D0             *reload opcode into D0
000017BA  EC48                     527              LSR.W       #6,D0               *shift bits to the right 6
000017BC  C07C 0007                528              AND.W       #$07,D0             *isolate the last 3 bits
000017C0  0C40 0003                529              CMPI.W      #$3,D0              *check if the bits are 011
000017C4  6700 0174                530              BEQ         ADDA                *if ADDA go to SUB        
000017C8                           531              
000017C8  0C40 0007                532              CMPI.W      #$7,D0              *check if the bits are 111
000017CC  6700 016C                533              BEQ         ADDA                *if ADDA go to SUB 
000017D0                           534                                                          
000017D0  6000 015C                535              BRA         ADD                 *if bits are not ADDA must be ADD and go to SUB
000017D4                           536              
000017D4  3015                     537  BIN_14      MOVE.W      (A5),D0             *Reload the opcode
000017D6  E648                     538              LSR.W       #3,D0               *shift bits down
000017D8  C07C 0007                539              AND.W       #$07,D0             *mask bits
000017DC  B07C 0001                540              CMP.W       #1,D0               *determin which kind of shift it is
000017E0  6700 015E                541              BEQ         LOGICSHIFT          *bra to logic shift
000017E4                           542              
000017E4  B07C 0000                543              CMP.W       #0,D0
000017E8  6700 0168                544              BEQ         ARITH_SHIFT         *bra to arthimetic shift
000017EC                           545              
000017EC  B07C 0003                546              CMP.W       #3,D0
000017F0  6700 0172                547              BEQ         ROTATE              *bra to rotate      
000017F4                           548              
000017F4  6000 01A0                549              BRA         DATA                *if not a shift must be DATA 
000017F8                           550                                                                  
000017F8                           551  
000017F8  6000 019C                552  BIN_15      BRA        DATA                *IF it goes into this bin it is DATA
000017FC                           553                                                                                               
000017FC                           554  
000017FC                           555  
000017FC  38FC 1AA4                556  ORI         MOVE.W      #S_ORI,(A4)+        *Load OPCODE string into (A4)
00001800  4EB9 000019B2            557              JSR         GET_SIZE_67
00001806  4E75                     558              RTS
00001808                           559              
00001808  38FC 1AA8                560  CMPI        MOVE.W      #S_CMPI,(A4)+       *Load OPCODE string into (A4)
0000180C  4EB9 000019B2            561              JSR         GET_SIZE_67
00001812  4E75                     562              RTS
00001814                           563              
00001814  38FC 1AAD                564  BCLR        MOVE.W      #S_BCLR,(A4)+       *Load OPCODE string into (A4)
00001818  4E75                     565              RTS            
0000181A                           566  
0000181A  38FC 1AB2                567  MOVE        MOVE.W      #S_MOVE,(A4)+       *Load OPCODE string into (A4)
0000181E  4EB9 000019EE            568              JSR         MOVE_SIZE
00001824  4E75                     569              RTS
00001826                           570              
00001826  38FC 1AB7                571  MOVEA       MOVE.W      #S_MOVEA,(A4)+      *Load OPCODE string into (A4)
0000182A  3015                     572              MOVE.W      (A5),D0             *reload OPCODE into (A5)
0000182C  E848                     573              LSR.W       #4,D0               *shift bits right 4
0000182E  E848                     574              LSR.W       #4,D0
00001830  E848                     575              LSR.W       #4,D0               *shift bits a total of 12 right
00001832  C07C 0003                576              AND.W       #$03,D0             *isolate the last 2 bits
00001836  0C40 0001                577              CMPI.W      #1,D0
0000183A  6700 015A                578              BEQ         DATA                *byte operations are not supported for MOVEA
0000183E  4EB9 000019EE            579              JSR         MOVE_SIZE
00001844  4E75                     580              RTS   
00001846                           581  
00001846                           582  
00001846  5447                     583  NOP         ADDI        #BYTE,D7            *NOP is 2 Bytes; Increment length var by 2
00001848  18FC 004E                584              MOVE.B      #'N',(A4)+          *Load OPCODE string into (A4)
0000184C  18FC 004F                585              MOVE.B      #'O',(A4)+
00001850  18FC 0050                586              MOVE.B      #'P',(A4)+
00001854  18FC 0020                587              MOVE.B      #' ',(A4)+
00001858  18FC 0000                588              MOVE.B      #0,(A4)+            *End the string with a 0 delimiter 
0000185C  3E3C 0002                589              MOVE.W      #2,D7
00001860  4E75                     590              RTS
00001862                           591              
00001862                           592              
00001862  18FC 0052                593  RTS         MOVE.B      #'R',(A4)+          *Load OPCODE string into (A4)
00001866  18FC 0054                594              MOVE.B      #'T',(A4)+
0000186A  18FC 0053                595              MOVE.B      #'S',(A4)+
0000186E  18FC 0020                596              MOVE.B      #' ',(A4)+
00001872  18FC 0000                597              MOVE.B      #0,(A4)+            *End the string with a 0 delimiter 
00001876  3E3C 0002                598              MOVE.W      #2,D7
0000187A  4E75                     599              RTS       
0000187C                           600              
0000187C  38FC 1AD9                601  LEA         MOVE.W      #S_LEA,(A4)+        *Load OPCODE string into (A4)
00001880  3E3C 0002                602              MOVE.W      #2,D7
00001884  4E75                     603              RTS
00001886                           604              
00001886  38FC 1AE1                605  MOVEM       MOVE.W      #S_MOVEM,(A4)+      *Load OPCODE string into (A4)
0000188A  4EB9 000019D4            606              JSR         MOVEM_SIZE
00001890  4E75                     607              RTS
00001892                           608              
00001892  38FC 1AF9                609  JSR         MOVE.W      #S_JSR,(A4)+        *Load OPCODE string into (A4)
00001896  3E3C 0002                610              MOVE.W      #2,D7
0000189A  4E75                     611              RTS
0000189C                           612              
0000189C  38FC 1ADD                613  NEG         MOVE.W      #S_NEG,(A4)+        *Load OPCODE string into (A4)
000018A0  4EB9 000019B2            614              JSR         GET_SIZE_67
000018A6  4E75                     615              RTS
000018A8                           616               
000018A8                           617              
000018A8  38FC 1AE7                618  SUBQ        MOVE.W      #S_SUBQ,(A4)+       *Load OPCODE string into (A4)
000018AC  4EB9 000019B2            619              JSR         GET_SIZE_67
000018B2  4E75                     620              RTS
000018B4                           621             
000018B4  38F9 00001ABD            622  BGE         MOVE.W      S_BGE,(A4)+         *Load OPCODE string into (A4)
000018BA  3E3C 0002                623              MOVE.W      #2,D7               *saving the OPCODE size into D7
000018BE  4E75                     624              RTS           
000018C0                           625              
000018C0  38FC 1AC1                626  BCS         MOVE.W      #S_BCS,(A4)+        *Load OPCODE string into (A4)
000018C4  3E3C 0002                627              MOVE.W      #2,D7               *saving the OPCODE size into D7
000018C8  4E75                     628              RTS
000018CA                           629              
000018CA  38FC 1AC5                630  BVC         MOVE.W      #S_BVC,(A4)+        *Load OPCODE string into (A4)
000018CE  3E3C 0002                631              MOVE.W      #2,D7               *saving the OPCODE size into D7
000018D2  4E75                     632              RTS
000018D4                           633              
000018D4  38FC 1AC9                634  BCC         MOVE.W      #S_BCC,(A4)+        *Load OPCODE string into (A4)
000018D8  3E3C 0002                635              MOVE.W      #2,D7               *saving the OPCODE size into D7
000018DC  4E75                     636              RTS
000018DE                           637              
000018DE  38FC 1ACD                638  BLT         MOVE.W      #S_BLT,(A4)+        *Load OPCODE string into (A4)
000018E2  3E3C 0002                639              MOVE.W      #2,D7               *saving the OPCODE size into D7
000018E6  4E75                     640              RTS
000018E8                           641  
000018E8  38FC 1AD1                642  BRA_SUB     MOVE.W      #S_BRA,(A4)+        *Load OPCODE string into (A4)
000018EC  3E3C 0002                643              MOVE.W      #2,D7               *saving the OPCODE size into D7
000018F0  4E75                     644              RTS
000018F2                           645              
000018F2  38FC 1AED                646  DIVS        MOVE.W      #S_DIVS,(A4)+       *Load OPCODE string into (A4)
000018F6  4E75                     647              RTS
000018F8                           648              
000018F8  38FC 1AF2                649  OR          MOVE.W      #S_OR,(A4)+         *Load OPCODE string into (A4)
000018FC  4EB9 00001A14            650              JSR         SIZE_678
00001902  4E75                     651              RTS
00001904                           652              
00001904  38FC 1AF5                653  SUB         MOVE.W      #S_SUB,(A4)+        *Load OPCODE string into (A4)
00001908  4EB9 00001A14            654              JSR         SIZE_678
0000190E  4E75                     655              RTS
00001910                           656              
00001910  38FC 1A8E                657  EOR         MOVE.W      #S_EOR,(A4)+        *Load OPCODE string into (A4)
00001914  4EB9 000019B2            658              JSR         GET_SIZE_67
0000191A  4E75                     659              RTS
0000191C                           660  
0000191C  38FC 1A92                661  CMP         MOVE.W      #S_CMP,(A4)+        *Load OPCODE string into (A4)
00001920  4EB9 000019B2            662              JSR         GET_SIZE_67
00001926  4E75                     663              RTS
00001928                           664  
00001928  38FC 1A96                665  MULS        MOVE.W      #S_MULS,(A4)+       *Load OPCODE string into (A4)
0000192C  4E75                     666              RTS
0000192E                           667              
0000192E  38FC 1A9B                668  ADD         MOVE.W      #S_ADD,(A4)+        *Load OPCODE string into (A4)
00001932  4EB9 00001A14            669              JSR         SIZE_678
00001938  4E75                     670              RTS
0000193A                           671  
0000193A  38FC 1A9F                672  ADDA        MOVE.W      #S_ADDA,(A4)+       *Load OPCODE string into (A4)
0000193E  4E75                     673              RTS
00001940                           674       
00001940                           675                                                                      
00001940  38FC 1AFD                676  LOGICSHIFT  MOVE.W      #S_LS,(A4)+         *Load logical shift OPCODE string into (A4)                    
00001944  4EB9 00001976            677              JSR         RIGHTORLEFT 
0000194A  4EB9 000019B2            678              JSR         GET_SIZE_67
00001950  4E75                     679              RTS            
00001952                           680  
00001952  38FC 1B00                681  ARITH_SHIFT MOVE.W      #S_AS,(A4)+         *Load arithmetic shift OPCODE string into (A4)             
00001956  4EB9 00001976            682              JSR         RIGHTORLEFT
0000195C  4EB9 000019B2            683              JSR         GET_SIZE_67
00001962  4E75                     684              RTS         
00001964                           685                  
00001964  38FC 1B03                686  ROTATE      MOVE.W      #S_RO,(A4)+         *Load rotate OPCODE string into (A4)           
00001968  4EB9 00001976            687              JSR         RIGHTORLEFT
0000196E  4EB9 000019B2            688              JSR         GET_SIZE_67
00001974  4E75                     689              RTS
00001976                           690                
00001976  3010                     691  RIGHTORLEFT MOVE.W      (A0),D0             *reload op
00001978  E148                     692              LSL.W       #8,D0               *shift until dr bit is reached
0000197A  B07C 0000                693              CMP.W       #0,D0               *check if left
0000197E  6700 000A                694              BEQ         LEFT
00001982                           695              
00001982  B07C 0001                696              CMP.W       #1,D0               *check if right
00001986  6700 0008                697              BEQ         RIGHT  
0000198A                           698                                                
0000198A  38FC 1B06                699  LEFT        MOVE.W      #S_LEFT,(A4)+       *Load directional string into (A4)
0000198E  4E75                     700              RTS                      
00001990                           701             
00001990                           702             
00001990  38FC 1B08                703  RIGHT       MOVE.W      #S_RIGHT,(A4)+      *Load directional string into (A4)
00001994  4E75                     704              RTS
00001996                           705                                    
00001996                           706  
00001996                           707  
00001996  18FC 0044                708  DATA        MOVE.B      #'D',(A4)+          *Write DATA into string
0000199A  18FC 0041                709              MOVE.B      #'A',(A4)+          
0000199E  18FC 0054                710              MOVE.B      #'T',(A4)+          
000019A2  18FC 0041                711              MOVE.B      #'A',(A4)+         
000019A6  18FC 0020                712              MOVE.B      #' ',(A4)+          *Write a space into string
000019AA                           713              
000019AA  18FC 0000                714              MOVE.B      #0,(A4)+            *End the string with a 0 delimiter 
000019AE                           715              
000019AE  38D5                     716              MOVE.W      (A5),(A4)+          *Write the word's worth of OPCODE data that couldn't be decoded
000019B0                           717              
000019B0  4E75                     718              RTS                             *Return program flow back to Dissasembler file
000019B2                           719  
000019B2  3015                     720  GET_SIZE_67 MOVE.W      (A5),D0             *reload OPCODE into (A5)
000019B4  EC48                     721              LSR.W       #6,D0               *shift bits right 6
000019B6  C07C 0003                722              AND.W       #$03,D0             *Isolate last 2 bits
000019BA  0C40 0000                723              CMPI.W      #0,D0
000019BE  6700 00AC                724              BEQ         APPND_BYTE          *Is a Byte operation
000019C2  0C40 0001                725              CMPI.W      #1,D0
000019C6  6700 00AE                726              BEQ         APPND_WORD          *Is a Word operation
000019CA  0C40 0002                727              CMPI.W      #2,D0
000019CE  6700 00B0                728              BEQ         APPND_LONG          *Is a Long operation
000019D2  60C2                     729              BRA         DATA                *Not a valid size must be data 
000019D4                           730  
000019D4  3015                     731  MOVEM_SIZE  MOVE.W      (A5),D0             *reload OPCODE into (A5)
000019D6  EC48                     732              LSR.W       #6,D0               *shift bits right 6
000019D8  C07C 0001                733              AND.W       #$01,D0             *isolate last bit
000019DC  0C40 0000                734              CMPI.W      #0,D0
000019E0  6700 0094                735              BEQ         APPND_WORD          *is a word operation
000019E4  0C40 0001                736              CMPI.W      #1,D0
000019E8  6700 0096                737              BEQ         APPND_LONG          *is a long operation
000019EC  60A8                     738              BRA         DATA
000019EE                           739              
000019EE  3015                     740  MOVE_SIZE   MOVE.W      (A5),D0             *reload OPCODE into (A5)
000019F0  E848                     741              LSR.W       #4,D0               *shift bits right 4
000019F2  E848                     742              LSR.W       #4,D0
000019F4  E848                     743              LSR.W       #4,D0               *shift bits a total of 12 right
000019F6  C07C 0003                744              AND.W       #$03,D0             *isolate the last 2 bits
000019FA  0C40 0001                745              CMPI.W      #1,D0               
000019FE  6700 006C                746              BEQ         APPND_BYTE          *is a byte operation
00001A02  0C40 0003                747              CMPI.W      #3,D0               
00001A06  6700 006E                748              BEQ         APPND_WORD          *is a word operation
00001A0A  0C40 0002                749              CMPI.W      #2,D0               
00001A0E  6700 0070                750              BEQ         APPND_LONG          *is a long operation
00001A12  6082                     751              BRA         DATA
00001A14                           752              
00001A14  3015                     753  SIZE_678    MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001A16  EC48                     754              LSR.W       #6,D0               *shift the bits right 6
00001A18  C07C 0007                755              AND.W       #$07,D0             *isolate the last 3 bits
00001A1C  0C40 0000                756              CMPI.W      #0,D0               
00001A20  6700 004A                757              BEQ         APPND_BYTE          *is a byte operation
00001A24  0C40 0004                758              CMPI.W      #4,D0
00001A28  6700 0042                759              BEQ         APPND_BYTE          *is a byte operation
00001A2C  0C40 0001                760              CMPI.W      #1,D0               
00001A30  6700 0044                761              BEQ         APPND_WORD          *is a word operation
00001A34  0C40 0005                762              CMPI.W      #5,D0               
00001A38  6700 003C                763              BEQ         APPND_WORD          *is a word operation
00001A3C  0C40 0002                764              CMPI.W      #2,D0
00001A40  6700 003E                765              BEQ         APPND_LONG          *is a long operation
00001A44  0C40 0006                766              CMPI.W      #6,D0
00001A48  6700 0036                767              BEQ         APPND_LONG          *is a long operation
00001A4C  6000 FF48                768              BRA         DATA                *is not one of the supported sizes
00001A50                           769              
00001A50  3015                     770  ADDA_SIZE   MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001A52  EC48                     771              LSR.W       #6,D0               *shift the bits right 6
00001A54  C07C 0007                772              AND.W       #$07,D0             *isolate the last 3 bits
00001A58  0C40 0003                773              CMPI.W      #3,D0
00001A5C  6700 0018                774              BEQ         APPND_WORD          *is a word operation
00001A60  0C40 0007                775              CMPI.W      #7,D0
00001A64  6700 001A                776              BEQ         APPND_LONG          *is a long operation
00001A68  6000 FF2C                777              BRA         DATA                *is not one of the supported sizes
00001A6C                           778  
00001A6C  38FC 1B0F                779  APPND_BYTE  MOVE.W      #S_BYTE,(A4)+       *load size into (A4)
00001A70  3E3C 0004                780              MOVE.W      #4,D7               *saving length of OPCODE + size in D7
00001A74  4E75                     781              RTS
00001A76                           782  
00001A76  38FC 1B12                783  APPND_WORD  MOVE.W      #S_WORD,(A4)+       *load size into (A4)
00001A7A  3E3C 0006                784              MOVE.W      #6,D7               *saving length of OPCODE + size in D7
00001A7E  4E75                     785              RTS
00001A80                           786  
00001A80  38FC 1B15                787  APPND_LONG  MOVE.W      #S_LONG,(A4)+       *load size into (A4)
00001A84  3E3C 000A                788              MOVE.W      #10,D7              *saving length of OPCODE + size in D7
00001A88  4E75                     789              RTS                
00001A8A                           790              
00001A8A                           791              ;INCLUDE     'TeamVisualBasic_OP_Decoder.X68'    ;Helper file for jump table
00001A8A                           792              
00001A8A= 4E 4F 50 00              793  S_NOP       DC.B        'NOP',0   
00001A8E= 45 4F 52 00              794  S_EOR       DC.B        'EOR',0
00001A92= 43 4D 50 00              795  S_CMP       DC.B        'CMP',0
00001A96= 4D 55 4C 53 00           796  S_MULS      DC.B        'MULS',0
00001A9B= 41 44 44 00              797  S_ADD       DC.B        'ADD',0
00001A9F= 41 44 44 41 00           798  S_ADDA      DC.B        'ADDA',0
00001AA4= 4F 52 49 00              799  S_ORI       DC.B        'ORI',0
00001AA8= 43 4D 50 49 00           800  S_CMPI      DC.B        'CMPI',0
00001AAD= 42 43 4C 52 00           801  S_BCLR      DC.B        'BCLR',0
00001AB2= 4D 4F 56 45 00           802  S_MOVE      DC.B        'MOVE',0
00001AB7= 4D 4F 56 45 41 00        803  S_MOVEA     DC.B        'MOVEA',0
00001ABD= 42 47 45 00              804  S_BGE       DC.B        'BGE',0
00001AC1= 42 43 53 00              805  S_BCS       DC.B        'BCS',0
00001AC5= 42 56 43 00              806  S_BVC       DC.B        'BVC',0
00001AC9= 42 43 43 00              807  S_BCC       DC.B        'BCC',0 
00001ACD= 42 4C 54 00              808  S_BLT       DC.B        'BLT',0
00001AD1= 42 52 41 00              809  S_BRA       DC.B        'BRA',0                      
00001AD5= 52 54 53 00              810  S_RTS       DC.B        'RTS',0
00001AD9= 4C 45 41 00              811  S_LEA       DC.B        'LEA',0
00001ADD= 4E 45 47 00              812  S_NEG       DC.B        'NEG',0 
00001AE1= 4D 4F 56 45 4D 00        813  S_MOVEM     DC.B        'MOVEM',0
00001AE7= 53 55 42 2E 51 00        814  S_SUBQ      DC.B        'SUB.Q',0
00001AED= 44 49 56 53 00           815  S_DIVS      DC.B        'DIVS',0
00001AF2= 4F 52 00                 816  S_OR        DC.B        'OR',0
00001AF5= 53 55 42 00              817  S_SUB       DC.B        'SUB',0
00001AF9= 4A 53 52 00              818  S_JSR       DC.B        'JSR',0
00001AFD= 4C 53 00                 819  S_LS        DC.B        'LS',0
00001B00= 41 53 00                 820  S_AS        DC.B        'AS',0
00001B03= 52 30 00                 821  S_RO        DC.B        'R0',0
00001B06= 4C 00                    822  S_LEFT      DC.B        'L',0
00001B08= 52 00                    823  S_RIGHT     DC.B        'R',0
00001B0A= 44 41 54 41 00           824  S_DATA      DC.B        'DATA',0
00001B0F= 2E 42 00                 825  S_BYTE      DC.B        '.B',0
00001B12= 2E 57 00                 826  S_WORD      DC.B        '.W',0
00001B15= 2E 4C 00                 827  S_LONG      DC.B        '.L',0
00001B18                           828  
00001B18                           829  
00001B18                           830  
00001B18                           831  
00001B18                           832  
00001B18                           833  
00001B18                           834  
00001B18                           835  
00001B18                           836  
00001B18                           837  
00001B18                           838  
00001B18                           839  -------------------- end include --------------------
00001B18                           840              
00001B18                           841              END         START               ;last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 192E
ADDA                193A
ADDA_SIZE           1A50
APPND_ALPHA         1616
APPND_BYTE          1A6C
APPND_LONG          1A80
APPND_NUM           161E
APPND_WORD          1A76
ARITH_SHIFT         1952
BCC                 18D4
BCLR                1814
BCS                 18C0
BGE                 18B4
BIN_0               16AE
BIN_10              1792
BIN_11              1796
BIN_12              17B4
BIN_13              17B8
BIN_14              17D4
BIN_15              17F8
BIN_4               16FA
BIN_5               1738
BIN_6               173C
BIN_7               1776
BIN_8               177A
BIN_9               178E
BIN_MOVE            16DE
BLT                 18DE
BRA_SUB             18E8
BUILD_STR           15CC
BVC                 18CA
BYTE                2
CMP                 191C
CMPI                1808
CNVRT_ADDR          146A
CNVRT_DONE          1506
CR                  D
C_ALPHA_L           14FC
C_ALPHA_U           14F2
C_ERR1              1540
C_ERR2              1554
C_ERR3              1568
C_ERR4              157C
C_ERR_BASE1         1590
C_ERR_BASE2         15BE
C_INVALID           1536
C_IS_LC             14D4
C_LOOP              1494
C_NUMERIC           14E8
C_VALIDATE          1510
DATA                1996
DISP_INTRO          1016
DISP_WAIT           1024
DIVS                18F2
DSMBL_DONE          1086
END                 10DC
END_ADDR            1100
EOR                 1910
GA_LOOP             15EE
GET_ADDR            15E6
GET_SIZE_67         19B2
HEX_2_ASCII         1602
INPUT_ADDR          1430
JSR                 1892
JT_START            1626
LEA                 187C
LEFT                198A
LF                  A
LOGICSHIFT          1940
LONG                8
LOOP_COND           1066
MAIN_LOOP           1042
MOVE                181A
MOVEA               1826
MOVEM               1886
MOVEM_SIZE          19D4
MOVE_SIZE           19EE
MULS                1928
M_DONE              1424
M_ERR_ADDR1         133F
M_ERR_ADDR2         1362
M_ERR_ADDR3         13A4
M_ERR_ADDR4         13BD
M_ERR_GEN           1413
M_INPUT_E           12D0
M_INPUT_S           1290
M_INTRO             113C
M_INV_INPUT         130F
M_IN_RULES          11A0
M_NEWLINE           142C
M_NPROMPT           13D4
M_WAIT              12F4
NEG                 189C
NEXT_OP             104A
NOP                 1846
OP_ADDR             111E
OR                  18F8
ORI                 17FC
PREPARE_OP          15E0
PRINT_OP            1070
PROMPT_NEW          109C
RIGHT               1990
RIGHTORLEFT         1976
ROTATE              1964
RTS                 1862
SIZE_678            1A14
START               1000
START_ADDR          10E2
SUB                 1904
SUBQ                18A8
S_ADD               1A9B
S_ADDA              1A9F
S_AS                1B00
S_BCC               1AC9
S_BCLR              1AAD
S_BCS               1AC1
S_BGE               1ABD
S_BLT               1ACD
S_BRA               1AD1
S_BVC               1AC5
S_BYTE              1B0F
S_CMP               1A92
S_CMPI              1AA8
S_DATA              1B0A
S_DIVS              1AED
S_EOR               1A8E
S_JSR               1AF9
S_LEA               1AD9
S_LEFT              1B06
S_LONG              1B15
S_LS                1AFD
S_MOVE              1AB2
S_MOVEA             1AB7
S_MOVEM             1AE1
S_MULS              1A96
S_NEG               1ADD
S_NOP               1A8A
S_OR                1AF2
S_ORI               1AA4
S_RIGHT             1B08
S_RO                1B03
S_RTS               1AD5
S_SUB               1AF5
S_SUBQ              1AE7
S_WORD              1B12
WORD                4
