00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/9/2018 4:51:11 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Team Visual Basic's Disassembler
00000000                             3  * Written by :  Henry Hong, Dylan Desmond, Austin Abeyta
00000000                             4  * Date       :  ?
00000000                             5  * Description:  CSS422 Final Project
00000000                             6  *               Machine code to Motorola 68000 Assembly
00000000                             7  *               Main Driver File
00000000                             8  *-----------------------------------------------------------
00000000                             9      
00001000                            10  START       ORG         $1000               ;Start @ address $1000
00001000  4EB9 00001016             11              JSR         DISP_INTRO          ;Display Intro Message
00001006  4EB9 0000143A             12              JSR         INPUT_ADDR          ;Take start and ending address as user input
0000100C  4EB9 00001042             13              JSR         MAIN_LOOP           ;Meat of the program: Check for validity, OPCODE match, and print to screen
00001012                            14                                                          
00001012  6000 00CE                 15              BRA         END                 ;If loop improperly terminated, base case BRA to END program         
00001016                            16  *-Intro Message---------------------------------------------
00001016  43F9 00001142             17  DISP_INTRO  LEA         M_INTRO,A1          ;Load intro msg
0000101C  103C 000E                 18              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001020  4E4F                      19              TRAP        #15                     
00001022                            20      
00001022  4E75                      21              RTS                             ;Return to main START section
00001024                            22              
00001024                            23  *-Press Enter to Continue message---------------------------            
00001024  43F9 000012FA             24  DISP_WAIT   LEA         M_WAIT,A1           ;Load wait message
0000102A  103C 000E                 25              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000102E  4E4F                      26              TRAP        #15
00001030                            27              
00001030  103C 0005                 28              MOVE.B      #5,D0               ;Trap Task 5 takes in a single character input (aka press enter)
00001034  4E4F                      29              TRAP        #15
00001036                            30              
00001036  103C 000B                 31              MOVE.B      #11,D0              ;Clear screen
0000103A  323C FF00                 32              MOVE.W      #$FF00,D1
0000103E  4E4F                      33              TRAP        #15
00001040                            34  
00001040  4E75                      35              RTS        
00001042                            36              
00001042                            37  *-Main Loop-------------------------------------------------
00001042  4EB8 1024                 38  MAIN_LOOP   JSR         DISP_WAIT           ;Display Press Enter to Continue msg
00001046  183C 001A                 39              MOVE.B      #26,D4              ;D4 loop var - print 26 lines per page
0000104A                            40              
0000104A  4EB9 000015D6             41  NEXT_OP     JSR         BUILD_STR           ;Build and accumulate the 0xADDR OPCODE $OPERAND string into memory @ OP_ADDR                            
00001050  4EB9 00001070             42              JSR         PRINT_OP            ;Print the built string to console 
00001056                            43              
00001056  4EB9 00001066             44              JSR         LOOP_COND           ;Check if address is still valid. END program if it isnt
0000105C                            45    
0000105C  5344                      46              SUBI        #1,D4               ;Decrement counter
0000105E  B83C 0000                 47              CMP.B       #0,D4               ;Is counter == 0?
00001062  67DE                      48              BEQ         MAIN_LOOP           ;Then print the next page
00001064                            49              
00001064  60E4                      50              BRA         NEXT_OP             ;Otherwise, in the same page, print the next OP         
00001066                            51  
00001066                            52              
00001066                            53  *-Loop Condition Logic--------------------------------------
00001066  DBC7                      54  LOOP_COND   ADD.L       D7,A5            ;Increment current address (A5) by the length of the last instruction + operand data (D7)
00001068  BCCD                      55              CMPA.W      A5,A6            ;If current address (A5) is now equal to or greater than end address (A6), end
0000106A  6D00 001A                 56              BLT         DSMBL_DONE           ;<---------- check conditional
0000106E                            57              
0000106E  4E75                      58              RTS            
00001070                            59             
00001070                            60  *-Print OPCODE STRING---------------------------------------
00001070  327C 1124                 61  PRINT_OP    MOVE.W      #OP_ADDR,A1         ;Move the OPCODE's beginning addr to A1
00001074  103C 000E                 62              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001078  4E4F                      63              TRAP        #15
0000107A                            64              
0000107A  327C 1436                 65              MOVE.W      #M_NEWLINE,A1       ;Print a new line after this OPCODE line is finished
0000107E  103C 000E                 66              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001082  4E4F                      67              TRAP        #15
00001084                            68              
00001084  4E75                      69              RTS
00001086                            70              
00001086                            71  *-Print to user DONE message--------------------------------
00001086  43F9 0000142E             72  DSMBL_DONE  LEA         M_DONE,A1           ;Print DONE message
0000108C  103C 000E                 73              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001090  4E4F                      74              TRAP        #15 
00001092                            75              
00001092  4EB9 00001098             76              JSR         PROMPT_NEW          ;Ask user if they want to restart
00001098                            77              
00001098                            78  *-Ask user if they want to start program again--------------            
00001098  43F9 000013DC             79  PROMPT_NEW  LEA         M_NPROMPT,A1        ;Ask user if they would like to run program again
0000109E  103C 000E                 80              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000010A2  4E4F                      81              TRAP        #15                     
000010A4                            82              
000010A4  4281                      83              CLR.L       D1                  ;Clear D1
000010A6  103C 0005                 84              MOVE.B      #5,D0               ;Read user input into D1
000010AA  4E4F                      85              TRAP        #15
000010AC                            86              
000010AC  B23C 0079                 87              CMP.B       #'y',D1             ;Is input y
000010B0  6700 0028                 88              BEQ         P_RESTART           ;if so restart program
000010B4                            89              
000010B4  B23C 0059                 90              CMP.B       #'Y',D1             ;Is input Y capital
000010B8  6700 0020                 91              BEQ         P_RESTART           ;if so restart program
000010BC                            92              
000010BC                            93        
000010BC                            94  
000010BC  B23C 006E                 95              CMP.B       #'n',D1             ;Is input n
000010C0  6700 0020                 96              BEQ         END                 ;if so restart program
000010C4                            97              
000010C4  B23C 004E                 98              CMP.B       #'N',D1             ;Is input N capital
000010C8  6700 0018                 99              BEQ         END                 ;if so restart program
000010CC                           100              
000010CC  43F9 0000141B            101              LEA         M_ERR_GEN,A1        ;Input is invalid! Prompt again
000010D2  103C 000E                102              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000010D6  4E4F                     103              TRAP        #15 
000010D8                           104              
000010D8  60BE                     105              BRA         PROMPT_NEW          ;Re prompt            
000010DA                           106  
000010DA  4EB8 1024                107  P_RESTART   JSR         DISP_WAIT
000010DE  6000 FF20                108              BRA         START 
000010E2                           109  *-END-------------------------------------------------------
000010E2  103C 0009                110  END         MOVE.B      #9,D0               ;End program
000010E6  4E4F                     111              TRAP        #15                      
000010E8                           112              
000010E8                           113  *-Variables and constants-----------------------------------
000010E8  =0000000D                114  CR          EQU         $0D
000010E8  =0000000A                115  LF          EQU         $0A
000010E8                           116  
000010E8  =00000002                117  BYTE        EQU         $2
000010E8  =00000004                118  WORD        EQU         $4
000010E8  =00000008                119  LONG        EQU         $8
000010E8                           120  
000010E8                           121  START_ADDR  DS.B        30                  ;Machine code start address stored here
00001106                           122  END_ADDR    DS.B        30                  ;Machine code end address stored here
00001124                           123  
00001124                           124  OP_ADDR     DS.B        30                  ;Storage to accumulate OPCODE address, name, and data string at            
00001142                           125  
00001142                           126  
00001142                           127  *-Strings---------------------------------------------------
00001142= 54 65 61 6D 20 56 ...    128  M_INTRO     DC.B        'Team Visual Basic',CR,LF
00001155= 4D 6F 74 6F 72 6F ...    129              DC.B        'Motorola 68000 Disassembler',CR,LF
00001172= 42 79 20 41 75 73 ...    130              DC.B        'By Austin Abeyta, Dylan Desmond, and Henry Hong',CR,LF,CR,LF,0 
000011A6                           131  
000011A6= 50 6C 65 61 73 65 ...    132  M_IN_RULES  DC.B        'Please limit address input to numeric (0-9) and/or alphabet A-F',CR,LF
000011E7= 50 6C 65 61 73 65 ...    133              DC.B        'Please limit address input to a range of [00005000-FFFFFFFF]!',CR,LF
00001226= 49 6E 70 75 74 20 ...    134              DC.B        'Input less than 8 digits will be padded on left',CR,LF    
00001257= 49 6E 70 75 74 20 ...    135              DC.B        'Input greater than 8 digits will be truncated on the right',CR,LF,CR,LF,0
00001296                           136              
00001296= 50 6C 65 61 73 65 ...    137  M_INPUT_S   DC.B        'Please Input the Starting Address (test code is ORG @ 7F00): ',CR,LF,0
000012D6= 50 6C 65 61 73 65 ...    138  M_INPUT_E   DC.B        'Please Input the Ending Address: ',CR,LF,0
000012FA                           139  
000012FA= 0D 0A 50 72 65 73 ...    140  M_WAIT      DC.B        CR,LF,'Press Enter to Continue!',CR,LF,0
00001317                           141  
00001317= 49 6E 70 75 74 20 ...    142  M_INV_INPUT DC.B        'Input address is invalid! Please re-enter: ',CR,LF,CR,LF,0
00001347                           143  
00001347= 45 52 52 3A 20 53 ...    144  M_ERR_ADDR1 DC.B        'ERR: START address > END address',CR,LF,0
0000136A= 45 52 52 3A 20 53 ...    145  M_ERR_ADDR2 DC.B        'ERR: START address too low, danger of overwriting program logic',CR,LF,0
000013AC= 45 52 52 3A 20 4F ...    146  M_ERR_ADDR3 DC.B        'ERR: ODD START address',CR,LF,0
000013C5= 45 52 52 3A 20 4F ...    147  M_ERR_ADDR4 DC.B        'ERR: ODD END address',CR,LF,0
000013DC                           148  
000013DC= 57 6F 75 6C 64 20 ...    149  M_NPROMPT   DC.B        'Would you like to run program again @ another address? (y/n)',CR,LF,0
0000141B= 0D 0A 49 6E 76 61 ...    150  M_ERR_GEN   DC.B        CR,LF,'Invalid input!',CR,LF,0  
0000142E= 44 6F 6E 65 21 0D ...    151  M_DONE      DC.B        'Done!',CR,LF,0  
00001436                           152  
00001436= 0D 0A 00                 153  M_NEWLINE   DC.B        '',CR,LF,0
00001439                           154                      
00001439                           155              
00001439                           156  
00001439                           157  *-Files-----------------------------------------------------
00001439                           158              INCLUDE     'TeamVisualBasic_Disassembler_Input.X68'            ;Include Input class file
00001439                           159  
0000143A  43F8 11A6                160  INPUT_ADDR  LEA         M_IN_RULES,A1       ;Load input restriction and rules msg
0000143E  103C 000E                161              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001442  4E4F                     162              TRAP        #15                 
00001444                           163  
00001444  43F8 1296                164              LEA         M_INPUT_S,A1        ;Load input request msg
00001448  103C 000E                165              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000144C  4E4F                     166              TRAP        #15
0000144E                           167              
0000144E  43F8 10E8                168              LEA         START_ADDR,A1
00001452  103C 0002                169              MOVE.B      #2,D0               ;Read string from keyboard and store in (A1)
00001456  4E4F                     170              TRAP        #15          
00001458                           171              
00001458  43F8 12D6                172              LEA         M_INPUT_E,A1        ;Load input request msg
0000145C  103C 000E                173              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001460  4E4F                     174              TRAP        #15
00001462                           175              
00001462  43F8 1106                176              LEA         END_ADDR,A1
00001466  103C 0002                177              MOVE.B      #2,D0               ;Read string from keyboard and store in (A1)
0000146A  4E4F                     178              TRAP        #15
0000146C                           179              
0000146C  4EB9 00001474            180              JSR         CNVRT_ADDR          ;Convert user ASCII input into usable hex addresses
00001472                           181  
00001472  4E75                     182              RTS                             ;Return to main START section
00001474                           183  
00001474                           184  
00001474  43F8 10E8                185  CNVRT_ADDR  LEA         START_ADDR,A1       ;Load start address into A1
00001478  163C 0008                186              MOVE.B      #8,D3               ;Load counter var into D3. Count down from 8
0000147C  4EB9 0000149E            187              JSR         C_LOOP
00001482  2A42                     188              MOVE.L      D2,A5               ;Save converted input in (A5)
00001484                           189              
00001484  4282                     190              CLR.L       D2                  ;Clear accumulator
00001486  43F8 1106                191              LEA         END_ADDR,A1         ;Load end address into A1
0000148A  163C 0008                192              MOVE.B      #8,D3               ;Load counter var into D3. Count down from 8
0000148E  4EB9 0000149E            193              JSR         C_LOOP
00001494  2C42                     194              MOVE.L      D2,A6               ;Save converted input in (A6)
00001496                           195                  
00001496  4EB9 0000151A            196              JSR         C_VALIDATE          ;Make sure input is not ODD and end addr is not before start
0000149C  4E75                     197              RTS                             ;Finish by RTSing back to main dissasembler file
0000149E                           198   
0000149E  1019                     199  C_LOOP      MOVE.B      (A1)+,D0            ;Load the ascii digit into D0
000014A0  B03C 00FF                200              CMP.B       #$FF,D0             ;If value is $FF, there is no digit
000014A4  6700 009A                201              BEQ         C_INVALID
000014A8  B03C 0000                202              CMP.B       #$00,D0             ;If value is $00, then probably done
000014AC  6700 0062                203              BEQ         CNVRT_DONE              
000014B0                           204              
000014B0  B63C 0000                205              CMP.B       #0,D3               ;If counter var == 0
000014B4  6700 005A                206              BEQ         CNVRT_DONE
000014B8  5303                     207              SUBI.B      #1,D3               ;Else, decrement counter var
000014BA                           208              
000014BA                           209              ;Determine whether num, upper, or lower case ascii a-f                                    
000014BA  B03C 0030                210              CMP.B       #$30,D0             ;If <30, not a number
000014BE  6D00 0080                211              BLT         C_INVALID           
000014C2  B03C 0046                212              CMP.B       #$46,D0             ;If >46, it's possibly a lowercase letter 
000014C6  6E00 0016                213              BGT         C_IS_LC             ;Check if it's a valid lower ascii letter
000014CA                           214              
000014CA  B03C 0040                215              CMP.B       #$40,D0             ;If <40, must be number
000014CE  6D00 0022                216              BLT         C_NUMERIC
000014D2  B03C 0041                217              CMP.B       #$41,D0             ;If >41, must be upper case ascii
000014D6  6E00 0024                218              BGT         C_ALPHA_U
000014DA                           219  
000014DA  6000 0064                220              BRA         C_INVALID           ;If none of the above, the input is not valid 
000014DE                           221              
000014DE  B03C 0061                222  C_IS_LC     CMP.B       #$61,D0             ;If >61, input is invalid
000014E2  6D00 005C                223              BLT         C_INVALID
000014E6  B03C 0066                224              CMP.B       #$66,D0             ;If >66, input is invalid
000014EA  6E00 0054                225              BGT         C_INVALID
000014EE                           226              
000014EE  6000 0016                227              BRA         C_ALPHA_L           ;Else must be a valid lowercase input
000014F2                           228  
000014F2  0400 0030                229  C_NUMERIC   SUBI.B      #$30,D0             ;Subtract 0x30 to convert to hex
000014F6  E98A                     230              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
000014F8  D400                     231              ADD.B       D0,D2               ;Accumulate digits into D2
000014FA  60A2                     232              BRA         C_LOOP  
000014FC                           233  
000014FC                           234  
000014FC  0400 0037                235  C_ALPHA_U   SUBI.B      #$37,D0             ;Subtract 0x37 to convert to hex
00001500  E98A                     236              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
00001502  D400                     237              ADD.B       D0,D2               ;Accumulate digits into D2
00001504  6098                     238              BRA         C_LOOP
00001506                           239  
00001506  0400 0057                240  C_ALPHA_L   SUBI.B      #$57,D0             ;Subtract 0x57 to convert to hex
0000150A  E98A                     241              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
0000150C  D400                     242              ADD.B       D0,D2               ;Accumulate digits into D2
0000150E  608E                     243              BRA         C_LOOP
00001510                           244          
00001510                           245                         
00001510  B63C 0008                246  CNVRT_DONE  CMP.B       #8,D3               ;If no input, invalid
00001514  6700 002A                247              BEQ         C_INVALID           
00001518                           248              
00001518  4E75                     249              RTS                             ;Else, done
0000151A                           250              
0000151A                           251  
0000151A  BDCD                     252  C_VALIDATE  CMPA.L      A5,A6               ;If end address < start address     
0000151C  6D00 002C                253              BLT         C_ERR1
00001520                           254                                                
00001520  BBFC 00005000            255              CMPA.L      #$00005000,A5       ;If start address is <0x5000
00001526  6D00 0036                256              BLT         C_ERR2
0000152A                           257              
0000152A  200D                     258              MOVE.L      A5,D0               ;Check rightmost input address bit
0000152C  0800 0000                259              BTST        #0,D0               ;If rightmost (least sig) bit is 1 (aka ODD address)
00001530  6600 0040                260              BNE         C_ERR3           
00001534                           261              
00001534  200E                     262              MOVE.L      A6,D0               ;Check rightmost input address bit
00001536  0800 0000                263              BTST        #0,D0               ;If rightmost (least sig) bit is 1 (aka ODD address)
0000153A  6600 004A                264              BNE         C_ERR4
0000153E                           265              
0000153E  4E75                     266              RTS                             ;If none of the above, input is valid
00001540                           267              
00001540  4EB9 0000159A            268  C_INVALID   JSR         C_ERR_BASE1         ;Clear screen and clear registers
00001546  6000 0080                269              BRA         C_ERR_BASE2         ;Print generic error msg and branch to start
0000154A                           270  
0000154A  4EB9 0000159A            271  C_ERR1      JSR         C_ERR_BASE1         ;Clear screen and registers
00001550  43F8 1347                272              LEA         M_ERR_ADDR1,A1      ;Load error message
00001554  103C 000E                273              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001558  4E4F                     274              TRAP        #15
0000155A                           275              
0000155A  6000 006C                276              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
0000155E                           277  
0000155E  4EB9 0000159A            278  C_ERR2      JSR         C_ERR_BASE1         ;Clear screen and registers
00001564  43F8 136A                279              LEA         M_ERR_ADDR2,A1      ;Load error message
00001568  103C 000E                280              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000156C  4E4F                     281              TRAP        #15
0000156E                           282              
0000156E  6000 0058                283              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
00001572                           284  
00001572                           285  
00001572                           286              
00001572  4EB9 0000159A            287  C_ERR3      JSR         C_ERR_BASE1         ;Clear screen and registers
00001578  43F8 13AC                288              LEA         M_ERR_ADDR3,A1      ;Load error message
0000157C  103C 000E                289              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001580  4E4F                     290              TRAP        #15
00001582                           291              
00001582  6000 0044                292              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
00001586                           293  
00001586  4EB9 0000159A            294  C_ERR4      JSR         C_ERR_BASE1         ;Clear screen and registers
0000158C  43F8 13C5                295              LEA         M_ERR_ADDR4,A1      ;Load error message
00001590  103C 000E                296              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001594  4E4F                     297              TRAP        #15
00001596                           298              
00001596  6000 0030                299              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
0000159A                           300  
0000159A                           301  
0000159A  103C 000B                302  C_ERR_BASE1 MOVE.B      #11,D0              ;Clear screen
0000159E  323C FF00                303              MOVE.W      #$FF00,D1
000015A2  4E4F                     304              TRAP        #15
000015A4                           305              
000015A4  4282                     306              CLR.L       D2
000015A6  4285                     307              CLR.L       D5
000015A8  4286                     308              CLR.L       D6
000015AA                           309                                
000015AA                           310  
000015AA  21FC FFFFFFFF 10E8       311              MOVE.L      #$FFFFFFFF,(START_ADDR)        
000015B2  21FC FFFFFFFF 1106       312              MOVE.L      #$FFFFFFFF,(END_ADDR)
000015BA  2A7C 00000000            313              MOVEA.L     #$00000000,A5       ;Clear registers
000015C0  2C7C 00000000            314              MOVEA.L     #$00000000,A6 
000015C6                           315       
000015C6  4E75                     316              RTS
000015C8                           317  
000015C8  43F8 1317                318  C_ERR_BASE2 LEA         M_INV_INPUT,A1      ;Load error message
000015CC  103C 000E                319              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000015D0  4E4F                     320              TRAP        #15
000015D2                           321              
000015D2  6000 FA2C                322              BRA         START 
000015D6                           323             
000015D6                           324  
000015D6                           325  
000015D6                           326  -------------------- end include --------------------
000015D6                           327              INCLUDE     'TeamVisualBasic_Disassembler_OutputBuilder.X68'    ;Include OutputBuilder class file
000015D6                           328  
000015D6  4EB9 000015EE            329  BUILD_STR   JSR         PREPARE_OP          ;Define a location in memory to write an OPCODE string to
000015DC  4EB9 000015F4            330              JSR         GET_ADDR            ;Accumulate the OPCODE's address into the A4 string [0xADDR]
000015E2  4EB9 00001634            331              JSR         JT_START            ;Send OPCODE to jump table for decoding [OPCODE $OPERAND]
000015E8  18FC 0000                332              MOVE.B      #0,(A4)+            ;End the string with a 0 delimiter
000015EC                           333              
000015EC  4E75                     334              RTS                             ;Return back to main disassembler loop
000015EE                           335  
000015EE  387C 1124                336  PREPARE_OP  MOVE.W      #OP_ADDR,A4         ;Define a location in memory to write an OPCODE string to
000015F2  4E75                     337              RTS
000015F4                           338              
000015F4  200D                     339  GET_ADDR    MOVE.L      A5,D0               ;Save the address pointer into D0
000015F6  4282                     340              CLR.L       D2                  ;Clear D2
000015F8  143C 0008                341              MOVE.B      #8,D2               ;Counter var starts at 8
000015FC                           342              
000015FC  4EB9 00001610            343  GA_LOOP     JSR         HEX_2_ASCII         ;Convert the hex to ascii for printing
00001602  5342                     344              SUBI        #1,D2               ;Decrement counter var
00001604  B43C 0000                345              CMP.B       #0,D2               ;Is counter var == 0?
00001608  6EF2                     346              BGT         GA_LOOP             ;If not, loop         
0000160A                           347              
0000160A  18FC 0009                348              MOVE.B      #09,(A4)+           ;Otherwise, we are done. Append a tab
0000160E  4E75                     349              RTS                             ;Return back to main disassembler loop    
00001610                           350  
00001610  E998                     351  HEX_2_ASCII ROL.L       #4,D0               ;Get the most significant hex digit into the right 4 bits
00001612  1200                     352              MOVE.B      D0,D1               ;Save that byte into D1
00001614  0241 000F                353              ANDI        #$0F,D1             ;Isolate the hex digit 
00001618                           354              
00001618  B23C 0009                355              CMP.B       #$9,D1              ;If hex digit is > 9
0000161C  6E00 0006                356              BGT         APPND_ALPHA         ;It is an alphabet ascii char. Branch
00001620  6000 000A                357              BRA         APPND_NUM           ;Else it is a numeric ascii char. Branch
00001624                           358              
00001624  0601 0037                359  APPND_ALPHA ADDI.B      #$37,D1             ;Add $37 to make it a ascii alphabet char
00001628  18C1                     360              MOVE.B      D1,(A4)+            ;Append this character to string
0000162A  4E75                     361              RTS           
0000162C                           362  
0000162C  0601 0030                363  APPND_NUM   ADDI.B      #$30,D1             ;Add $30 to make it a ascii numeric char
00001630  18C1                     364              MOVE.B      D1,(A4)+            ;Append this character to string
00001632  4E75                     365              RTS
00001634                           366         
00001634                           367  
00001634                           368  
00001634                           369  
00001634                           370  -------------------- end include --------------------
00001634                           371              INCLUDE     'TeamVisualBasic_JumpTable.X68'                     ;Include Jump Table file
00001634                           372  
00001634  7E04                     373  JT_START    MOVE.L      #WORD,D7            *All OPCODEs takes up a WORD of space, save this into length counter D7
00001636  3015                     374              MOVE.W      (A5),D0             *Move OPCODE into D0 to bit shift
00001638                           375              
00001638  E848                     376              LSR.W       #4,D0               *Shift right 4 bits
0000163A  E848                     377              LSR.W       #4,D0               *shift right 4 bits
0000163C  E848                     378              LSR.W       #4,D0               *shift right 4 bits
0000163E                           379              
0000163E  0C40 0000                380              CMPI.W      #0,D0               *check if it falls into 0 bin
00001642  6700 007A                381              BEQ         BIN_0
00001646                           382      
00001646  0C40 0001                383              CMPI.W      #1,D0               *check if it is a MOVE
0000164A  6700 00A2                384              BEQ         BIN_MOVE
0000164E                           385              
0000164E  0C40 0002                386              CMPI.W      #2,D0               *check if it is a MOVE
00001652  6700 009A                387              BEQ         BIN_MOVE
00001656                           388              
00001656  0C40 0003                389              CMPI.W      #3,D0               *check if it is a MOVE
0000165A  6700 0092                390              BEQ         BIN_MOVE
0000165E                           391              
0000165E  0C40 0004                392              CMPI.W      #4,D0               *check if it falls into 4 bin
00001662  6700 00A6                393              BEQ         BIN_4
00001666                           394  
00001666  0C40 0005                395              CMPI.W      #5,D0               *check if it falls into 5 bin
0000166A  6700 00DC                396              BEQ         BIN_5
0000166E                           397  
0000166E  0C40 0006                398              CMPI.W      #6,D0               *check if it falls into 6 bin
00001672  6700 00D8                399              BEQ         BIN_6
00001676                           400  
00001676  0C40 0007                401              CMPI.W      #7,D0               *check if it falls into 7 bin
0000167A  6700 010A                402              BEQ         BIN_7
0000167E                           403  
0000167E  0C40 0008                404              CMPI.W      #8,D0               *check if it falls into 8 bin
00001682  6700 0106                405              BEQ         BIN_8
00001686                           406  
00001686  0C40 0009                407              CMPI.W      #9,D0               *check if it falls into 9 bin
0000168A  6700 0112                408              BEQ         BIN_9
0000168E                           409  
0000168E  0C40 000A                410              CMPI.W      #10,D0              *check if it falls into 10 bin
00001692  6700 010E                411              BEQ         BIN_10
00001696                           412  
00001696  0C40 000B                413              CMPI.W      #11,D0              *check if it falls into 11 bin
0000169A  6700 010A                414              BEQ         BIN_11
0000169E                           415  
0000169E  0C40 000C                416              CMPI.W      #12,D0              *check if it falls into 12 bin
000016A2  6700 0120                417              BEQ         BIN_12
000016A6                           418  
000016A6  0C40 000D                419              CMPI.W      #13,D0              *check if it falls into 12 bin
000016AA  6700 011C                420              BEQ         BIN_13
000016AE                           421  
000016AE  0C40 000E                422              CMPI.W      #14,D0              *check if it falls into 14 bin
000016B2  6700 0130                423              BEQ         BIN_14
000016B6                           424  
000016B6  0C40 000F                425              CMPI.W      #15,D0              *check if it falls into 15 bin
000016BA  6700 014C                426              BEQ         BIN_15
000016BE                           427  
000016BE  3015                     428  BIN_0       MOVE.W      (A5),D0             *reload opcode
000016C0  E048                     429              LSR.W       #8,D0               *shift bits to the right 8
000016C2  C07C 000F                430              AND.W       #$0F,D0             *Isolate the last 4 bits
000016C6                           431              
000016C6  0C40 000C                432              CMPI.W      #12,D0              *Check if the bit is C
000016CA  6700 0154                433              BEQ         CMPI                *if CMPI go to the subroutine
000016CE                           434              
000016CE  0C40 0000                435              CMPI.W      #0,D0               *Check if the bit is a 0
000016D2  6700 0138                436              BEQ         ORI                 *if ORI go to the subroutine
000016D6                           437              
000016D6  0C40 0008                438              CMPI.W      #8,D0               *Check if the bit is an 8
000016DA  6700 015C                439              BEQ         BCLR                *if BCLR immediate go to subroutine
000016DE                           440              
000016DE  C07C 0001                441              AND.W       #$01,D0             *isolate the last bit
000016E2  0C40 0001                442              CMPI.W      #1,D0               *Check if the bit is a 1
000016E6  6700 0150                443              BEQ         BCLR                *if BCLR register go to subroutine
000016EA                           444              
000016EA  6000 0374                445              BRA         DATA           
000016EE                           446  
000016EE  3015                     447  BIN_MOVE    MOVE.W      (A5),D0             *reload opcode
000016F0  EC48                     448              LSR.W       #6,D0               *shift bits to the right 6
000016F2  C07C 0007                449              AND.W       #$07,D0             *isolate the last 3 bits
000016F6  0C40 0001                450              CMPI.W      #1,D0               *check if the bits are 001
000016FA  6700 0166                451              BEQ         MOVEA               *if MOVEA go to SUB
000016FE                           452              
000016FE  0C40 0007                453              CMPI.W      #7,D0               *check if the bits are 111
00001702  6700 035C                454              BEQ         DATA                *if 111 must be DATA
00001706  6000 0142                455              BRA         MOVE                *otherwise must be MOVE
0000170A                           456              
0000170A  3015                     457  BIN_4       MOVE.W      (A5),D0             *reload opcode
0000170C  0C40 4E71                458              CMPI.W      #$4E71,D0           *check for no-op value
00001710  6700 0180                459              BEQ         NOP                 *if NOP go to SUB
00001714                           460              
00001714  0C40 4E75                461              CMPI.W      #$4E75,D0           *Compare with a constant value for RTS      
00001718  6700 0188                462              BEQ         RTS                 *if RTS go to RTS subroutine
0000171C                           463              
0000171C  E848                     464              LSR.W       #4,D0               *shift right 4 bits
0000171E  E848                     465              LSR.W       #4,D0               *shift right 4 bits
00001720  C07C 000F                466              AND.W       #$0F,D0             *bitmask first 4 bits  
00001724  0C40 000E                467              CMPI.W      #$E,D0              *compare final masked bits
00001728  6700 01B0                468              BEQ         JSR                 *if it equals E it is JSR
0000172C                           469              
0000172C  0C40 0004                470              CMPI.W      #$4,D0              *check for defining bits
00001730  6700 01B6                471              BEQ         NEG                 *branch to NEG routine
00001734                           472              
00001734  C07C 0001                473              AND.W       #$1,D0
00001738  0C40 0001                474              CMPI.W      #1,D0
0000173C  6700 0172                475              BEQ         LEA
00001740                           476              
00001740  0C40 0000                477              CMPI.W      #0,D0
00001744  6700 0178                478              BEQ         MOVEM
00001748                           479              
00001748  6000 01B2                480  BIN_5       BRA         SUBQ                *SUBQ is the only option for this bin so branch to SUB
0000174C                           481  
0000174C  3015                     482  BIN_6       MOVE.W      (A5),D0             *reload fresh op code
0000174E  E848                     483              LSR.W       #4,D0               *shift right 4
00001750  E848                     484              LSR.W       #4,D0               *shift right 4
00001752  C07C 000F                485              AND.W       #$0F,D0             *Finds the condition code of the branch statement through bitmask
00001756                           486              
00001756  0C40 0000                487              CMPI.W      #0,D0               *check if the 4 bits == 0000
0000175A  6700 01FE                488              BEQ         BRA_SUB             *branch to BRA SUB
0000175E                           489              
0000175E  0C40 0004                490              CMPI.W      #4,D0
00001762  6700 01DA                491              BEQ         BCC                 *branch to BCC code 
00001766                           492                                                                       
00001766  0C40 000D                493              CMPI.W      #$D,D0
0000176A  6700 01E0                494              BEQ         BLT                 *branch to BLT SUB            
0000176E                           495                                                                   
0000176E  0C40 0008                496              CMPI.W      #8,D0
00001772  6700 01BC                497              BEQ         BVC                 *branch to BVC code
00001776                           498              
00001776  0C40 0005                499              CMPI.W      #5,D0
0000177A  6700 01A6                500              BEQ         BCS                 *branch to BCS code
0000177E                           501              
0000177E  0C40 000C                502              CMPI.W      #$C,D0
00001782  6700 0190                503              BEQ         BGE                 *branch to BGE code
00001786                           504  
00001786  6000 02D8                505  BIN_7       BRA        DATA                *If it goes into this bin it is DATA
0000178A                           506  
0000178A  3015                     507  BIN_8       MOVE.W      (A5),D0
0000178C  EC48                     508              LSR.W       #6,D0
0000178E  C07C 0007                509              AND.W       #$07,D0   
00001792  0C40 0007                510              CMPI.W      #7,D0
00001796  6700 01D0                511              BEQ         DIVS
0000179A                           512              
0000179A  6000 01DE                513              BRA         OR  
0000179E                           514              
0000179E  6000 01EA                515  BIN_9       BRA         SUB                 *SUB is the only option for this bin so branch to SUB
000017A2                           516  
000017A2  6000 02BC                517  BIN_10      BRA         DATA                *If it goes into this bin it is DATA
000017A6                           518  
000017A6  3015                     519  BIN_11      MOVE.W      (A5),D0             *reload opcode into D0
000017A8  E848                     520              LSR.W       #4,D0               *shift bits to the right 4
000017AA  E848                     521              LSR.W       #4,D0               *Shift bits to the right 4
000017AC  C07C 0001                522              AND.W       #$01,D0             *isolate the last bit
000017B0  0C40 0001                523              CMPI.W      #1,D0               *check if the bit is a 1
000017B4  6700 01E8                524              BEQ         EOR                 *if EOR go to the SUB
000017B8                           525              
000017B8  0C40 0000                526              CMPI.W      #0,D0               *check if the bit is a 0
000017BC  6700 01F4                527              BEQ         CMP                 *if CMP go to the SUB
000017C0                           528              
000017C0  6000 029E                529              BRA         DATA                *if neither EOR or CMP must be DATA
000017C4                           530              
000017C4  6000 0200                531  BIN_12      BRA         MULS                *MULS is the only option for this bin so branch to SUB
000017C8                           532  
000017C8  3015                     533  BIN_13      MOVE.W      (A5),D0             *reload opcode into D0
000017CA  EC48                     534              LSR.W       #6,D0               *shift bits to the right 6
000017CC  C07C 0007                535              AND.W       #$07,D0             *isolate the last 3 bits
000017D0  0C40 0003                536              CMPI.W      #$3,D0              *check if the bits are 011
000017D4  6700 0216                537              BEQ         ADDA                *if ADDA go to SUB        
000017D8                           538              
000017D8  0C40 0007                539              CMPI.W      #$7,D0              *check if the bits are 111
000017DC  6700 020E                540              BEQ         ADDA                *if ADDA go to SUB 
000017E0                           541                                                          
000017E0  6000 01F6                542              BRA         ADD                 *if bits are not ADDA must be ADD and go to SUB
000017E4                           543              
000017E4  3015                     544  BIN_14      MOVE.W      (A5),D0             *Reload the opcode
000017E6  E648                     545              LSR.W       #3,D0               *shift bits down
000017E8  C07C 0007                546              AND.W       #$07,D0             *mask bits
000017EC  B07C 0001                547              CMP.W       #1,D0               *determin which kind of shift it is
000017F0  6700 020C                548              BEQ         LOGICSHIFT          *bra to logic shift
000017F4                           549              
000017F4  B07C 0000                550              CMP.W       #0,D0
000017F8  6700 021A                551              BEQ         ARITH_SHIFT         *bra to arthimetic shift
000017FC                           552              
000017FC  B07C 0003                553              CMP.W       #3,D0
00001800  6700 0228                554              BEQ         ROTATE              *bra to rotate      
00001804                           555              
00001804  6000 025A                556              BRA         DATA                *if not a shift must be DATA 
00001808                           557                                                                  
00001808                           558  
00001808  6000 0256                559  BIN_15      BRA        DATA                *IF it goes into this bin it is DATA
0000180C                           560                                                                                               
0000180C                           561  
0000180C                           562  
0000180C  18FC 004F                563  ORI         MOVE.B      #'O',(A4)+          *Load OPCODE string into (A4)
00001810  18FC 0052                564              MOVE.B      #'R',(A4)+
00001814  18FC 0049                565              MOVE.B      #'I',(A4)+
00001818                           566              
00001818  4EB9 00001AE6            567              JSR         GET_SIZE_67
0000181E                           568           
0000181E  4E75                     569              RTS                             *Return to OutputBuilder file
00001820                           570              
00001820  18FC 0043                571  CMPI        MOVE.B      #'C',(A4)+          *Load OPCODE string into (A4)
00001824  18FC 004D                572              MOVE.B      #'M',(A4)+
00001828  18FC 0050                573              MOVE.B      #'P',(A4)+
0000182C  18FC 0049                574              MOVE.B      #'I',(A4)+
00001830                           575              
00001830  4EB9 00001AE6            576              JSR         GET_SIZE_67 
00001836                           577     
00001836  4E75                     578              RTS                             *Return to OutputBuilder file
00001838                           579              
00001838  18FC 0042                580  BCLR        MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
0000183C  18FC 0043                581              MOVE.B      #'C',(A4)+
00001840  18FC 004C                582              MOVE.B      #'L',(A4)+
00001844  18FC 0052                583              MOVE.B      #'R',(A4)+
00001848                           584              
00001848  4E75                     585              RTS                             *Return to OutputBuilder file
0000184A                           586  
0000184A  18FC 0042                587  MOVE        MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
0000184E  18FC 0043                588              MOVE.B      #'C',(A4)+
00001852  18FC 004C                589              MOVE.B      #'L',(A4)+
00001856  18FC 0052                590              MOVE.B      #'R',(A4)+
0000185A                           591              
0000185A  4EB9 00001B26            592              JSR         MOVE_SIZE           *Append size
00001860                           593  
00001860  4E75                     594              RTS                             *Return to OutputBuilder file
00001862                           595             
00001862                           596              
00001862  18FC 004D                597  MOVEA       MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
00001866  18FC 004F                598              MOVE.B      #'O',(A4)+
0000186A  18FC 0056                599              MOVE.B      #'V',(A4)+
0000186E  18FC 0045                600              MOVE.B      #'E',(A4)+
00001872  18FC 0041                601              MOVE.B      #'A',(A4)+
00001876                           602              
00001876  3015                     603              MOVE.W      (A5),D0             *reload OPCODE into D0
00001878  E848                     604              LSR.W       #4,D0               *Isolate leftmost hex digit
0000187A  E848                     605              LSR.W       #4,D0
0000187C  E848                     606              LSR.W       #4,D0               *shift bits a total of 12 right
0000187E  C07C 0003                607              AND.W       #$03,D0             *isolate the last 2 bits
00001882                           608              
00001882  0C40 0001                609              CMPI.W      #1,D0               *If == 1, invalid OPCODE
00001886  6700 01D8                610              BEQ         DATA                *Operation not supported for MOVEA
0000188A                           611              
0000188A  4EB9 00001B26            612              JSR         MOVE_SIZE           *Append size
00001890                           613              
00001890  4E75                     614              RTS                             *Return to OutputBuilder file
00001892                           615  
00001892  5447                     616  NOP         ADDI        #BYTE,D7            *NOP is 2 Bytes; Increment length var by 2
00001894  18FC 004E                617              MOVE.B      #'N',(A4)+          *Load OPCODE string into (A4)
00001898  18FC 004F                618              MOVE.B      #'O',(A4)+
0000189C  18FC 0050                619              MOVE.B      #'P',(A4)+
000018A0                           620              
000018A0  4E75                     621              RTS                             *Return to OutputBuilder file
000018A2                           622              
000018A2                           623              
000018A2  18FC 0052                624  RTS         MOVE.B      #'R',(A4)+          *Load OPCODE string into (A4)
000018A6  18FC 0054                625              MOVE.B      #'T',(A4)+
000018AA  18FC 0053                626              MOVE.B      #'S',(A4)+ 
000018AE                           627  
000018AE  4E75                     628              RTS                             *Return to OutputBuilder file
000018B0                           629              
000018B0  18FC 004C                630  LEA         MOVE.B      #'L',(A4)+          *Load OPCODE string into (A4)
000018B4  18FC 0045                631              MOVE.B      #'E',(A4)+
000018B8  18FC 0041                632              MOVE.B      #'A',(A4)+   
000018BC                           633          
000018BC  4E75                     634              RTS                             *Return to OutputBuilder file
000018BE                           635              
000018BE  18FC 004D                636  MOVEM       MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
000018C2  18FC 004F                637              MOVE.B      #'O',(A4)+
000018C6  18FC 0056                638              MOVE.B      #'V',(A4)+   
000018CA  18FC 0045                639              MOVE.B      #'E',(A4)+
000018CE  18FC 004D                640              MOVE.B      #'M',(A4)+
000018D2                           641  
000018D2  4EB9 00001B0A            642              JSR         MOVEM_SIZE          *Append size
000018D8                           643              
000018D8  4E75                     644              RTS                             *Return to OutputBuilder file
000018DA                           645              
000018DA  18FC 004A                646  JSR         MOVE.B      #'J',(A4)+          *Load OPCODE string into (A4)
000018DE  18FC 0053                647              MOVE.B      #'S',(A4)+
000018E2  18FC 0052                648              MOVE.B      #'R',(A4)+   
000018E6                           649          
000018E6                           650  
000018E6  4E75                     651              RTS                             *Return to OutputBuilder file
000018E8                           652              
000018E8  18FC 004E                653  NEG         MOVE.B      #'N',(A4)+          *Load OPCODE string into (A4)
000018EC  18FC 0045                654              MOVE.B      #'E',(A4)+
000018F0  18FC 0047                655              MOVE.B      #'G',(A4)+   
000018F4                           656          
000018F4  4EB9 00001AE6            657              JSR         GET_SIZE_67         *Append size
000018FA                           658              
000018FA  4E75                     659              RTS                             *Return to OutputBuilder file
000018FC                           660               
000018FC                           661              
000018FC  18FC 0053                662  SUBQ        MOVE.B      #'S',(A4)+          *Load OPCODE string into (A4)
00001900  18FC 0055                663              MOVE.B      #'U',(A4)+
00001904  18FC 0042                664              MOVE.B      #'B',(A4)+   
00001908  18FC 0051                665              MOVE.B      #'Q',(A4)+ 
0000190C                           666                                         
0000190C  4EB9 00001AE6            667              JSR         GET_SIZE_67         *Append size
00001912                           668              
00001912  4E75                     669              RTS                             *Return to OutputBuilder file
00001914                           670             
00001914  18FC 0042                671  BGE         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001918  18FC 0047                672              MOVE.B      #'G',(A4)+
0000191C  18FC 0045                673              MOVE.B      #'E',(A4)+   
00001920                           674          
00001920  4E75                     675              RTS                             *Return to OutputBuilder file
00001922                           676              
00001922  18FC 0042                677  BCS         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001926  18FC 0043                678              MOVE.B      #'C',(A4)+
0000192A  18FC 0053                679              MOVE.B      #'S',(A4)+   
0000192E                           680          
0000192E  4E75                     681              RTS                             *Return to OutputBuilder file
00001930                           682              
00001930  18FC 0042                683  BVC         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001934  18FC 0056                684              MOVE.B      #'V',(A4)+
00001938  18FC 0043                685              MOVE.B      #'C',(A4)+   
0000193C                           686          
0000193C  4E75                     687              RTS                             *Return to OutputBuilder file
0000193E                           688              
0000193E  18FC 0042                689  BCC         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001942  18FC 0043                690              MOVE.B      #'C',(A4)+
00001946  18FC 0043                691              MOVE.B      #'C',(A4)+   
0000194A                           692          
0000194A  4E75                     693              RTS                             *Return to OutputBuilder file
0000194C                           694              
0000194C  18FC 0042                695  BLT         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001950  18FC 004C                696              MOVE.B      #'L',(A4)+
00001954  18FC 0054                697              MOVE.B      #'T',(A4)+   
00001958                           698          
00001958  4E75                     699              RTS                             *Return to OutputBuilder file
0000195A                           700  
0000195A  18FC 0042                701  BRA_SUB     MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
0000195E  18FC 0052                702              MOVE.B      #'R',(A4)+
00001962  18FC 0041                703              MOVE.B      #'A',(A4)+   
00001966                           704          
00001966  4E75                     705              RTS                             *Return to OutputBuilder file
00001968                           706              
00001968  18FC 0044                707  DIVS        MOVE.B      #'D',(A4)+          *Load OPCODE string into (A4)
0000196C  18FC 0049                708              MOVE.B      #'I',(A4)+
00001970  18FC 0056                709              MOVE.B      #'V',(A4)+   
00001974  18FC 0053                710              MOVE.B      #'S',(A4)+
00001978                           711          
00001978  4E75                     712              RTS                             *Return to OutputBuilder file
0000197A                           713              
0000197A  18FC 004F                714  OR          MOVE.B      #'O',(A4)+          *Load OPCODE string into (A4)
0000197E  18FC 0052                715              MOVE.B      #'R',(A4)+
00001982                           716             
00001982  4EB9 00001B4E            717              JSR         SIZE_678            *Append size
00001988                           718              
00001988  4E75                     719              RTS                             *Return to OutputBuilder file
0000198A                           720              
0000198A  18FC 0053                721  SUB         MOVE.B      #'S',(A4)+          *Load OPCODE string into (A4)
0000198E  18FC 0055                722              MOVE.B      #'U',(A4)+
00001992  18FC 0042                723              MOVE.B      #'B',(A4)+   
00001996                           724  
00001996  4EB9 00001B4E            725              JSR         SIZE_678            *Append size
0000199C                           726              
0000199C  4E75                     727              RTS                             *Return to OutputBuilder file
0000199E                           728              
0000199E  18FC 0045                729  EOR         MOVE.B      #'E',(A4)+          *Load OPCODE string into (A4)
000019A2  18FC 004F                730              MOVE.B      #'O',(A4)+
000019A6  18FC 0052                731              MOVE.B      #'R',(A4)+   
000019AA                           732  
000019AA  4EB9 00001AE6            733              JSR         GET_SIZE_67         *Append size
000019B0                           734              
000019B0  4E75                     735              RTS                             *Return to OutputBuilder file
000019B2                           736  
000019B2  18FC 0043                737  CMP         MOVE.B      #'C',(A4)+          *Load OPCODE string into (A4)
000019B6  18FC 004D                738              MOVE.B      #'M',(A4)+
000019BA  18FC 0050                739              MOVE.B      #'P',(A4)+   
000019BE                           740  
000019BE  4EB9 00001AE6            741              JSR         GET_SIZE_67         *Append size
000019C4  4E75                     742              RTS                             *Return to OutputBuilder file
000019C6                           743  
000019C6  18FC 004D                744  MULS        MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
000019CA  18FC 0055                745              MOVE.B      #'U',(A4)+
000019CE  18FC 004C                746              MOVE.B      #'L',(A4)+   
000019D2  18FC 0053                747              MOVE.B      #'S',(A4)+
000019D6                           748              
000019D6  4E75                     749              RTS                             *Return to OutputBuilder file
000019D8                           750              
000019D8  18FC 0041                751  ADD         MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
000019DC  18FC 0044                752              MOVE.B      #'D',(A4)+
000019E0  18FC 0044                753              MOVE.B      #'D',(A4)+   
000019E4                           754              
000019E4  4EB9 00001B4E            755              JSR         SIZE_678            *Append size
000019EA  4E75                     756              RTS                             *Return to OutputBuilder file
000019EC                           757              
000019EC                           758  
000019EC                           759  
000019EC  18FC 0041                760  ADDA        MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
000019F0  18FC 0044                761              MOVE.B      #'D',(A4)+
000019F4  18FC 0044                762              MOVE.B      #'D',(A4)+
000019F8  18FC 0041                763              MOVE.B      #'A',(A4)+   
000019FC                           764                  
000019FC  4E75                     765              RTS                             *Return to OutputBuilder file
000019FE                           766       
000019FE  18FC 004C                767  LOGICSHIFT  MOVE.B      #'L',(A4)+          *Load OPCODE string into (A4)
00001A02  18FC 0053                768              MOVE.B      #'S',(A4)+
00001A06                           769                     
00001A06  4EB9 00001A40            770              JSR         RIGHTORLEFT         *Append (L/R)
00001A0C  4EB9 00001AE6            771              JSR         GET_SIZE_67         *Append Size
00001A12                           772              
00001A12  4E75                     773              RTS                             *Return to OutputBuilder file           
00001A14                           774  
00001A14  18FC 0041                775  ARITH_SHIFT MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
00001A18  18FC 0053                776              MOVE.B      #'S',(A4)+
00001A1C                           777              
00001A1C  4EB9 00001A40            778              JSR         RIGHTORLEFT         *Append (L/R)
00001A22  4EB9 00001AE6            779              JSR         GET_SIZE_67         *Append Size
00001A28                           780  
00001A28  4E75                     781              RTS         
00001A2A                           782                  
00001A2A  18FC 0052                783  ROTATE      MOVE.B      #'R',(A4)+          *Load OPCODE string into (A4)
00001A2E  18FC 004F                784              MOVE.B      #'O',(A4)+
00001A32                           785            
00001A32  4EB9 00001A40            786              JSR         RIGHTORLEFT         *Append (L/R)
00001A38  4EB9 00001AE6            787              JSR         GET_SIZE_67         *Append Size
00001A3E                           788              
00001A3E  4E75                     789              RTS
00001A40                           790                
00001A40  3010                     791  RIGHTORLEFT MOVE.W      (A0),D0             *reload op
00001A42  E148                     792              LSL.W       #8,D0               *shift until dr bit is reached
00001A44  B07C 0000                793              CMP.W       #0,D0               *check if left
00001A48  6700 000A                794              BEQ         LEFT
00001A4C                           795              
00001A4C  B07C 0001                796              CMP.W       #1,D0               *check if right
00001A50  6700 0008                797              BEQ         RIGHT  
00001A54                           798                                                
00001A54  38FC 004C                799  LEFT        MOVE.W      #'L',(A4)+          *Load directional string 'L' into (A4)
00001A58  4E75                     800              RTS                      
00001A5A                           801                       
00001A5A  38FC 0052                802  RIGHT       MOVE.W      #'R',(A4)+          *Load directional string 'R' into (A4)
00001A5E  4E75                     803              RTS
00001A60                           804                                    
00001A60  18FC 0044                805  DATA        MOVE.B      #'D',(A4)+          *Write DATA into string
00001A64  18FC 0041                806              MOVE.B      #'A',(A4)+          
00001A68  18FC 0054                807              MOVE.B      #'T',(A4)+          
00001A6C  18FC 0041                808              MOVE.B      #'A',(A4)+         
00001A70  18FC 0009                809              MOVE.B      #09,(A4)+           *Write a tab into string
00001A74                           810              
00001A74  1E3C 0004                811              MOVE.B      #WORD,D7            *Increment the size counter D7 by a WORD 
00001A78  4EB9 00001A90            812              JSR         WRITE_DATA          *Write D7 worth of OPCODE data that couldn't be decoded
00001A7E                           813                                    
00001A7E  4E75                     814              RTS                             *Return program flow back to Dissasembler file
00001A80                           815              
00001A80  5507                     816  P_OPERAND   SUBI.B      #2,D7               *Subtract 2 from D7 size counter to account for and skip OPCODE's data 
00001A82  544D                     817              ADDA        #2,A5               *Increment current address pointer to skip over OPCODE
00001A84  4EB9 00001A90            818              JSR         WRITE_DATA          *WRITE_DATA writes everything after the OPCODE to (A4)
00001A8A                           819              
00001A8A  5407                     820              ADDI.B      #2,D7               *Add the 2 back to D7 size counter
00001A8C  554D                     821              SUBA        #2,A5               *Decrement current address point to point to the start of opcode again
00001A8E                           822              
00001A8E  4E75                     823              RTS
00001A90                           824              
00001A90  2607                     825  WRITE_DATA  MOVE.L      D7,D3               *D3 is counter var. Same size as the length specified in D7
00001A92  0C03 0000                826  WRITE_LOOP  CMPI.B      #0,D3               *is D3 == 0?
00001A96  6700 004A                827              BEQ         WRITE_DONE          *then we are done writing the string 
00001A9A                           828              
00001A9A  5543                     829              SUBI        #BYTE,D3            *Decrement counter var by 1 byte                       
00001A9C                           830  
00001A9C  1415                     831              MOVE.B      (A5),D2             *Move 1 byte of OPCODE/OPERAND data into D2                   
00001A9E  E84A                     832              LSR.W       #4,D2               *Isolate left 4 bits of first byte in D1             
00001AA0  4EB9 00001AB6            833              JSR         WRITE_DIGIT         *Save the left 4 bits in the byte as an ascii char
00001AA6                           834          
00001AA6  1415                     835              MOVE.B      (A5),D2             *Move 1 byte of OPCODE/OPERAND data into D2   
00001AA8  0202 000F                836              ANDI.B      #$0F,D2             *Isolate right 4 of the first byte in D2                                     
00001AAC  4EB9 00001AB6            837              JSR         WRITE_DIGIT         *Save the right 4 bits in the byte as an ascii char
00001AB2                           838              
00001AB2  524D                     839              ADDA        #1,A5               *Increment A5
00001AB4                           840              
00001AB4  60DC                     841              BRA         WRITE_LOOP          *Go to start of loop, and write the next bytes worth of digits          
00001AB6                           842                     
00001AB6  B43C 0009                843  WRITE_DIGIT CMP.B       #$09,D2             *Is D2 alphabet or number?
00001ABA  6E00 0006                844              BGT         W_ALPHA             *If D2 > #$09, it's alphabet
00001ABE  6000 000A                845              BRA         W_NUM               *Else its numeric             
00001AC2                           846              
00001AC2  4EB9 00001AD2            847  W_ALPHA     JSR         CNVRT_ALPHA         *Convert the half byte to ascii, and write to string
00001AC8  4E75                     848              RTS                             *Go back to write_loop
00001ACA                           849  
00001ACA  4EB9 00001AD2            850  W_NUM       JSR         CNVRT_ALPHA         *Convert the half byte to ascii, and write to string
00001AD0  4E75                     851              RTS                             *Go back to write_loop           
00001AD2                           852              
00001AD2  0602 0037                853  CNVRT_ALPHA ADDI.B      #$37,D2             *Convert to ASCII
00001AD6  18C2                     854              MOVE.B      D2,(A4)+            *Write to string
00001AD8  4E75                     855              RTS
00001ADA                           856  
00001ADA  0602 0030                857  CNVRT_NUM   ADDI.B      #$30,D2             *Convert to ASCII
00001ADE  18C2                     858              MOVE.B      D2,(A4)+            *Write to string
00001AE0  4E75                     859              RTS           
00001AE2                           860              
00001AE2  9AC7                     861  WRITE_DONE  SUB.W       D7,A5               *Bring A5 pointer back to where it was before writing the DATA
00001AE4  4E75                     862              RTS                             *Finished writing       
00001AE6                           863  
00001AE6                           864  
00001AE6  3015                     865  GET_SIZE_67 MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001AE8  EC48                     866              LSR.W       #6,D0               *shift bits right 6
00001AEA  C07C 0003                867              AND.W       #$03,D0             *Isolate last 2 bits
00001AEE  0C40 0000                868              CMPI.W      #0,D0
00001AF2  6700 00B2                869              BEQ         APPND_BYTE          *Is a Byte operation
00001AF6  0C40 0001                870              CMPI.W      #1,D0
00001AFA  6700 00B2                871              BEQ         APPND_WORD          *Is a Word operation
00001AFE  0C40 0002                872              CMPI.W      #2,D0
00001B02  6700 00B2                873              BEQ         APPND_LONG          *Is a Long operation
00001B06  6000 FF58                874              BRA         DATA                *Not a valid size must be data 
00001B0A                           875  
00001B0A  3015                     876  MOVEM_SIZE  MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001B0C  EC48                     877              LSR.W       #6,D0               *shift bits right 6
00001B0E  C07C 0001                878              AND.W       #$01,D0             *isolate last bit
00001B12  0C40 0000                879              CMPI.W      #0,D0
00001B16  6700 0096                880              BEQ         APPND_WORD          *is a word operation
00001B1A  0C40 0001                881              CMPI.W      #1,D0
00001B1E  6700 0096                882              BEQ         APPND_LONG          *is a long operation
00001B22  6000 FF3C                883              BRA         DATA
00001B26                           884              
00001B26  3015                     885  MOVE_SIZE   MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001B28  E848                     886              LSR.W       #4,D0               *shift bits right 4
00001B2A  E848                     887              LSR.W       #4,D0
00001B2C  E848                     888              LSR.W       #4,D0               *shift bits a total of 12 right
00001B2E  C07C 0003                889              AND.W       #$03,D0             *isolate the last 2 bits
00001B32  0C40 0001                890              CMPI.W      #1,D0               
00001B36  6700 006E                891              BEQ         APPND_BYTE          *is a byte operation
00001B3A  0C40 0003                892              CMPI.W      #3,D0               
00001B3E  6700 006E                893              BEQ         APPND_WORD          *is a word operation
00001B42  0C40 0002                894              CMPI.W      #2,D0               
00001B46  6700 006E                895              BEQ         APPND_LONG          *is a long operation
00001B4A  6000 FF14                896              BRA         DATA
00001B4E                           897              
00001B4E  3015                     898  SIZE_678    MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001B50  EC48                     899              LSR.W       #6,D0               *shift the bits right 6
00001B52  C07C 0007                900              AND.W       #$07,D0             *isolate the last 3 bits
00001B56  0C40 0000                901              CMPI.W      #0,D0               
00001B5A  6700 004A                902              BEQ         APPND_BYTE          *is a byte operation
00001B5E  0C40 0004                903              CMPI.W      #4,D0
00001B62  6700 0042                904              BEQ         APPND_BYTE          *is a byte operation
00001B66  0C40 0001                905              CMPI.W      #1,D0               
00001B6A  6700 0042                906              BEQ         APPND_WORD          *is a word operation
00001B6E  0C40 0005                907              CMPI.W      #5,D0               
00001B72  6700 003A                908              BEQ         APPND_WORD          *is a word operation
00001B76  0C40 0002                909              CMPI.W      #2,D0
00001B7A  6700 003A                910              BEQ         APPND_LONG          *is a long operation
00001B7E  0C40 0006                911              CMPI.W      #6,D0
00001B82  6700 0032                912              BEQ         APPND_LONG          *is a long operation
00001B86  6000 FED8                913              BRA         DATA                *is not one of the supported sizes
00001B8A                           914              
00001B8A  3015                     915  ADDA_SIZE   MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001B8C  EC48                     916              LSR.W       #6,D0               *shift the bits right 6
00001B8E  C07C 0007                917              AND.W       #$07,D0             *isolate the last 3 bits
00001B92  0C40 0003                918              CMPI.W      #3,D0
00001B96  6700 0016                919              BEQ         APPND_WORD          *is a word operation
00001B9A  0C40 0007                920              CMPI.W      #7,D0
00001B9E  6700 0016                921              BEQ         APPND_LONG          *is a long operation
00001BA2  6000 FEBC                922              BRA         DATA                *is not one of the supported sizes
00001BA6                           923  
00001BA6  38FC 0042                924  APPND_BYTE  MOVE.W      #'B',(A4)+          *load size into (A4)
00001BAA  5447                     925              ADDI.W      #2,D7               *add OPCODE length to D7
00001BAC  4E75                     926              RTS
00001BAE                           927  
00001BAE  38FC 0057                928  APPND_WORD  MOVE.W      #'W',(A4)+          *load size into (A4)
00001BB2  5847                     929              ADDI.W      #4,D7               *add OPCODE length to D7
00001BB4  4E75                     930              RTS
00001BB6                           931  
00001BB6  38FC 004C                932  APPND_LONG  MOVE.W      #'L',(A4)+          *load size into (A4)
00001BBA  5047                     933              ADDI.W      #8,D7               *add OPCODE length to D7
00001BBC  4E75                     934              RTS                
00001BBE                           935              
00001BBE                           936              INCLUDE     'TeamVisualBasic_OP_Decoder.X68'    ;Helper file for jump table
00001BBE                           937  
00001BBE                           938  
00001BBE                           939  
00001BBE  3415                     940  DECODE_A    MOVE.W      (A5),D2             *Copy OPCODE into D2
00001BC0  E64A                     941              LSR.W       #3,D2               *Shift right 3 - isolate Src Mode
00001BC2  C47C 0007                942              AND.W       #$0007,D2           *Mask out other bits
00001BC6  4EB9 00001C8E            943              JSR         GET_SRCMODE         *Append SRC string to (A4)          
00001BCC  18FC 002C                944              MOVE.B      #',',(A4)+
00001BD0                           945              
00001BD0  3415                     946              MOVE.W      (A5),D2             *Recopy OPCODE into D2  
00001BD2  EC4A                     947              LSR.W       #6,D2               *Shift right 6 - isolate Dest Mode
00001BD4  C47C 0007                948              AND.W       #$0007,D2           *Mask out other bits
00001BD8  4EB9 00001CC6            949              JSR         GET_DSTMODE         *Append DST string to (A4)
00001BDE                           950              
00001BDE  4E75                     951              RTS                             *Return back to jump table
00001BE0                           952  
00001BE0                           953                 
00001BE0  3415                     954  DECODE_B    MOVE.W      (A5),D2
00001BE2  EC4A                     955              LSR.W       #6,D2
00001BE4  C478 0003                956              AND.W       $0003,D2
00001BE8  B47C 0003                957              CMP.W       #3,D2
00001BEC  6700 002E                958              BEQ         B_ADDMODE
00001BF0  3415                     959              MOVE.W      (A5),D2             
00001BF2  EA4A                     960              LSR.W       #5,D2
00001BF4  C47C 0003                961              AND.W       #$0003,D2
00001BF8  B47C 0001                962              CMP.W       #1,D2
00001BFC  6700 003C                963              BEQ         B_SCOUNT
00001C00  B47C 0002                964              CMP.W       #2,D2
00001C04  6700 004C                965              BEQ         B_DATAREG
00001C08  18FC 0044                966              MOVE.B      #'D',(A4)+
00001C0C  3415                     967              MOVE.W      (A5),D2
00001C0E  C47C 0007                968              AND.W       #$0007,D2
00001C12  3A02                     969              MOVE.W      D2,D5
00001C14  4EB9 00001E0A            970              JSR         PrintD5Num
00001C1A  4E75                     971              RTS
00001C1C                           972  
00001C1C                           973  B_ADDMODE
00001C1C  3415                     974             MOVE.W       (A5),D2
00001C1E  E64A                     975             LSR.W        #3,D2
00001C20  C47C 0007                976             AND.W        #$0007,D2
00001C24  4EB9 00001CC6            977             JSR          GET_DSTMODE
00001C2A  3415                     978             MOVE.W       (A5),D2
00001C2C  C47C 0007                979             AND.W        #$0007,D2
00001C30  3A02                     980             MOVE.W       D2,D5
00001C32  4EB9 00001E0A            981             JSR          PrintD5Num
00001C38  4E75                     982             RTS
00001C3A                           983              
00001C3A                           984              
00001C3A                           985  
00001C3A  3415                     986  B_SCOUNT    MOVE.W      (A5),D2
00001C3C  EC4A                     987              LSR.W       #6,D2
00001C3E  E64A                     988              LSR.W       #3,D2
00001C40  C47C 0007                989              AND.W       #$0007,D2
00001C44  3A02                     990              MOVE.W      D2,D5
00001C46  18FC 0023                991              MOVE.B      #'#',(A4)+
00001C4A  4EB9 00001E0A            992              JSR         PrintD5Num
00001C50  4E75                     993              RTS
00001C52                           994     
00001C52  18FC 0044                995  B_DATAREG   MOVE.B      #'D',(A4)+
00001C56  3415                     996              MOVE.W      (A5),D2
00001C58  EC4A                     997              LSR.W       #6,D2
00001C5A  E64A                     998              LSR.W       #3,D2
00001C5C  C47C 0007                999              AND.W       #$0007,D2
00001C60  3A02                    1000              MOVE.W      D2,D5
00001C62  4EB9 00001E0A           1001              JSR         PrintD5Num
00001C68  4E75                    1002              RTS
00001C6A                          1003         
00001C6A                          1004  
00001C6A                          1005  
00001C6A                          1006    
00001C6A  3415                    1007  DECODE_C    MOVE.W      (A5),D2
00001C6C                          1008              *ENTER PRINT DATA CODE HERE
00001C6C  4EB9 00001C72           1009              JSR         C_SRC
00001C72                          1010              
00001C72                          1011  
00001C72                          1012  
00001C72                          1013  
00001C72  3415                    1014  C_SRC       MOVE.W      (A5),D2
00001C74  E64A                    1015              LSR.W       #3,D2
00001C76  C47C 0007               1016              AND.W       #$0007,D2
00001C7A  4EB9 00001CC6           1017              JSR         GET_DSTMODE
00001C80  3415                    1018              MOVE.W      (A5),D2
00001C82  C47C 0007               1019              AND.W       #$0007,D2
00001C86  4EB9 00001C8E           1020              JSR         GET_SRCMODE
00001C8C  4E75                    1021              RTS
00001C8E                          1022  
00001C8E                          1023  
00001C8E                          1024     
00001C8E                          1025  DECODE_D
00001C8E                          1026  
00001C8E                          1027  
00001C8E                          1028    
00001C8E                          1029  DECODE_E
00001C8E                          1030  
00001C8E                          1031  
00001C8E                          1032    
00001C8E                          1033  DECODE_F
00001C8E                          1034  
00001C8E                          1035  
00001C8E                          1036     
00001C8E                          1037  
00001C8E                          1038  
00001C8E  B47C 0000               1039  GET_SRCMODE CMP.W       #0,D2
00001C92  6700 006A               1040              BEQ         SregMode        *register mode: Dn
00001C96  B47C 0001               1041              CMP.W       #1,D2
00001C9A  6700 0074               1042              BEQ         SaddMode        *address mode ---An
00001C9E  B47C 0002               1043              CMP.W       #2,D2
00001CA2  6700 007E               1044              BEQ         SaddINmode      *addres indirect mode ---(An)
00001CA6  B47C 0003               1045              CMP.W       #3,D2
00001CAA  6700 0090               1046              BEQ         SaddINpre       *addess indirect pre dec ----(An)
00001CAE  B47C 0004               1047              CMP.W       #4,D2
00001CB2  6700 00A6               1048              BEQ         SaddINpost      *address indirect post inc --- (An)+
00001CB6  B47C 0005               1049              CMP.W       #5,D2
00001CBA  6700 00BC               1050              BEQ         S16An           *source number of word size --- (d16,An)
00001CBE  B47C 0006               1051              CMP.W       #6,D2
00001CC2  6700 00B4               1052              BEQ         S8AnXn          *source number byte size --- (d8,An,Xn)
00001CC6                          1053      
00001CC6                          1054  
00001CC6  B47C 0000               1055  GET_DSTMODE CMP.W       #0,D2
00001CCA  6700 00AC               1056              BEQ         DregMode        *register mode ---Dn
00001CCE  B47C 0001               1057              CMP.W       #1,D2
00001CD2  6700 00B6               1058              BEQ         DaddMode        *address mode ---An
00001CD6  B47C 0002               1059              CMP.W       #2,D2
00001CDA  6700 00C0               1060              BEQ         DaddINmode      *addres indirect mode ---(An)
00001CDE  B47C 0003               1061              CMP.W       #3,D2
00001CE2  6700 00D2               1062              BEQ         DaddINpre       *addess indirect pre dec ----(An)
00001CE6  B47C 0004               1063              CMP.W       #4,D2
00001CEA  6700 00E8               1064              BEQ         DaddINpost      *address indirect post inc --- (An)+
00001CEE  B47C 0005               1065              CMP.W       #5,D2
00001CF2  6700 00FE               1066              BEQ         D16An           *source number of word size --- (d16,An)
00001CF6  B47C 0006               1067              CMP.W       #6,D2
00001CFA  6700 00F6               1068              BEQ         D8AnXn          *source number byte size --- (d8,An,Xn)
00001CFE                          1069      
00001CFE                          1070   
00001CFE  18FC 0044               1071  SregMode    MOVE.B      #'D',(A4)+
00001D02  4EB9 00001DF2           1072              JSR         T1_GrabSreg
00001D08  4EB9 00001E0A           1073              JSR         PrintD5Num   
00001D0E  4E75                    1074              RTS  
00001D10                          1075          
00001D10  18FC 0041               1076  SaddMode    MOVE.B      #'A',(A4)+
00001D14  4EB9 00001DF2           1077              JSR         T1_GrabSreg
00001D1A  4EB9 00001E0A           1078              JSR         PrintD5Num
00001D20  4E75                    1079              RTS
00001D22                          1080      
00001D22                          1081      
00001D22                          1082      
00001D22  18FC 0028               1083  SaddInMode  MOVE.B      #'(',(A4)+
00001D26  18FC 0041               1084              MOVE.B      #'A',(A4)+
00001D2A  4EB9 00001DF2           1085              JSR         T1_GrabSreg
00001D30  4EB9 00001E0A           1086              JSR         PrintD5Num
00001D36  18FC 0029               1087              MOVE.B      #')',(A4)+
00001D3A  4E75                    1088              RTS
00001D3C                          1089      
00001D3C  18FC 002D               1090  SaddINpre   MOVE.B      #'-',(A4)+
00001D40  18FC 0028               1091              MOVE.B      #'(',(A4)+
00001D44  18FC 0041               1092              MOVE.B      #'A',(A4)+
00001D48  4EB9 00001DF2           1093              JSR         T1_GrabSreg
00001D4E  4EB9 00001E0A           1094              JSR         PrintD5Num
00001D54  18FC 0029               1095              MOVE.B      #')',(A4)+
00001D58  4E75                    1096              RTS
00001D5A                          1097      
00001D5A  18FC 0028               1098  SaddINpost  MOVE.B      #'(',(A4)+
00001D5E  18FC 0041               1099              MOVE.B      #'A',(A4)+
00001D62  4EB9 00001DF2           1100              JSR         T1_GrabSreg
00001D68  4EB9 00001E0A           1101              JSR         PrintD5Num
00001D6E  18FC 0029               1102              MOVE.B      #')',(A4)+
00001D72  18FC 002B               1103              MOVE.B      #'+',(A4)+
00001D76  4E75                    1104              RTS
00001D78                          1105      
00001D78                          1106  S16An
00001D78                          1107  S8AnXn
00001D78                          1108  
00001D78                          1109  
00001D78  18FC 0044               1110  DregMode    MOVE.B      #'D',(A4)+
00001D7C  4EB9 00001DFC           1111              JSR         T1_GrabDreg
00001D82  4EB9 00001E0A           1112              JSR         PrintD5Num   
00001D88  4E75                    1113              RTS
00001D8A                          1114           
00001D8A  18FC 0041               1115  DaddMode    MOVE.B      #'A',(A4)+
00001D8E  4EB9 00001DFC           1116              JSR         T1_GrabDreg
00001D94  4EB9 00001E0A           1117              JSR         PrintD5Num
00001D9A  4E75                    1118              RTS
00001D9C                          1119      
00001D9C                          1120      
00001D9C                          1121      
00001D9C  18FC 0028               1122  DaddInMode  MOVE.B      #'(',(A4)+
00001DA0  18FC 0041               1123              MOVE.B      #'A',(A4)+
00001DA4  4EB9 00001DFC           1124              JSR         T1_GrabDreg
00001DAA  4EB9 00001E0A           1125              JSR         PrintD5Num
00001DB0  18FC 0029               1126              MOVE.B      #')',(A4)+
00001DB4  4E75                    1127              RTS
00001DB6                          1128      
00001DB6  18FC 002D               1129  DaddINpre   MOVE.B      #'-',(A4)+
00001DBA  18FC 0028               1130              MOVE.B      #'(',(A4)+
00001DBE  18FC 0041               1131              MOVE.B      #'A',(A4)+
00001DC2  4EB9 00001DFC           1132              JSR         T1_GrabDreg
00001DC8  4EB9 00001E0A           1133              JSR         PrintD5Num
00001DCE  18FC 0029               1134              MOVE.B      #')',(A4)+
00001DD2  4E75                    1135              RTS
00001DD4                          1136      
00001DD4  18FC 0028               1137  DaddINpost  MOVE.B      #'(',(A4)+
00001DD8  18FC 0041               1138              MOVE.B      #'A',(A4)+
00001DDC  4EB9 00001DFC           1139              JSR         T1_GrabDreg
00001DE2  4EB9 00001E0A           1140              JSR         PrintD5Num
00001DE8  18FC 0029               1141              MOVE.B      #')',(A4)+
00001DEC  18FC 002B               1142              MOVE.B      #'+',(A4)+
00001DF0  4E75                    1143              RTS
00001DF2                          1144      
00001DF2                          1145  D16An
00001DF2                          1146  D8AnXn
00001DF2                          1147  
00001DF2                          1148      
00001DF2  3415                    1149  T1_GrabSreg MOVE.W      (A5),D2         *recopy op code
00001DF4  C47C 0007               1150              AND.W       #$0007,D2       *mask other bits
00001DF8  3A02                    1151              MOVE.W      D2,D5           *copy D2 to D5
00001DFA  4E75                    1152              RTS
00001DFC                          1153      
00001DFC  3415                    1154  T1_GrabDreg MOVE.W      (A5),D2         *type one grab register bits
00001DFE  EC4A                    1155              LSR.W       #6,D2           *shift bits over
00001E00  E64A                    1156              LSR.W       #3,D2           
00001E02  C47C 0007               1157              AND.W       #$0007,D2       *mask so only relevent bits left
00001E06  3A02                    1158              MOVE.W      D2,D5           *move to d5 for printing
00001E08  4E75                    1159              RTS
00001E0A                          1160      
00001E0A  BA3C 0000               1161  PrintD5Num  CMP.B       #0,D5           *print the numeber in d5
00001E0E  6700 0042               1162              BEQ         PRINT0
00001E12  BA3C 0001               1163              CMP.B       #1,D5
00001E16  6700 0040               1164              BEQ         PRINT1
00001E1A  BA3C 0002               1165              CMP.B       #2,D5
00001E1E  6700 003E               1166              BEQ         PRINT2
00001E22  BA3C 0003               1167              CMP.B       #3,D5
00001E26  6700 003C               1168              BEQ         PRINT3
00001E2A  BA3C 0004               1169              CMP.B       #4,D5
00001E2E  6700 003A               1170              BEQ         PRINT4
00001E32  BA3C 0005               1171              CMP.B       #5,D5
00001E36  6700 0038               1172              BEQ         PRINT5
00001E3A  BA3C 0006               1173              CMP.B       #6,D5
00001E3E  6700 0036               1174              BEQ         PRINT6
00001E42  BA3C 0007               1175              CMP.B       #7,D5
00001E46  6700 0034               1176              BEQ         PRINT7
00001E4A  BA3C 0008               1177              CMP.B       #8,D5
00001E4E  6700 0032               1178              BEQ         PRINT8  
00001E52                          1179      
00001E52                          1180      
00001E52  18FC 0030               1181  PRINT0      MOVE.B      #'0',(A4)+
00001E56  4E75                    1182              RTS
00001E58                          1183      
00001E58  18FC 0031               1184  PRINT1      MOVE.B      #'1',(A4)+
00001E5C  4E75                    1185              RTS
00001E5E                          1186      
00001E5E  18FC 0032               1187  PRINT2      MOVE.B      #'2',(A4)+
00001E62  4E75                    1188              RTS
00001E64                          1189      
00001E64  18FC 0033               1190  PRINT3      MOVE.B      #'3',(A4)+
00001E68  4E75                    1191              RTS
00001E6A                          1192      
00001E6A  18FC 0034               1193  PRINT4      MOVE.B      #'4',(A4)+
00001E6E  4E75                    1194              RTS
00001E70                          1195      
00001E70  18FC 0035               1196  PRINT5      MOVE.B      #'5',(A4)+
00001E74  4E75                    1197              RTS
00001E76                          1198  
00001E76  18FC 0036               1199  PRINT6      MOVE.B      #'6',(A4)+
00001E7A  4E75                    1200              RTS
00001E7C                          1201      
00001E7C  18FC 0037               1202  PRINT7      MOVE.B      #'7',(A4)+
00001E80  4E75                    1203              RTS  
00001E82                          1204         
00001E82  18FC 0038               1205  PRINT8      MOVE.B      #'8',(A4)+
00001E86  4E75                    1206              RTS
00001E88                          1207      
00001E88                          1208  
00001E88                          1209  
00001E88                          1210  
00001E88                          1211  
00001E88                          1212  
00001E88                          1213  -------------------- end include --------------------
00001E88                          1214              
00001E88                          1215  
00001E88                          1216  
00001E88                          1217  
00001E88                          1218  
00001E88                          1219  
00001E88                          1220  
00001E88                          1221  
00001E88                          1222  
00001E88                          1223  
00001E88                          1224  
00001E88                          1225  
00001E88                          1226  
00001E88                          1227  
00001E88                          1228  -------------------- end include --------------------
00001E88                          1229              
00001E88                          1230              END         START               ;last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 19D8
ADDA                19EC
ADDA_SIZE           1B8A
APPND_ALPHA         1624
APPND_BYTE          1BA6
APPND_LONG          1BB6
APPND_NUM           162C
APPND_WORD          1BAE
ARITH_SHIFT         1A14
BCC                 193E
BCLR                1838
BCS                 1922
BGE                 1914
BIN_0               16BE
BIN_10              17A2
BIN_11              17A6
BIN_12              17C4
BIN_13              17C8
BIN_14              17E4
BIN_15              1808
BIN_4               170A
BIN_5               1748
BIN_6               174C
BIN_7               1786
BIN_8               178A
BIN_9               179E
BIN_MOVE            16EE
BLT                 194C
BRA_SUB             195A
BUILD_STR           15D6
BVC                 1930
BYTE                2
B_ADDMODE           1C1C
B_DATAREG           1C52
B_SCOUNT            1C3A
CMP                 19B2
CMPI                1820
CNVRT_ADDR          1474
CNVRT_ALPHA         1AD2
CNVRT_DONE          1510
CNVRT_NUM           1ADA
CR                  D
C_ALPHA_L           1506
C_ALPHA_U           14FC
C_ERR1              154A
C_ERR2              155E
C_ERR3              1572
C_ERR4              1586
C_ERR_BASE1         159A
C_ERR_BASE2         15C8
C_INVALID           1540
C_IS_LC             14DE
C_LOOP              149E
C_NUMERIC           14F2
C_SRC               1C72
C_VALIDATE          151A
D16AN               1DF2
D8ANXN              1DF2
DADDINMODE          1D9C
DADDINPOST          1DD4
DADDINPRE           1DB6
DADDMODE            1D8A
DATA                1A60
DECODE_A            1BBE
DECODE_B            1BE0
DECODE_C            1C6A
DECODE_D            1C8E
DECODE_E            1C8E
DECODE_F            1C8E
DISP_INTRO          1016
DISP_WAIT           1024
DIVS                1968
DREGMODE            1D78
DSMBL_DONE          1086
END                 10E2
END_ADDR            1106
EOR                 199E
GA_LOOP             15FC
GET_ADDR            15F4
GET_DSTMODE         1CC6
GET_SIZE_67         1AE6
GET_SRCMODE         1C8E
HEX_2_ASCII         1610
INPUT_ADDR          143A
JSR                 18DA
JT_START            1634
LEA                 18B0
LEFT                1A54
LF                  A
LOGICSHIFT          19FE
LONG                8
LOOP_COND           1066
MAIN_LOOP           1042
MOVE                184A
MOVEA               1862
MOVEM               18BE
MOVEM_SIZE          1B0A
MOVE_SIZE           1B26
MULS                19C6
M_DONE              142E
M_ERR_ADDR1         1347
M_ERR_ADDR2         136A
M_ERR_ADDR3         13AC
M_ERR_ADDR4         13C5
M_ERR_GEN           141B
M_INPUT_E           12D6
M_INPUT_S           1296
M_INTRO             1142
M_INV_INPUT         1317
M_IN_RULES          11A6
M_NEWLINE           1436
M_NPROMPT           13DC
M_WAIT              12FA
NEG                 18E8
NEXT_OP             104A
NOP                 1892
OP_ADDR             1124
OR                  197A
ORI                 180C
PREPARE_OP          15EE
PRINT0              1E52
PRINT1              1E58
PRINT2              1E5E
PRINT3              1E64
PRINT4              1E6A
PRINT5              1E70
PRINT6              1E76
PRINT7              1E7C
PRINT8              1E82
PRINTD5NUM          1E0A
PRINT_OP            1070
PROMPT_NEW          1098
P_OPERAND           1A80
P_RESTART           10DA
RIGHT               1A5A
RIGHTORLEFT         1A40
ROTATE              1A2A
RTS                 18A2
S16AN               1D78
S8ANXN              1D78
SADDINMODE          1D22
SADDINPOST          1D5A
SADDINPRE           1D3C
SADDMODE            1D10
SIZE_678            1B4E
SREGMODE            1CFE
START               1000
START_ADDR          10E8
SUB                 198A
SUBQ                18FC
T1_GRABDREG         1DFC
T1_GRABSREG         1DF2
WORD                4
WRITE_DATA          1A90
WRITE_DIGIT         1AB6
WRITE_DONE          1AE2
WRITE_LOOP          1A92
W_ALPHA             1AC2
W_NUM               1ACA
