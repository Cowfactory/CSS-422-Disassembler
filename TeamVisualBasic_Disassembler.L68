00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/6/2018 8:22:30 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Team Visual Basic's Disassembler
00000000                             3  * Written by :  Henry Hong, Dylan Desmond, Austin Abeyta
00000000                             4  * Date       :  ?
00000000                             5  * Description:  CSS422 Final Project
00000000                             6  *               Machine code to Motorola 68000 Assembly
00000000                             7  *               Main Driver File
00000000                             8  *-----------------------------------------------------------
00000000                             9      
00001000                            10  START       ORG         $1000               ;Start @ address $1000             
00001000  4EB9 0000101C             11              JSR         DISP_INTRO          ;Display Intro Message
00001006  4EB9 00001384             12              JSR         INPUT_ADDR          ;Take start and ending address as user input
0000100C  4EB9 0000102A             13              JSR         DISP_WAIT           ;Display Press Enter to Continue msg
00001012  4EB9 00001048             14              JSR         MAIN_LOOP           ;Meat of the program: Check for validity, OPCODE match, and print to screen
00001018                            15                                                          
00001018  6000 0066                 16              BRA         END                 ;If loop improperly terminated, base case BRA to END program         
0000101C                            17  *-Intro Message---------------------------------------------
0000101C  43F9 000010E0             18  DISP_INTRO  LEA         M_INTRO,A1          ;Load intro msg
00001022  103C 000E                 19              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001026  4E4F                      20              TRAP        #15                     
00001028                            21      
00001028  4E75                      22              RTS                             ;Return to main START section
0000102A                            23              
0000102A                            24  *-Press Enter to Continue message---------------------------            
0000102A  43F9 000012A1             25  DISP_WAIT   LEA         M_WAIT,A1           ;Load wait message
00001030  103C 000E                 26              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001034  4E4F                      27              TRAP        #15
00001036                            28              
00001036  103C 0005                 29              MOVE.B      #5,D0               ;Trap Task 5 takes in a single character input (aka press enter)
0000103A  4E4F                      30              TRAP        #15
0000103C                            31              
0000103C  103C 000B                 32              MOVE.B      #11,D0              ;Clear screen
00001040  323C FF00                 33              MOVE.W      #$FF00,D1
00001044  4E4F                      34              TRAP        #15
00001046                            35  
00001046  4E75                      36              RTS        
00001048                            37              
00001048                            38  *-Main Loop-------------------------------------------------
00001048  4EB9 00001520             39  MAIN_LOOP   JSR         BUILD_STR           ;Build and accumulate the 0xADDR OPCODE $OPERAND string into memory @ OP_ADDR                            
0000104E  4EB9 0000106A             40              JSR         PRINT_OP            ;Print the built string to console           
00001054  4EB9 0000105C             41              JSR         LOOP_COND
0000105A                            42              
0000105A                            43              
0000105A                            44              
0000105A  60EC                      45              BRA         MAIN_LOOP
0000105C                            46              
0000105C                            47              
0000105C                            48  *-Loop Condition Logic--------------------------------------
0000105C  DBFC 00000004             49  LOOP_COND   ADD.L       #WORD,A5            ;Increment current address (A5)
00001062  BCCD                      50              CMP.W       A5,A6               ;If current address (A5) is now equal to end address (A6), end
00001064  6700 001A                 51              BEQ         END
00001068                            52              
00001068  4E75                      53              RTS
0000106A                            54  *-Print a Page worth of OPCODES-----------------------------
0000106A                            55             
0000106A                            56  *-Print OPCODE STRING---------------------------------------
0000106A  327C 10C2                 57  PRINT_OP    MOVE.W      #OP_ADDR,A1         ;Move the OPCODE's beginning addr to A1
0000106E  103C 000E                 58              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001072  4E4F                      59              TRAP        #15
00001074                            60              
00001074  327C 1381                 61              MOVE.W      #M_NEWLINE,A1       ;Print a new line after this OPCODE line is finished
00001078  103C 000E                 62              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000107C  4E4F                      63              TRAP        #15
0000107E                            64              
0000107E  4E75                      65              RTS
00001080                            66              
00001080                            67      
00001080                            68  *-END-------------------------------------------------------
00001080  103C 0009                 69  END         MOVE.B      #9,D0               ;End program
00001084  4E4F                      70              TRAP        #15                      
00001086                            71              
00001086                            72  *-Variables and constants-----------------------------------
00001086  =0000000D                 73  CR          EQU         $0D
00001086  =0000000A                 74  LF          EQU         $0A
00001086                            75  
00001086  =00000002                 76  BYTE        EQU         $2
00001086  =00000004                 77  WORD        EQU         $4
00001086  =00000008                 78  LONG        EQU         $8
00001086                            79  
00001086                            80  START_ADDR  DS.B        30                  ;Machine code start address stored here
000010A4                            81  END_ADDR    DS.B        30                  ;Machine code end address stored here
000010C2                            82  
000010C2                            83  OP_ADDR     DS.B        30                  ;Storage to accumulate OPCODE address, name, and data string at            
000010E0                            84  
000010E0                            85  
000010E0                            86  *-Strings---------------------------------------------------
000010E0= 54 65 61 6D 20 56 ...     87  M_INTRO     DC.B        'Team Visual Basic',CR,LF
000010F3= 4D 6F 74 6F 72 6F ...     88              DC.B        'Motorola 68000 Disassembler',CR,LF
00001110= 42 79 20 41 75 73 ...     89              DC.B        'By Austin Abeyta, Dylan Desmond, and Henry Hong',CR,LF,CR,LF,0 
00001144                            90  
00001144= 50 6C 65 61 73 65 ...     91  M_IN_RULES  DC.B        'Please limit address input to numeric (0-9) and/or ALL CAPS alphabet A-F',CR,LF
0000118E= 50 6C 65 61 73 65 ...     92              DC.B        'Please limit address input to a range of [00005000-FFFFFFFF]!',CR,LF
000011CD= 49 6E 70 75 74 20 ...     93              DC.B        'Input less than 8 digits will be padded on left',CR,LF    
000011FE= 49 6E 70 75 74 20 ...     94              DC.B        'Input greater than 8 digits will be truncated on the right',CR,LF,CR,LF,0
0000123D                            95              
0000123D= 50 6C 65 61 73 65 ...     96  M_INPUT_S   DC.B        'Please Input the Starting Address (test code is ORG @ 7F00): ',CR,LF,0
0000127D= 50 6C 65 61 73 65 ...     97  M_INPUT_E   DC.B        'Please Input the Ending Address: ',CR,LF,0
000012A1                            98  
000012A1= 50 72 65 73 73 20 ...     99  M_WAIT      DC.B        'Press Enter to Continue!',CR,LF,0
000012BC                           100  
000012BC= 49 6E 70 75 74 20 ...    101  M_INV_INPUT DC.B        'Input address is invalid! Please re-enter: ',CR,LF,CR,LF,0
000012EC                           102  
000012EC= 45 52 52 3A 20 53 ...    103  M_ERR_ADDR1 DC.B        'ERR: START address > END address',CR,LF,0
0000130F= 45 52 52 3A 20 53 ...    104  M_ERR_ADDR2 DC.B        'ERR: START address too low, danger of overwriting program logic',CR,LF,0
00001351= 45 52 52 3A 20 4F ...    105  M_ERR_ADDR3 DC.B        'ERR: ODD START address',CR,LF,0
0000136A= 45 52 52 3A 20 4F ...    106  M_ERR_ADDR4 DC.B        'ERR: ODD END address',CR,LF,0
00001381                           107  
00001381= 0D 0A 00                 108  M_NEWLINE   DC.B        '',CR,LF,0
00001384                           109                      
00001384                           110              
00001384                           111  
00001384                           112  *-Files-----------------------------------------------------
00001384                           113              INCLUDE     'TeamVisualBasic_Disassembler_Input.X68'            ;Include Input class file
00001384                           114  
00001384  43F8 1144                115  INPUT_ADDR  LEA         M_IN_RULES,A1       ;Load input restriction and rules msg
00001388  103C 000E                116              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000138C  4E4F                     117              TRAP        #15                 
0000138E                           118  
0000138E  43F8 123D                119              LEA         M_INPUT_S,A1        ;Load input request msg
00001392  103C 000E                120              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001396  4E4F                     121              TRAP        #15
00001398                           122              
00001398  43F8 1086                123              LEA         START_ADDR,A1
0000139C  103C 0002                124              MOVE.B      #2,D0               ;Read string from keyboard and store in (A1)
000013A0  4E4F                     125              TRAP        #15          
000013A2                           126              
000013A2  43F8 127D                127              LEA         M_INPUT_E,A1        ;Load input request msg
000013A6  103C 000E                128              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000013AA  4E4F                     129              TRAP        #15
000013AC                           130              
000013AC  43F8 10A4                131              LEA         END_ADDR,A1
000013B0  103C 0002                132              MOVE.B      #2,D0               ;Read string from keyboard and store in (A1)
000013B4  4E4F                     133              TRAP        #15
000013B6                           134              
000013B6  4EB9 000013BE            135              JSR         CNVRT_ADDR          ;Convert user ASCII input into usable hex addresses
000013BC                           136  
000013BC  4E75                     137              RTS                             ;Return to main START section
000013BE                           138  
000013BE                           139  
000013BE  43F8 1086                140  CNVRT_ADDR  LEA         START_ADDR,A1       ;Load start address into A1
000013C2  163C 0008                141              MOVE.B      #8,D3               ;Load counter var into D3. Count down from 8
000013C6  4EB9 000013E8            142              JSR         C_LOOP
000013CC  2A42                     143              MOVE.L      D2,A5               ;Save converted input in (A5)
000013CE                           144              
000013CE  4282                     145              CLR.L       D2                  ;Clear accumulator
000013D0  43F8 10A4                146              LEA         END_ADDR,A1         ;Load end address into A1
000013D4  163C 0008                147              MOVE.B      #8,D3               ;Load counter var into D3. Count down from 8
000013D8  4EB9 000013E8            148              JSR         C_LOOP
000013DE  2C42                     149              MOVE.L      D2,A6               ;Save converted input in (A6)
000013E0                           150                  
000013E0  4EB9 00001464            151              JSR         C_VALIDATE          ;Make sure input is not ODD and end addr is not before start
000013E6  4E75                     152              RTS                             ;Finish by RTSing back to main dissasembler file
000013E8                           153   
000013E8  1019                     154  C_LOOP      MOVE.B      (A1)+,D0            ;Load the ascii digit into D0
000013EA  B03C 00FF                155              CMP.B       #$FF,D0             ;If value is $FF, there is no digit
000013EE  6700 009A                156              BEQ         C_INVALID
000013F2  B03C 0000                157              CMP.B       #$00,D0             ;If value is $00, then probably done
000013F6  6700 0062                158              BEQ         CNVRT_DONE              
000013FA                           159              
000013FA  B63C 0000                160              CMP.B       #0,D3               ;If counter var == 0
000013FE  6700 005A                161              BEQ         CNVRT_DONE
00001402  5303                     162              SUBI.B      #1,D3               ;Else, decrement counter var
00001404                           163              
00001404                           164              ;Determine whether num, upper, or lower case ascii a-f                                    
00001404  B03C 0030                165              CMP.B       #$30,D0             ;If <30, not a number
00001408  6D00 0080                166              BLT         C_INVALID           
0000140C  B03C 0046                167              CMP.B       #$46,D0             ;If >46, it's possibly a lowercase letter 
00001410  6E00 0016                168              BGT         C_IS_LC             ;Check if it's a valid lower ascii letter
00001414                           169              
00001414  B03C 0040                170              CMP.B       #$40,D0             ;If <40, must be number
00001418  6D00 0022                171              BLT         C_NUMERIC
0000141C  B03C 0041                172              CMP.B       #$41,D0             ;If >41, must be upper case ascii
00001420  6E00 0024                173              BGT         C_ALPHA_U
00001424                           174  
00001424  6000 0064                175              BRA         C_INVALID           ;If none of the above, the input is not valid 
00001428                           176              
00001428  B03C 0061                177  C_IS_LC     CMP.B       #$61,D0             ;If >61, input is invalid
0000142C  6D00 005C                178              BLT         C_INVALID
00001430  B03C 0066                179              CMP.B       #$66,D0             ;If >66, input is invalid
00001434  6E00 0054                180              BGT         C_INVALID
00001438                           181              
00001438  6000 0016                182              BRA         C_ALPHA_L           ;Else must be a valid lowercase input
0000143C                           183  
0000143C  0400 0030                184  C_NUMERIC   SUBI.B      #$30,D0             ;Subtract 0x30 to convert to hex
00001440  E98A                     185              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
00001442  D400                     186              ADD.B       D0,D2               ;Accumulate digits into D2
00001444  60A2                     187              BRA         C_LOOP  
00001446                           188  
00001446                           189  
00001446  0400 0037                190  C_ALPHA_U   SUBI.B      #$37,D0             ;Subtract 0x37 to convert to hex
0000144A  E98A                     191              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
0000144C  D400                     192              ADD.B       D0,D2               ;Accumulate digits into D2
0000144E  6098                     193              BRA         C_LOOP
00001450                           194  
00001450  0400 0057                195  C_ALPHA_L   SUBI.B      #$57,D0             ;Subtract 0x57 to convert to hex
00001454  E98A                     196              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
00001456  D400                     197              ADD.B       D0,D2               ;Accumulate digits into D2
00001458  608E                     198              BRA         C_LOOP
0000145A                           199          
0000145A                           200                         
0000145A  B63C 0008                201  CNVRT_DONE  CMP.B       #8,D3               ;If no input, invalid
0000145E  6700 002A                202              BEQ         C_INVALID           
00001462                           203              
00001462  4E75                     204              RTS                             ;Else, done
00001464                           205              
00001464                           206  
00001464  BDCD                     207  C_VALIDATE  CMPA.L      A5,A6               ;If end address < start address     
00001466  6D00 002C                208              BLT         C_ERR1
0000146A                           209                                                
0000146A  BBFC 00005000            210              CMPA.L      #$00005000,A5       ;If start address is <0x5000
00001470  6D00 0036                211              BLT         C_ERR2
00001474                           212              
00001474  200D                     213              MOVE.L      A5,D0               ;Check rightmost input address bit
00001476  0800 0000                214              BTST        #0,D0               ;If rightmost (least sig) bit is 1 (aka ODD address)
0000147A  6600 0040                215              BNE         C_ERR3           
0000147E                           216              
0000147E  200E                     217              MOVE.L      A6,D0               ;Check rightmost input address bit
00001480  0800 0000                218              BTST        #0,D0               ;If rightmost (least sig) bit is 1 (aka ODD address)
00001484  6600 004A                219              BNE         C_ERR4
00001488                           220              
00001488  4E75                     221              RTS                             ;If none of the above, input is valid
0000148A                           222              
0000148A  4EB9 000014E4            223  C_INVALID   JSR         C_ERR_BASE1         ;Clear screen and clear registers
00001490  6000 0080                224              BRA         C_ERR_BASE2         ;Print generic error msg and branch to start
00001494                           225  
00001494  4EB9 000014E4            226  C_ERR1      JSR         C_ERR_BASE1         ;Clear screen and registers
0000149A  43F8 12EC                227              LEA         M_ERR_ADDR1,A1      ;Load error message
0000149E  103C 000E                228              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000014A2  4E4F                     229              TRAP        #15
000014A4                           230              
000014A4  6000 006C                231              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
000014A8                           232  
000014A8  4EB9 000014E4            233  C_ERR2      JSR         C_ERR_BASE1         ;Clear screen and registers
000014AE  43F8 130F                234              LEA         M_ERR_ADDR2,A1      ;Load error message
000014B2  103C 000E                235              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000014B6  4E4F                     236              TRAP        #15
000014B8                           237              
000014B8  6000 0058                238              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
000014BC                           239  
000014BC                           240  
000014BC                           241              
000014BC  4EB9 000014E4            242  C_ERR3      JSR         C_ERR_BASE1         ;Clear screen and registers
000014C2  43F8 1351                243              LEA         M_ERR_ADDR3,A1      ;Load error message
000014C6  103C 000E                244              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000014CA  4E4F                     245              TRAP        #15
000014CC                           246              
000014CC  6000 0044                247              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
000014D0                           248  
000014D0  4EB9 000014E4            249  C_ERR4      JSR         C_ERR_BASE1         ;Clear screen and registers
000014D6  43F8 136A                250              LEA         M_ERR_ADDR4,A1      ;Load error message
000014DA  103C 000E                251              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000014DE  4E4F                     252              TRAP        #15
000014E0                           253              
000014E0  6000 0030                254              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
000014E4                           255  
000014E4                           256  
000014E4  103C 000B                257  C_ERR_BASE1 MOVE.B      #11,D0              ;Clear screen
000014E8  323C FF00                258              MOVE.W      #$FF00,D1
000014EC  4E4F                     259              TRAP        #15
000014EE                           260              
000014EE  4282                     261              CLR.L       D2
000014F0  4285                     262              CLR.L       D5
000014F2  4286                     263              CLR.L       D6
000014F4                           264                                
000014F4                           265  
000014F4  21FC FFFFFFFF 1086       266              MOVE.L      #$FFFFFFFF,(START_ADDR)        
000014FC  21FC FFFFFFFF 10A4       267              MOVE.L      #$FFFFFFFF,(END_ADDR)
00001504  2A7C 00000000            268              MOVEA.L     #$00000000,A5       ;Clear registers
0000150A  2C7C 00000000            269              MOVEA.L     #$00000000,A6 
00001510                           270       
00001510  4E75                     271              RTS
00001512                           272  
00001512  43F8 12BC                273  C_ERR_BASE2 LEA         M_INV_INPUT,A1      ;Load error message
00001516  103C 000E                274              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000151A  4E4F                     275              TRAP        #15
0000151C                           276              
0000151C  6000 FAE2                277              BRA         START 
00001520                           278             
00001520                           279  
00001520                           280  
00001520                           281  -------------------- end include --------------------
00001520                           282              INCLUDE     'TeamVisualBasic_Disassembler_OutputBuilder.X68'    ;Include OutputBuilder class file
00001520                           283  
00001520  4EB9 00001534            284  BUILD_STR   JSR         PREPARE_OP          ;Define a location in memory to write an OPCODE string to
00001526  4EB9 0000153A            285              JSR         GET_ADDR            ;Accumulate the OPCODE's address into the A4 string [0xADDR]
0000152C  4EB9 0000157A            286              JSR         JT_START            ;Send OPCODE to jump table for decoding [OPCODE $OPERAND]
00001532                           287              
00001532  4E75                     288              RTS                             ;Return back to main disassembler loop
00001534                           289  
00001534  387C 10C2                290  PREPARE_OP  MOVE.W      #OP_ADDR,A4         ;Define a location in memory to write an OPCODE string to
00001538  4E75                     291              RTS
0000153A                           292              
0000153A  200D                     293  GET_ADDR    MOVE.L      A5,D0               ;Save the address pointer into D0
0000153C  4282                     294              CLR.L       D2                  ;Clear D2
0000153E  143C 0008                295              MOVE.B      #8,D2               ;Counter var starts at 8
00001542                           296              
00001542  4EB9 00001556            297  GA_LOOP     JSR         HEX_2_ASCII         ;Convert the hex to ascii for printing
00001548  5342                     298              SUBI        #1,D2               ;Decrement counter var
0000154A  B43C 0000                299              CMP.B       #0,D2               ;Is counter var == 0?
0000154E  6EF2                     300              BGT         GA_LOOP             ;If not, loop         
00001550                           301              
00001550  18FC 0020                302              MOVE.B      #' ',(A4)+           ;Otherwise, we are done. Append a space
00001554  4E75                     303              RTS                             ;Return back to main disassembler loop    
00001556                           304  
00001556  E998                     305  HEX_2_ASCII ROL.L       #4,D0               ;Get the most significant hex digit into the right 4 bits
00001558  1200                     306              MOVE.B      D0,D1               ;Save that byte into D1
0000155A  0241 000F                307              ANDI        #$0F,D1             ;Isolate the hex digit 
0000155E                           308              
0000155E  B23C 0009                309              CMP.B       #$9,D1              ;If hex digit is > 9
00001562  6E00 0006                310              BGT         APPND_ALPHA         ;It is an alphabet ascii char. Branch
00001566  6000 000A                311              BRA         APPND_NUM           ;Else it is a numeric ascii char. Branch
0000156A                           312              
0000156A  0601 0037                313  APPND_ALPHA ADDI.B      #$37,D1             ;Add $37 to make it a ascii alphabet char
0000156E  18C1                     314              MOVE.B      D1,(A4)+            ;Append this character to string
00001570  4E75                     315              RTS           
00001572                           316  
00001572  0601 0030                317  APPND_NUM   ADDI.B      #$30,D1             ;Add $30 to make it a ascii numeric char
00001576  18C1                     318              MOVE.B      D1,(A4)+            ;Append this character to string
00001578  4E75                     319              RTS
0000157A                           320         
0000157A                           321  
0000157A                           322  -------------------- end include --------------------
0000157A                           323              INCLUDE     'TeamVisualBasic_JumpTable.X68'                     ;Include Jump Table file
0000157A                           324  
0000157A  3015                     325  JT_START    MOVE.W      (A5),D0             *move op code into d0 to bit shift
0000157C  E848                     326              LSR.W       #4,D0               *Shift right 4 bits
0000157E  E848                     327              LSR.W       #4,D0               *shift right 4 bits
00001580  E848                     328              LSR.W       #4,D0               *shift right 4 bits
00001582                           329              
00001582  0C40 0000                330              CMPI.W      #0,D0               *check if it falls into 0 bin
00001586  6700 007A                331              BEQ         BIN_0
0000158A                           332      
0000158A  0C40 0001                333              CMPI.W      #1,D0               *check if it is a MOVE
0000158E  6700 00A2                334              BEQ         BIN_MOVE
00001592                           335              
00001592  0C40 0002                336              CMPI.W      #2,D0               *check if it is a MOVE
00001596  6700 009A                337              BEQ         BIN_MOVE
0000159A                           338              
0000159A  0C40 0003                339              CMPI.W      #3,D0               *check if it is a MOVE
0000159E  6700 0092                340              BEQ         BIN_MOVE
000015A2                           341              
000015A2  0C40 0004                342              CMPI.W      #4,D0               *check if it falls into 4 bin
000015A6  6700 00A6                343              BEQ         BIN_4
000015AA                           344  
000015AA  0C40 0005                345              CMPI.W      #5,D0               *check if it falls into 5 bin
000015AE  6700 00DC                346              BEQ         BIN_5
000015B2                           347  
000015B2  0C40 0006                348              CMPI.W      #6,D0               *check if it falls into 6 bin
000015B6  6700 00D8                349              BEQ         BIN_6
000015BA                           350  
000015BA  0C40 0007                351              CMPI.W      #7,D0               *check if it falls into 7 bin
000015BE  6700 010A                352              BEQ         BIN_7
000015C2                           353  
000015C2  0C40 0008                354              CMPI.W      #8,D0               *check if it falls into 8 bin
000015C6  6700 0106                355              BEQ         BIN_8
000015CA                           356  
000015CA  0C40 0009                357              CMPI.W      #9,D0               *check if it falls into 9 bin
000015CE  6700 0112                358              BEQ         BIN_9
000015D2                           359  
000015D2  0C40 000A                360              CMPI.W      #10,D0              *check if it falls into 10 bin
000015D6  6700 010E                361              BEQ         BIN_10
000015DA                           362  
000015DA  0C40 000B                363              CMPI.W      #11,D0              *check if it falls into 11 bin
000015DE  6700 010A                364              BEQ         BIN_11
000015E2                           365  
000015E2  0C40 000C                366              CMPI.W      #12,D0              *check if it falls into 12 bin
000015E6  6700 0120                367              BEQ         BIN_12
000015EA                           368  
000015EA  0C40 000D                369              CMPI.W      #13,D0              *check if it falls into 12 bin
000015EE  6700 011C                370              BEQ         BIN_13
000015F2                           371  
000015F2  0C40 000E                372              CMPI.W      #14,D0              *check if it falls into 14 bin
000015F6  6700 0130                373              BEQ         BIN_14
000015FA                           374  
000015FA  0C40 000F                375              CMPI.W      #15,D0              *check if it falls into 15 bin
000015FE  6700 014C                376              BEQ         BIN_15
00001602                           377  
00001602  3015                     378  BIN_0       MOVE.W      (A5),D0             *reload opcode
00001604  E048                     379              LSR.W       #8,D0               *shift bits to the right 8
00001606  C07C 000F                380              AND.W       #$0F,D0             *Isolate the last 4 bits
0000160A                           381              
0000160A  0C40 000C                382              CMPI.W      #12,D0              *Check if the bit is C
0000160E  6700 014C                383              BEQ         CMPI                *if CMPI go to the subroutine
00001612                           384              
00001612  0C40 0000                385              CMPI.W      #0,D0               *Check if the bit is a 0
00001616  6700 0138                386              BEQ         ORI                 *if ORI go to the subroutine
0000161A                           387              
0000161A  0C40 0008                388              CMPI.W      #8,D0               *Check if the bit is an 8
0000161E  6700 0148                389              BEQ         BCLR                *if BCLR immediate go to subroutine
00001622                           390              
00001622  C07C 0001                391              AND.W       #$01,D0             *isolate the last bit
00001626  0C40 0001                392              CMPI.W      #1,D0               *Check if the bit is a 1
0000162A  6700 013C                393              BEQ         BCLR                *if BCLR register go to subroutine
0000162E                           394              
0000162E  6000 0238                395              BRA         DATA           
00001632                           396  
00001632  3015                     397  BIN_MOVE    MOVE.W      (A5),D0             *reload opcode
00001634  EC48                     398              LSR.W       #6,D0               *shift bits to the right 6
00001636  C07C 0007                399              AND.W       #$07,D0             *isolate the last 3 bits
0000163A  0C40 0001                400              CMPI.W      #1,D0               *check if the bits are 001
0000163E  6700 0134                401              BEQ         MOVEA               *if MOVEA go to SUB
00001642                           402              
00001642  0C40 0007                403              CMPI.W      #7,D0               *check if the bits are 111
00001646  6700 0220                404              BEQ         DATA                *if 111 must be DATA
0000164A  6000 0122                405              BRA         MOVE                *otherwise must be MOVE
0000164E                           406              
0000164E  3015                     407  BIN_4       MOVE.W      (A5),D0             *reload opcode
00001650  0C40 4E71                408              CMPI.W      #$4E71,D0           *check for no-op value
00001654  6700 0124                409              BEQ         NOP                 *if NOP go to SUB
00001658                           410              
00001658  0C40 4E75                411              CMPI.W      #$4E75,D0           *Compare with a constant value for RTS      
0000165C  6700 0134                412              BEQ         RTS                 *if RTS go to RTS subroutine
00001660                           413              
00001660  E848                     414              LSR.W       #4,D0               *shift right 4 bits
00001662  E848                     415              LSR.W       #4,D0               *shift right 4 bits
00001664  C07C 000F                416              AND.W       #$0F,D0             *bitmask first 4 bits  
00001668  0C40 000E                417              CMPI.W      #$E,D0              *compare final masked bits
0000166C  6700 0146                418              BEQ         JSR                 *if it equals E it is JSR
00001670                           419              
00001670  0C40 0004                420              CMPI.W      #$4,D0              *check for defining bits
00001674  6700 0144                421              BEQ         NEG                 *branch to NEG routine
00001678                           422              
00001678  C07C 0001                423              AND.W       #$1,D0
0000167C  0C40 0001                424              CMPI.W      #1,D0
00001680  6700 0126                425              BEQ         LEA
00001684                           426              
00001684  0C40 0000                427              CMPI.W      #0,D0
00001688  6700 0124                428              BEQ         MOVEM
0000168C                           429              
0000168C  6000 0138                430  BIN_5       BRA         SUBQ                *SUBQ is the only option for this bin so branch to SUB
00001690                           431  
00001690  3015                     432  BIN_6       MOVE.W      (A5),D0             *reload fresh op code
00001692  E848                     433              LSR.W       #4,D0               *shift right 4
00001694  E848                     434              LSR.W       #4,D0               *shift right 4
00001696  C07C 000F                435              AND.W       #$0F,D0             *Finds the condition code of the branch statement through bitmask
0000169A                           436              
0000169A  0C40 0000                437              CMPI.W      #0,D0               *check if the 4 bits == 0000
0000169E  6700 0152                438              BEQ         BRA_SUB             *branch to BRA SUB
000016A2                           439              
000016A2  0C40 0004                440              CMPI.W      #4,D0
000016A6  6700 013E                441              BEQ         BCC                 *branch to BCC code 
000016AA                           442                                                                       
000016AA  0C40 000D                443              CMPI.W      #$D,D0
000016AE  6700 013C                444              BEQ         BLT                 *branch to BLT SUB            
000016B2                           445                                                                   
000016B2  0C40 0008                446              CMPI.W      #8,D0
000016B6  6700 0128                447              BEQ         BVC                 *branch to BVC code
000016BA                           448              
000016BA  0C40 0005                449              CMPI.W      #5,D0
000016BE  6700 011A                450              BEQ         BCS                 *branch to BCS code
000016C2                           451              
000016C2  0C40 000C                452              CMPI.W      #$C,D0
000016C6  6700 010A                453              BEQ         BGE                 *branch to BGE code
000016CA                           454  
000016CA  6000 019C                455  BIN_7       BRA        DATA                *If it goes into this bin it is DATA
000016CE                           456  
000016CE  3015                     457  BIN_8       MOVE.W      (A5),D0
000016D0  EC48                     458              LSR.W       #6,D0
000016D2  C07C 0007                459              AND.W       #$07,D0   
000016D6  0C40 0007                460              CMPI.W      #7,D0
000016DA  6700 011C                461              BEQ         DIVS
000016DE                           462              
000016DE  6000 011E                463              BRA         OR  
000016E2                           464              
000016E2  6000 0120                465  BIN_9       BRA         SUB                 *SUB is the only option for this bin so branch to SUB
000016E6                           466  
000016E6  6000 0180                467  BIN_10      BRA        DATA                *If it goes into this bin it is DATA
000016EA                           468  
000016EA  3015                     469  BIN_11      MOVE.W      (A5),D0             *reload opcode into D0
000016EC  E848                     470              LSR.W       #4,D0               *shift bits to the right 4
000016EE  E848                     471              LSR.W       #4,D0               *Shift bits to the right 4
000016F0  C07C 0001                472              AND.W       #$01,D0             *isolate the last bit
000016F4  0C40 0001                473              CMPI.W      #1,D0               *check if the bit is a 1
000016F8  6700 0110                474              BEQ         EOR                 *if EOR go to the SUB
000016FC                           475              
000016FC  0C40 0000                476              CMPI.W      #0,D0               *check if the bit is a 0
00001700  6700 0114                477              BEQ         CMP                 *if CMP go to the SUB
00001704                           478              
00001704  6000 0162                479              BRA         DATA                *if neither EOR or CMP must be DATA
00001708                           480              
00001708  6000 0118                481  BIN_12      BRA         MULS                *MULS is the only option for this bin so branch to SUB
0000170C                           482  
0000170C  3015                     483  BIN_13      MOVE.W      (A5),D0             *reload opcode into D0
0000170E  EC48                     484              LSR.W       #6,D0               *shift bits to the right 6
00001710  C07C 0007                485              AND.W       #$07,D0             *isolate the last 3 bits
00001714  0C40 0003                486              CMPI.W      #$3,D0              *check if the bits are 011
00001718  6700 0114                487              BEQ         ADDA                *if ADDA go to SUB        
0000171C                           488              
0000171C  0C40 0007                489              CMPI.W      #$7,D0              *check if the bits are 111
00001720  6700 010C                490              BEQ         ADDA                *if ADDA go to SUB 
00001724                           491                                                          
00001724  6000 0102                492              BRA         ADD                 *if bits are not ADDA must be ADD and go to SUB
00001728                           493              
00001728  3015                     494  BIN_14      MOVE.W      (A5),D0             *Reload the opcode
0000172A  E648                     495              LSR.W       #3,D0               *shift bits down
0000172C  C07C 0007                496              AND.W       #$07,D0             *mask bits
00001730  B07C 0001                497              CMP.W       #1,D0               *determin which kind of shift it is
00001734  6700 00FE                498              BEQ         LOGICSHIFT          *bra to logic shift
00001738                           499              
00001738  B07C 0000                500              CMP.W       #0,D0
0000173C  6700 0112                501              BEQ         ARITH_SHIFT         *bra to arthimetic shift
00001740                           502              
00001740  B07C 0003                503              CMP.W       #3,D0
00001744  6700 0110                504              BEQ         ROTATE              *bra to rotate      
00001748                           505              
00001748  6000 011E                506              BRA         DATA                *if not a shift must be DATA 
0000174C                           507                                                                  
0000174C                           508  
0000174C  6000 011A                509  BIN_15      BRA        DATA                *IF it goes into this bin it is DATA
00001750                           510                                                                                               
00001750                           511  
00001750                           512  
00001750  38FC 18D2                513  ORI         MOVE.W      #S_ORI,(A4)+        *Load OPCODE string into (A4)
00001754  4EB9 00001884            514              JSR         GET_SIZE_67
0000175A  4E75                     515              RTS
0000175C                           516              
0000175C  38FC 18D6                517  CMPI        MOVE.W      #S_CMPI,(A4)+       *Load OPCODE string into (A4)
00001760  4EB9 00001884            518              JSR         GET_SIZE_67
00001766  4E75                     519              RTS
00001768                           520              
00001768  38FC 18DB                521  BCLR        MOVE.W      #S_BCLR,(A4)+       *Load OPCODE string into (A4)
0000176C  4E75                     522              RTS            
0000176E                           523  
0000176E  38FC 18E0                524  MOVE        MOVE.W      #S_MOVE,(A4)+       *Load OPCODE string into (A4)
00001772  4E75                     525              RTS
00001774                           526              
00001774  38FC 18E5                527  MOVEA       MOVE.W      #S_MOVEA,(A4)+      *Load OPCODE string into (A4)
00001778  4E75                     528              RTS   
0000177A                           529  
0000177A                           530  
0000177A  5447                     531  NOP         ADDI        #BYTE,D7            *NOP is 2 Bytes; Increment length var by 2
0000177C  18FC 004E                532              MOVE.B      #'N',(A4)+          *Load OPCODE string into (A4)
00001780  18FC 004F                533              MOVE.B      #'O',(A4)+
00001784  18FC 0050                534              MOVE.B      #'P',(A4)+
00001788  18FC 0020                535              MOVE.B      #' ',(A4)+
0000178C  18FC 0000                536              MOVE.B      #0,(A4)+            *End the string with a 0 delimiter 
00001790                           537              
00001790  4E75                     538              RTS
00001792                           539              
00001792                           540              
00001792  18FC 0052                541  RTS         MOVE.B      #'R',(A4)+          *Load OPCODE string into (A4)
00001796  18FC 0054                542              MOVE.B      #'T',(A4)+
0000179A  18FC 0053                543              MOVE.B      #'S',(A4)+
0000179E  18FC 0020                544              MOVE.B      #' ',(A4)+
000017A2  18FC 0000                545              MOVE.B      #0,(A4)+            *End the string with a 0 delimiter 
000017A6                           546              
000017A6  4E75                     547              RTS       
000017A8                           548              
000017A8  38FC 1907                549  LEA         MOVE.W      #S_LEA,(A4)+        *Load OPCODE string into (A4)
000017AC  4E75                     550              RTS
000017AE                           551              
000017AE  38FC 190F                552  MOVEM       MOVE.W      #S_MOVEM,(A4)+      *Load OPCODE string into (A4)
000017B2  4E75                     553              RTS
000017B4                           554              
000017B4  38FC 1927                555  JSR         MOVE.W      #S_JSR,(A4)+        *Load OPCODE string into (A4)
000017B8  4E75                     556              RTS
000017BA                           557              
000017BA  38FC 190B                558  NEG         MOVE.W      #S_NEG,(A4)+        *Load OPCODE string into (A4)
000017BE  4EB9 00001884            559              JSR         GET_SIZE_67
000017C4  4E75                     560              RTS
000017C6                           561               
000017C6                           562              
000017C6  38FC 1915                563  SUBQ        MOVE.W      #S_SUBQ,(A4)+       *Load OPCODE string into (A4)
000017CA  4EB9 00001884            564              JSR         GET_SIZE_67
000017D0  4E75                     565              RTS
000017D2                           566             
000017D2  38F9 000018EB            567  BGE         MOVE.W      S_BGE,(A4)+         *Load OPCODE string into (A4)
000017D8  4E75                     568              RTS           
000017DA                           569              
000017DA  38FC 18EF                570  BCS         MOVE.W      #S_BCS,(A4)+        *Load OPCODE string into (A4)
000017DE  4E75                     571              RTS
000017E0                           572              
000017E0  38FC 18F3                573  BVC         MOVE.W      #S_BVC,(A4)+        *Load OPCODE string into (A4)
000017E4  4E75                     574              RTS
000017E6                           575              
000017E6  38FC 18F7                576  BCC         MOVE.W      #S_BCC,(A4)+        *Load OPCODE string into (A4)
000017EA  4E75                     577              RTS
000017EC                           578              
000017EC  38FC 18FB                579  BLT         MOVE.W      #S_BLT,(A4)+        *Load OPCODE string into (A4)
000017F0  4E75                     580              RTS
000017F2                           581  
000017F2  38FC 18FF                582  BRA_SUB     MOVE.W      #S_BRA,(A4)+        *Load OPCODE string into (A4)
000017F6  4E75                     583              RTS
000017F8                           584              
000017F8  38FC 191B                585  DIVS        MOVE.W      #S_DIVS,(A4)+       *Load OPCODE string into (A4)
000017FC  4E75                     586              RTS
000017FE                           587              
000017FE  38FC 1920                588  OR          MOVE.W      #S_OR,(A4)+         *Load OPCODE string into (A4)
00001802  4E75                     589              RTS
00001804                           590              
00001804  38FC 1923                591  SUB         MOVE.W      #S_SUB,(A4)+        *Load OPCODE string into (A4)
00001808  4E75                     592              RTS
0000180A                           593              
0000180A  38FC 18BC                594  EOR         MOVE.W      #S_EOR,(A4)+        *Load OPCODE string into (A4)
0000180E  4EB9 00001884            595              JSR         GET_SIZE_67
00001814  4E75                     596              RTS
00001816                           597  
00001816  38FC 18C0                598  CMP         MOVE.W      #S_CMP,(A4)+        *Load OPCODE string into (A4)
0000181A  4EB9 00001884            599              JSR         GET_SIZE_67
00001820  4E75                     600              RTS
00001822                           601  
00001822  38FC 18C4                602  MULS        MOVE.W      #S_MULS,(A4)+       *Load OPCODE string into (A4)
00001826  4E75                     603              RTS
00001828                           604              
00001828  38FC 18C9                605  ADD         MOVE.W      #S_ADD,(A4)+        *Load OPCODE string into (A4)
0000182C  4E75                     606              RTS
0000182E                           607  
0000182E  38FC 18CD                608  ADDA        MOVE.W      #S_ADDA,(A4)+       *Load OPCODE string into (A4)
00001832  4E75                     609              RTS
00001834                           610       
00001834                           611                                                                      
00001834  38FC 192B                612  LOGICSHIFT  MOVE.W      #S_LS,(A4)+         *Load logical shift OPCODE string into (A4)                    
00001838  6000 0002                613              BRA         RIGHTORLEFT             
0000183C                           614                
0000183C  3010                     615  RIGHTORLEFT MOVE.W      (A0),D0             *reload op
0000183E  E148                     616              LSL.W       #8,D0               *shift until dr bit is reached
00001840  B07C 0000                617              CMP.W       #0,D0               *check if left
00001844  6700 0016                618              BEQ         LEFT
00001848                           619              
00001848  B07C 0001                620              CMP.W       #1,D0               *check if right
0000184C  6700 0014                621              BEQ         RIGHT  
00001850                           622                                      
00001850  38FC 192E                623  ARITH_SHIFT MOVE.W      #S_AS,(A4)+         *Load arithmetic shift OPCODE string into (A4)             
00001854  60E6                     624              BRA         RIGHTORLEFT         
00001856                           625                  
00001856  38FC 1931                626  ROTATE      MOVE.W      #S_RO,(A4)+         *Load rotate OPCODE string into (A4)           
0000185A  60E0                     627              BRA         RIGHTORLEFT
0000185C                           628              
0000185C  38FC 1934                629  LEFT        MOVE.W      #S_LEFT,(A4)+       *Load directional string into (A4)
00001860  4E75                     630              RTS                      
00001862                           631             
00001862                           632             
00001862  38FC 1936                633  RIGHT       MOVE.W      #S_RIGHT,(A4)+      *Load directional string into (A4)
00001866  4E75                     634              RTS
00001868                           635                                    
00001868                           636  
00001868                           637  
00001868  18FC 0044                638  DATA        MOVE.B      #'D',(A4)+          *Write DATA into string
0000186C  18FC 0041                639              MOVE.B      #'A',(A4)+          
00001870  18FC 0054                640              MOVE.B      #'T',(A4)+          
00001874  18FC 0041                641              MOVE.B      #'A',(A4)+         
00001878  18FC 0020                642              MOVE.B      #' ',(A4)+          *Write a space into string
0000187C                           643              
0000187C  18FC 0000                644              MOVE.B      #0,(A4)+            *End the string with a 0 delimiter 
00001880                           645              
00001880  38D5                     646              MOVE.W      (A5),(A4)+          *Write the word's worth of OPCODE data that couldn't be decoded
00001882                           647              
00001882  4E75                     648              RTS                             *Return program flow back to Dissasembler file
00001884                           649  
00001884  3015                     650  GET_SIZE_67 MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001886  EC48                     651              LSR.W       #6,D0               *shift bits right 6
00001888  C07C 0003                652              AND.W       #$03,D0             *Isolate last 2 bits
0000188C  0C40 0000                653              CMPI.W      #0,D0
00001890  6700 0014                654              BEQ         APPND_BYTE          *Is a Byte operation
00001894  0C40 0001                655              CMPI        #1,D0
00001898  6700 E76A                656              BEQ         WORD                *Is a Word operation
0000189C  0C40 0002                657              CMPI        #2,D0
000018A0  6700 E766                658              BEQ         LONG                *Is a Long operation
000018A4  60C2                     659              BRA         DATA                *Not a valid size must be data 
000018A6                           660  
000018A6  38FC 193D                661  APPND_BYTE  MOVE.W      #S_BYTE,(A4)+       *load size into (A4)
000018AA  4E75                     662              RTS
000018AC                           663  
000018AC  38FC 1940                664  APPND_WORD  MOVE.W      #S_WORD,(A4)+       *load size into (A4)
000018B0  4E75                     665              RTS
000018B2                           666  
000018B2  38FC 1943                667  APPND_LONG  MOVE.W      #S_LONG,(A4)+       *load size into (A4)
000018B6  4E75                     668              RTS                
000018B8                           669              
000018B8                           670  
000018B8= 4E 4F 50 00              671  S_NOP       DC.B        'NOP',0   
000018BC= 45 4F 52 00              672  S_EOR       DC.B        'EOR',0
000018C0= 43 4D 50 00              673  S_CMP       DC.B        'CMP',0
000018C4= 4D 55 4C 53 00           674  S_MULS      DC.B        'MULS',0
000018C9= 41 44 44 00              675  S_ADD       DC.B        'ADD',0
000018CD= 41 44 44 41 00           676  S_ADDA      DC.B        'ADDA',0
000018D2= 4F 52 49 00              677  S_ORI       DC.B        'ORI',0
000018D6= 43 4D 50 49 00           678  S_CMPI      DC.B        'CMPI',0
000018DB= 42 43 4C 52 00           679  S_BCLR      DC.B        'BCLR',0
000018E0= 4D 4F 56 45 00           680  S_MOVE      DC.B        'MOVE',0
000018E5= 4D 4F 56 45 41 00        681  S_MOVEA     DC.B        'MOVEA',0
000018EB= 42 47 45 00              682  S_BGE       DC.B        'BGE',0
000018EF= 42 43 53 00              683  S_BCS       DC.B        'BCS',0
000018F3= 42 56 43 00              684  S_BVC       DC.B        'BVC',0
000018F7= 42 43 43 00              685  S_BCC       DC.B        'BCC',0 
000018FB= 42 4C 54 00              686  S_BLT       DC.B        'BLT',0
000018FF= 42 52 41 00              687  S_BRA       DC.B        'BRA',0                      
00001903= 52 54 53 00              688  S_RTS       DC.B        'RTS',0
00001907= 4C 45 41 00              689  S_LEA       DC.B        'LEA',0
0000190B= 4E 45 47 00              690  S_NEG       DC.B        'NEG',0 
0000190F= 4D 4F 56 45 4D 00        691  S_MOVEM     DC.B        'MOVEM',0
00001915= 53 55 42 2E 51 00        692  S_SUBQ      DC.B        'SUB.Q',0
0000191B= 44 49 56 53 00           693  S_DIVS      DC.B        'DIVS',0
00001920= 4F 52 00                 694  S_OR        DC.B        'OR',0
00001923= 53 55 42 00              695  S_SUB       DC.B        'SUB',0
00001927= 4A 53 52 00              696  S_JSR       DC.B        'JSR',0
0000192B= 4C 53 00                 697  S_LS        DC.B        'LS',0
0000192E= 41 53 00                 698  S_AS        DC.B        'AS',0
00001931= 52 30 00                 699  S_RO        DC.B        'R0',0
00001934= 4C 00                    700  S_LEFT      DC.B        'L',0
00001936= 52 00                    701  S_RIGHT     DC.B        'R',0
00001938= 44 41 54 41 00           702  S_DATA      DC.B        'DATA',0
0000193D= 2E 42 00                 703  S_BYTE      DC.B        '.B',0
00001940= 2E 57 00                 704  S_WORD      DC.B        '.W',0
00001943= 2E 4C 00                 705  S_LONG      DC.B        '.L',0
00001946                           706  
00001946                           707  
00001946                           708  
00001946                           709  
00001946                           710  
00001946                           711  
00001946                           712  
00001946                           713  
00001946                           714  -------------------- end include --------------------
00001946                           715              
00001946                           716              END         START               ;last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1828
ADDA                182E
APPND_ALPHA         156A
APPND_BYTE          18A6
APPND_LONG          18B2
APPND_NUM           1572
APPND_WORD          18AC
ARITH_SHIFT         1850
BCC                 17E6
BCLR                1768
BCS                 17DA
BGE                 17D2
BIN_0               1602
BIN_10              16E6
BIN_11              16EA
BIN_12              1708
BIN_13              170C
BIN_14              1728
BIN_15              174C
BIN_4               164E
BIN_5               168C
BIN_6               1690
BIN_7               16CA
BIN_8               16CE
BIN_9               16E2
BIN_MOVE            1632
BLT                 17EC
BRA_SUB             17F2
BUILD_STR           1520
BVC                 17E0
BYTE                2
CMP                 1816
CMPI                175C
CNVRT_ADDR          13BE
CNVRT_DONE          145A
CR                  D
C_ALPHA_L           1450
C_ALPHA_U           1446
C_ERR1              1494
C_ERR2              14A8
C_ERR3              14BC
C_ERR4              14D0
C_ERR_BASE1         14E4
C_ERR_BASE2         1512
C_INVALID           148A
C_IS_LC             1428
C_LOOP              13E8
C_NUMERIC           143C
C_VALIDATE          1464
DATA                1868
DISP_INTRO          101C
DISP_WAIT           102A
DIVS                17F8
END                 1080
END_ADDR            10A4
EOR                 180A
GA_LOOP             1542
GET_ADDR            153A
GET_SIZE_67         1884
HEX_2_ASCII         1556
INPUT_ADDR          1384
JSR                 17B4
JT_START            157A
LEA                 17A8
LEFT                185C
LF                  A
LOGICSHIFT          1834
LONG                8
LOOP_COND           105C
MAIN_LOOP           1048
MOVE                176E
MOVEA               1774
MOVEM               17AE
MULS                1822
M_ERR_ADDR1         12EC
M_ERR_ADDR2         130F
M_ERR_ADDR3         1351
M_ERR_ADDR4         136A
M_INPUT_E           127D
M_INPUT_S           123D
M_INTRO             10E0
M_INV_INPUT         12BC
M_IN_RULES          1144
M_NEWLINE           1381
M_WAIT              12A1
NEG                 17BA
NOP                 177A
OP_ADDR             10C2
OR                  17FE
ORI                 1750
PREPARE_OP          1534
PRINT_OP            106A
RIGHT               1862
RIGHTORLEFT         183C
ROTATE              1856
RTS                 1792
START               1000
START_ADDR          1086
SUB                 1804
SUBQ                17C6
S_ADD               18C9
S_ADDA              18CD
S_AS                192E
S_BCC               18F7
S_BCLR              18DB
S_BCS               18EF
S_BGE               18EB
S_BLT               18FB
S_BRA               18FF
S_BVC               18F3
S_BYTE              193D
S_CMP               18C0
S_CMPI              18D6
S_DATA              1938
S_DIVS              191B
S_EOR               18BC
S_JSR               1927
S_LEA               1907
S_LEFT              1934
S_LONG              1943
S_LS                192B
S_MOVE              18E0
S_MOVEA             18E5
S_MOVEM             190F
S_MULS              18C4
S_NEG               190B
S_NOP               18B8
S_OR                1920
S_ORI               18D2
S_RIGHT             1936
S_RO                1931
S_RTS               1903
S_SUB               1923
S_SUBQ              1915
S_WORD              1940
WORD                4
