00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/12/2018 11:26:57 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Team Visual Basic's Disassembler
00000000                             3  * Written by :  Henry Hong, Dylan Desmond, Austin Abeyta
00000000                             4  * Date       :  ?
00000000                             5  * Description:  CSS422 Final Project
00000000                             6  *               Machine code to Motorola 68000 Assembly
00000000                             7  *               Main Driver File
00000000                             8  *-----------------------------------------------------------
00000000                             9      
00001000                            10  START       ORG         $1000               ;Start @ address $1000
00001000  4EB9 00001016             11              JSR         DISP_INTRO          ;Display Intro Message
00001006  4EB9 0000143A             12              JSR         INPUT_ADDR          ;Take start and ending address as user input
0000100C  4EB9 00001042             13              JSR         MAIN_LOOP           ;Meat of the program: Check for validity, OPCODE match, and print to screen
00001012                            14                                                          
00001012  6000 00CE                 15              BRA         END                 ;If loop improperly terminated, base case BRA to END program         
00001016                            16  *-Intro Message---------------------------------------------
00001016  43F9 00001142             17  DISP_INTRO  LEA         M_INTRO,A1          ;Load intro msg
0000101C  103C 000E                 18              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001020  4E4F                      19              TRAP        #15                     
00001022                            20      
00001022  4E75                      21              RTS                             ;Return to main START section
00001024                            22              
00001024                            23  *-Press Enter to Continue message---------------------------            
00001024  43F9 000012FA             24  DISP_WAIT   LEA         M_WAIT,A1           ;Load wait message
0000102A  103C 000E                 25              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000102E  4E4F                      26              TRAP        #15
00001030                            27              
00001030  103C 0005                 28              MOVE.B      #5,D0               ;Trap Task 5 takes in a single character input (aka press enter)
00001034  4E4F                      29              TRAP        #15
00001036                            30              
00001036  103C 000B                 31              MOVE.B      #11,D0              ;Clear screen
0000103A  323C FF00                 32              MOVE.W      #$FF00,D1
0000103E  4E4F                      33              TRAP        #15
00001040                            34  
00001040  4E75                      35              RTS        
00001042                            36              
00001042                            37  *-Main Loop-------------------------------------------------
00001042  4EB8 1024                 38  MAIN_LOOP   JSR         DISP_WAIT           ;Display Press Enter to Continue msg
00001046  183C 001A                 39              MOVE.B      #26,D4              ;D4 loop var - print 26 lines per page
0000104A                            40              
0000104A  4EB9 000015D4             41  NEXT_OP     JSR         BUILD_STR           ;Build and accumulate the 0xADDR OPCODE $OPERAND string into memory @ OP_ADDR                            
00001050  4EB9 00001070             42              JSR         PRINT_OP            ;Print the built string to console 
00001056                            43              
00001056  4EB9 00001066             44              JSR         LOOP_COND           ;Check if address is still valid. END program if it isnt
0000105C                            45    
0000105C  5344                      46              SUBI        #1,D4               ;Decrement counter
0000105E  B83C 0000                 47              CMP.B       #0,D4               ;Is counter == 0?
00001062  67DE                      48              BEQ         MAIN_LOOP           ;Then print the next page
00001064                            49              
00001064  60E4                      50              BRA         NEXT_OP             ;Otherwise, in the same page, print the next OP         
00001066                            51  
00001066                            52              
00001066                            53  *-Loop Condition Logic--------------------------------------
00001066  DBC6                      54  LOOP_COND   ADD.L       D6,A5            ;Increment current address (A5) by the length of the last instruction + operand data (D6)
00001068  BCCD                      55              CMPA.W      A5,A6            ;If current address (A5) is now equal to or greater than end address (A6), end
0000106A  6D00 001A                 56              BLT         DSMBL_DONE           ;<---------- check conditional
0000106E                            57              
0000106E  4E75                      58              RTS            
00001070                            59             
00001070                            60  *-Print OPCODE STRING---------------------------------------
00001070  327C 1124                 61  PRINT_OP    MOVE.W      #OP_ADDR,A1         ;Move the OPCODE's beginning addr to A1
00001074  103C 000E                 62              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001078  4E4F                      63              TRAP        #15
0000107A                            64              
0000107A  327C 1436                 65              MOVE.W      #M_NEWLINE,A1       ;Print a new line after this OPCODE line is finished
0000107E  103C 000E                 66              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001082  4E4F                      67              TRAP        #15
00001084                            68              
00001084  4E75                      69              RTS
00001086                            70              
00001086                            71  *-Print to user DONE message--------------------------------
00001086  43F9 0000142E             72  DSMBL_DONE  LEA         M_DONE,A1           ;Print DONE message
0000108C  103C 000E                 73              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001090  4E4F                      74              TRAP        #15 
00001092                            75              
00001092  4EB9 00001098             76              JSR         PROMPT_NEW          ;Ask user if they want to restart
00001098                            77              
00001098                            78  *-Ask user if they want to start program again--------------            
00001098  43F9 000013DC             79  PROMPT_NEW  LEA         M_NPROMPT,A1        ;Ask user if they would like to run program again
0000109E  103C 000E                 80              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000010A2  4E4F                      81              TRAP        #15                     
000010A4                            82              
000010A4  4281                      83              CLR.L       D1                  ;Clear D1
000010A6  103C 0005                 84              MOVE.B      #5,D0               ;Read user input into D1
000010AA  4E4F                      85              TRAP        #15
000010AC                            86              
000010AC  B23C 0079                 87              CMP.B       #'y',D1             ;Is input y
000010B0  6700 0028                 88              BEQ         P_RESTART           ;if so restart program
000010B4                            89              
000010B4  B23C 0059                 90              CMP.B       #'Y',D1             ;Is input Y capital
000010B8  6700 0020                 91              BEQ         P_RESTART           ;if so restart program
000010BC                            92              
000010BC                            93        
000010BC                            94  
000010BC  B23C 006E                 95              CMP.B       #'n',D1             ;Is input n
000010C0  6700 0020                 96              BEQ         END                 ;if so restart program
000010C4                            97              
000010C4  B23C 004E                 98              CMP.B       #'N',D1             ;Is input N capital
000010C8  6700 0018                 99              BEQ         END                 ;if so restart program
000010CC                           100              
000010CC  43F9 0000141B            101              LEA         M_ERR_GEN,A1        ;Input is invalid! Prompt again
000010D2  103C 000E                102              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000010D6  4E4F                     103              TRAP        #15 
000010D8                           104              
000010D8  60BE                     105              BRA         PROMPT_NEW          ;Re prompt            
000010DA                           106  
000010DA  4EB8 1024                107  P_RESTART   JSR         DISP_WAIT
000010DE  6000 FF20                108              BRA         START 
000010E2                           109  *-END-------------------------------------------------------
000010E2  103C 0009                110  END         MOVE.B      #9,D0               ;End program
000010E6  4E4F                     111              TRAP        #15                      
000010E8                           112              
000010E8                           113  *-Variables and constants-----------------------------------
000010E8  =0000000D                114  CR          EQU         $0D
000010E8  =0000000A                115  LF          EQU         $0A
000010E8                           116  
000010E8  =00000002                117  BYTE        EQU         $2
000010E8  =00000004                118  WORD        EQU         $4
000010E8  =00000008                119  LONG        EQU         $8
000010E8                           120  
000010E8                           121  START_ADDR  DS.B        30                  ;Machine code start address stored here
00001106                           122  END_ADDR    DS.B        30                  ;Machine code end address stored here
00001124                           123  
00001124                           124  OP_ADDR     DS.B        30                  ;Storage to accumulate OPCODE address, name, and data string at            
00001142                           125  
00001142                           126  
00001142                           127  *-Strings---------------------------------------------------
00001142= 54 65 61 6D 20 56 ...    128  M_INTRO     DC.B        'Team Visual Basic',CR,LF
00001155= 4D 6F 74 6F 72 6F ...    129              DC.B        'Motorola 68000 Disassembler',CR,LF
00001172= 42 79 20 41 75 73 ...    130              DC.B        'By Austin Abeyta, Dylan Desmond, and Henry Hong',CR,LF,CR,LF,0 
000011A6                           131  
000011A6= 50 6C 65 61 73 65 ...    132  M_IN_RULES  DC.B        'Please limit address input to numeric (0-9) and/or alphabet A-F',CR,LF
000011E7= 50 6C 65 61 73 65 ...    133              DC.B        'Please limit address input to a range of [00005000-FFFFFFFF]!',CR,LF
00001226= 49 6E 70 75 74 20 ...    134              DC.B        'Input less than 8 digits will be padded on left',CR,LF    
00001257= 49 6E 70 75 74 20 ...    135              DC.B        'Input greater than 8 digits will be truncated on the right',CR,LF,CR,LF,0
00001296                           136              
00001296= 50 6C 65 61 73 65 ...    137  M_INPUT_S   DC.B        'Please Input the Starting Address (test code is ORG @ 7F00): ',CR,LF,0
000012D6= 50 6C 65 61 73 65 ...    138  M_INPUT_E   DC.B        'Please Input the Ending Address: ',CR,LF,0
000012FA                           139  
000012FA= 0D 0A 50 72 65 73 ...    140  M_WAIT      DC.B        CR,LF,'Press Enter to Continue!',CR,LF,0
00001317                           141  
00001317= 49 6E 70 75 74 20 ...    142  M_INV_INPUT DC.B        'Input address is invalid! Please re-enter: ',CR,LF,CR,LF,0
00001347                           143  
00001347= 45 52 52 3A 20 53 ...    144  M_ERR_ADDR1 DC.B        'ERR: START address > END address',CR,LF,0
0000136A= 45 52 52 3A 20 53 ...    145  M_ERR_ADDR2 DC.B        'ERR: START address too low, danger of overwriting program logic',CR,LF,0
000013AC= 45 52 52 3A 20 4F ...    146  M_ERR_ADDR3 DC.B        'ERR: ODD START address',CR,LF,0
000013C5= 45 52 52 3A 20 4F ...    147  M_ERR_ADDR4 DC.B        'ERR: ODD END address',CR,LF,0
000013DC                           148  
000013DC= 57 6F 75 6C 64 20 ...    149  M_NPROMPT   DC.B        'Would you like to run program again @ another address? (y/n)',CR,LF,0
0000141B= 0D 0A 49 6E 76 61 ...    150  M_ERR_GEN   DC.B        CR,LF,'Invalid input!',CR,LF,0  
0000142E= 44 6F 6E 65 21 0D ...    151  M_DONE      DC.B        'Done!',CR,LF,0  
00001436                           152  
00001436= 0D 0A 00                 153  M_NEWLINE   DC.B        '',CR,LF,0
00001439                           154                      
00001439                           155              
00001439                           156  
00001439                           157  *-Files-----------------------------------------------------
00001439                           158              INCLUDE     'TeamVisualBasic_Disassembler_Input.X68'            ;Include Input class file
00001439                           159  
0000143A  43F8 11A6                160  INPUT_ADDR  LEA         M_IN_RULES,A1       ;Load input restriction and rules msg
0000143E  103C 000E                161              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001442  4E4F                     162              TRAP        #15                 
00001444                           163  
00001444  43F8 1296                164              LEA         M_INPUT_S,A1        ;Load input request msg
00001448  103C 000E                165              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000144C  4E4F                     166              TRAP        #15
0000144E                           167              
0000144E  43F8 10E8                168              LEA         START_ADDR,A1
00001452  103C 0002                169              MOVE.B      #2,D0               ;Read string from keyboard and store in (A1)
00001456  4E4F                     170              TRAP        #15          
00001458                           171              
00001458  43F8 12D6                172              LEA         M_INPUT_E,A1        ;Load input request msg
0000145C  103C 000E                173              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001460  4E4F                     174              TRAP        #15
00001462                           175              
00001462  43F8 1106                176              LEA         END_ADDR,A1
00001466  103C 0002                177              MOVE.B      #2,D0               ;Read string from keyboard and store in (A1)
0000146A  4E4F                     178              TRAP        #15
0000146C                           179              
0000146C  4EB9 00001474            180              JSR         CNVRT_ADDR          ;Convert user ASCII input into usable hex addresses
00001472                           181  
00001472  4E75                     182              RTS                             ;Return to main START section
00001474                           183  
00001474                           184  
00001474  43F8 10E8                185  CNVRT_ADDR  LEA         START_ADDR,A1       ;Load start address into A1
00001478  163C 0008                186              MOVE.B      #8,D3               ;Load counter var into D3. Count down from 8
0000147C  4EB9 0000149E            187              JSR         C_LOOP
00001482  2A42                     188              MOVE.L      D2,A5               ;Save converted input in (A5)
00001484                           189              
00001484  4282                     190              CLR.L       D2                  ;Clear accumulator
00001486  43F8 1106                191              LEA         END_ADDR,A1         ;Load end address into A1
0000148A  163C 0008                192              MOVE.B      #8,D3               ;Load counter var into D3. Count down from 8
0000148E  4EB9 0000149E            193              JSR         C_LOOP
00001494  2C42                     194              MOVE.L      D2,A6               ;Save converted input in (A6)
00001496                           195                  
00001496  4EB9 0000151A            196              JSR         C_VALIDATE          ;Make sure input is not ODD and end addr is not before start
0000149C  4E75                     197              RTS                             ;Finish by RTSing back to main dissasembler file
0000149E                           198   
0000149E  1019                     199  C_LOOP      MOVE.B      (A1)+,D0            ;Load the ascii digit into D0
000014A0  B03C 00FF                200              CMP.B       #$FF,D0             ;If value is $FF, there is no digit
000014A4  6700 009A                201              BEQ         C_INVALID
000014A8  B03C 0000                202              CMP.B       #$00,D0             ;If value is $00, then probably done
000014AC  6700 0062                203              BEQ         CNVRT_DONE              
000014B0                           204              
000014B0  B63C 0000                205              CMP.B       #0,D3               ;If counter var == 0
000014B4  6700 005A                206              BEQ         CNVRT_DONE
000014B8  5303                     207              SUBI.B      #1,D3               ;Else, decrement counter var
000014BA                           208              
000014BA                           209              ;Determine whether num, upper, or lower case ascii a-f                                    
000014BA  B03C 0030                210              CMP.B       #$30,D0             ;If <30, not a number
000014BE  6D00 0080                211              BLT         C_INVALID           
000014C2  B03C 0046                212              CMP.B       #$46,D0             ;If >46, it's possibly a lowercase letter 
000014C6  6E00 0016                213              BGT         C_IS_LC             ;Check if it's a valid lower ascii letter
000014CA                           214              
000014CA  B03C 0040                215              CMP.B       #$40,D0             ;If <40, must be number
000014CE  6D00 0022                216              BLT         C_NUMERIC
000014D2  B03C 0041                217              CMP.B       #$41,D0             ;If >41, must be upper case ascii
000014D6  6E00 0024                218              BGT         C_ALPHA_U
000014DA                           219  
000014DA  6000 0064                220              BRA         C_INVALID           ;If none of the above, the input is not valid 
000014DE                           221              
000014DE  B03C 0061                222  C_IS_LC     CMP.B       #$61,D0             ;If >61, input is invalid
000014E2  6D00 005C                223              BLT         C_INVALID
000014E6  B03C 0066                224              CMP.B       #$66,D0             ;If >66, input is invalid
000014EA  6E00 0054                225              BGT         C_INVALID
000014EE                           226              
000014EE  6000 0016                227              BRA         C_ALPHA_L           ;Else must be a valid lowercase input
000014F2                           228  
000014F2  0400 0030                229  C_NUMERIC   SUBI.B      #$30,D0             ;Subtract 0x30 to convert to hex
000014F6  E98A                     230              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
000014F8  D400                     231              ADD.B       D0,D2               ;Accumulate digits into D2
000014FA  60A2                     232              BRA         C_LOOP  
000014FC                           233  
000014FC                           234  
000014FC  0400 0037                235  C_ALPHA_U   SUBI.B      #$37,D0             ;Subtract 0x37 to convert to hex
00001500  E98A                     236              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
00001502  D400                     237              ADD.B       D0,D2               ;Accumulate digits into D2
00001504  6098                     238              BRA         C_LOOP
00001506                           239  
00001506  0400 0057                240  C_ALPHA_L   SUBI.B      #$57,D0             ;Subtract 0x57 to convert to hex
0000150A  E98A                     241              LSL.L       #4,D2               ;Shift by 1 digit to make room for next digit
0000150C  D400                     242              ADD.B       D0,D2               ;Accumulate digits into D2
0000150E  608E                     243              BRA         C_LOOP
00001510                           244          
00001510                           245                         
00001510  B63C 0008                246  CNVRT_DONE  CMP.B       #8,D3               ;If no input, invalid
00001514  6700 002A                247              BEQ         C_INVALID           
00001518                           248              
00001518  4E75                     249              RTS                             ;Else, done
0000151A                           250              
0000151A                           251  
0000151A  BDCD                     252  C_VALIDATE  CMPA.L      A5,A6               ;If end address < start address     
0000151C  6D00 002C                253              BLT         C_ERR1
00001520                           254                                                
00001520  BBFC 00005000            255              CMPA.L      #$00005000,A5       ;If start address is <0x5000
00001526  6D00 0036                256              BLT         C_ERR2
0000152A                           257              
0000152A  200D                     258              MOVE.L      A5,D0               ;Check rightmost input address bit
0000152C  0800 0000                259              BTST        #0,D0               ;If rightmost (least sig) bit is 1 (aka ODD address)
00001530  6600 0040                260              BNE         C_ERR3           
00001534                           261              
00001534  200E                     262              MOVE.L      A6,D0               ;Check rightmost input address bit
00001536  0800 0000                263              BTST        #0,D0               ;If rightmost (least sig) bit is 1 (aka ODD address)
0000153A  6600 004A                264              BNE         C_ERR4
0000153E                           265              
0000153E  4E75                     266              RTS                             ;If none of the above, input is valid
00001540                           267              
00001540  4EB9 0000159A            268  C_INVALID   JSR         C_ERR_BASE1         ;Clear screen and clear registers
00001546  6000 007E                269              BRA         C_ERR_BASE2         ;Print generic error msg and branch to start
0000154A                           270  
0000154A  4EB9 0000159A            271  C_ERR1      JSR         C_ERR_BASE1         ;Clear screen and registers
00001550  43F8 1347                272              LEA         M_ERR_ADDR1,A1      ;Load error message
00001554  103C 000E                273              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001558  4E4F                     274              TRAP        #15
0000155A                           275              
0000155A  6000 006A                276              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
0000155E                           277  
0000155E  4EB9 0000159A            278  C_ERR2      JSR         C_ERR_BASE1         ;Clear screen and registers
00001564  43F8 136A                279              LEA         M_ERR_ADDR2,A1      ;Load error message
00001568  103C 000E                280              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
0000156C  4E4F                     281              TRAP        #15
0000156E                           282              
0000156E  6000 0056                283              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
00001572                           284  
00001572                           285  
00001572                           286              
00001572  4EB9 0000159A            287  C_ERR3      JSR         C_ERR_BASE1         ;Clear screen and registers
00001578  43F8 13AC                288              LEA         M_ERR_ADDR3,A1      ;Load error message
0000157C  103C 000E                289              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001580  4E4F                     290              TRAP        #15
00001582                           291              
00001582  6000 0042                292              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
00001586                           293  
00001586  4EB9 0000159A            294  C_ERR4      JSR         C_ERR_BASE1         ;Clear screen and registers
0000158C  43F8 13C5                295              LEA         M_ERR_ADDR4,A1      ;Load error message
00001590  103C 000E                296              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
00001594  4E4F                     297              TRAP        #15
00001596                           298              
00001596  6000 002E                299              BRA         C_ERR_BASE2         ;Print generic err msg, then go back to input loop and ask for new input
0000159A                           300  
0000159A                           301  
0000159A  103C 000B                302  C_ERR_BASE1 MOVE.B      #11,D0              ;Clear screen
0000159E  323C FF00                303              MOVE.W      #$FF00,D1
000015A2  4E4F                     304              TRAP        #15
000015A4                           305              
000015A4  4282                     306              CLR.L       D2
000015A6  4285                     307              CLR.L       D5
000015A8                           308                                
000015A8                           309  
000015A8  21FC FFFFFFFF 10E8       310              MOVE.L      #$FFFFFFFF,(START_ADDR)        
000015B0  21FC FFFFFFFF 1106       311              MOVE.L      #$FFFFFFFF,(END_ADDR)
000015B8  2A7C 00000000            312              MOVEA.L     #$00000000,A5       ;Clear registers
000015BE  2C7C 00000000            313              MOVEA.L     #$00000000,A6 
000015C4                           314       
000015C4  4E75                     315              RTS
000015C6                           316  
000015C6  43F8 1317                317  C_ERR_BASE2 LEA         M_INV_INPUT,A1      ;Load error message
000015CA  103C 000E                318              MOVE.B      #14,D0              ;Trap Task 14 displays null terminated string
000015CE  4E4F                     319              TRAP        #15
000015D0                           320              
000015D0  6000 FA2E                321              BRA         START 
000015D4                           322             
000015D4                           323  
000015D4                           324  
000015D4                           325  
000015D4                           326  -------------------- end include --------------------
000015D4                           327              INCLUDE     'TeamVisualBasic_Disassembler_OutputBuilder.X68'    ;Include OutputBuilder class file
000015D4                           328  
000015D4  4EB9 000015EC            329  BUILD_STR   JSR         PREPARE_OP          ;Define a location in memory to write an OPCODE string to
000015DA  4EB9 000015F2            330              JSR         GET_ADDR            ;Accumulate the OPCODE's address into the A4 string [0xADDR]
000015E0  4EB9 00001632            331              JSR         JT_START            ;Send OPCODE to jump table for decoding [OPCODE $OPERAND]
000015E6  18FC 0000                332              MOVE.B      #0,(A4)+            ;End the string with a 0 delimiter
000015EA                           333              
000015EA  4E75                     334              RTS                             ;Return back to main disassembler loop
000015EC                           335  
000015EC  387C 1124                336  PREPARE_OP  MOVE.W      #OP_ADDR,A4         ;Define a location in memory to write an OPCODE string to
000015F0  4E75                     337              RTS
000015F2                           338              
000015F2  200D                     339  GET_ADDR    MOVE.L      A5,D0               ;Save the address pointer into D0
000015F4  4282                     340              CLR.L       D2                  ;Clear D2
000015F6  143C 0008                341              MOVE.B      #8,D2               ;Counter var starts at 8
000015FA                           342              
000015FA  4EB9 0000160E            343  GA_LOOP     JSR         HEX_2_ASCII         ;Convert the hex to ascii for printing
00001600  5342                     344              SUBI        #1,D2               ;Decrement counter var
00001602  B43C 0000                345              CMP.B       #0,D2               ;Is counter var == 0?
00001606  6EF2                     346              BGT         GA_LOOP             ;If not, loop         
00001608                           347              
00001608  18FC 0009                348              MOVE.B      #09,(A4)+           ;Otherwise, we are done. Append a tab
0000160C  4E75                     349              RTS                             ;Return back to main disassembler loop    
0000160E                           350  
0000160E  E998                     351  HEX_2_ASCII ROL.L       #4,D0               ;Get the most significant hex digit into the right 4 bits
00001610  1200                     352              MOVE.B      D0,D1               ;Save that byte into D1
00001612  0241 000F                353              ANDI        #$0F,D1             ;Isolate the hex digit 
00001616                           354              
00001616  B23C 0009                355              CMP.B       #$9,D1              ;If hex digit is > 9
0000161A  6E00 0006                356              BGT         APPND_ALPHA         ;It is an alphabet ascii char. Branch
0000161E  6000 000A                357              BRA         APPND_NUM           ;Else it is a numeric ascii char. Branch
00001622                           358              
00001622  0601 0037                359  APPND_ALPHA ADDI.B      #$37,D1             ;Add $37 to make it a ascii alphabet char
00001626  18C1                     360              MOVE.B      D1,(A4)+            ;Append this character to string
00001628  4E75                     361              RTS           
0000162A                           362  
0000162A  0601 0030                363  APPND_NUM   ADDI.B      #$30,D1             ;Add $30 to make it a ascii numeric char
0000162E  18C1                     364              MOVE.B      D1,(A4)+            ;Append this character to string
00001630  4E75                     365              RTS
00001632                           366         
00001632                           367  
00001632                           368  
00001632                           369  
00001632                           370  
00001632                           371  
00001632                           372  -------------------- end include --------------------
00001632                           373              INCLUDE     'TeamVisualBasic_JumpTable.X68'                     ;Include Jump Table file
00001632                           374  
00001632  7E04                     375  JT_START    MOVE.L      #WORD,D7            *All OPCODEs takes up a WORD of space, save this into length counter D7
00001634  4286                     376              CLR.L       D6                  *Clear the D6 address increment counter
00001636  3015                     377              MOVE.W      (A5),D0             *Move OPCODE into D0 to bit shift
00001638                           378              
00001638  E848                     379              LSR.W       #4,D0               *Shift right 4 bits
0000163A  E848                     380              LSR.W       #4,D0               *shift right 4 bits
0000163C  E848                     381              LSR.W       #4,D0               *shift right 4 bits
0000163E                           382              
0000163E  0C40 0000                383              CMPI.W      #0,D0               *check if it falls into 0 bin
00001642  6700 007A                384              BEQ         BIN_0
00001646                           385      
00001646  0C40 0001                386              CMPI.W      #1,D0               *check if it is a MOVE
0000164A  6700 00A2                387              BEQ         BIN_MOVE
0000164E                           388              
0000164E  0C40 0002                389              CMPI.W      #2,D0               *check if it is a MOVE
00001652  6700 009A                390              BEQ         BIN_MOVE
00001656                           391              
00001656  0C40 0003                392              CMPI.W      #3,D0               *check if it is a MOVE
0000165A  6700 0092                393              BEQ         BIN_MOVE
0000165E                           394              
0000165E  0C40 0004                395              CMPI.W      #4,D0               *check if it falls into 4 bin
00001662  6700 00A6                396              BEQ         BIN_4
00001666                           397  
00001666  0C40 0005                398              CMPI.W      #5,D0               *check if it falls into 5 bin
0000166A  6700 00DC                399              BEQ         BIN_5
0000166E                           400  
0000166E  0C40 0006                401              CMPI.W      #6,D0               *check if it falls into 6 bin
00001672  6700 00D8                402              BEQ         BIN_6
00001676                           403  
00001676  0C40 0007                404              CMPI.W      #7,D0               *check if it falls into 7 bin
0000167A  6700 010A                405              BEQ         BIN_7
0000167E                           406  
0000167E  0C40 0008                407              CMPI.W      #8,D0               *check if it falls into 8 bin
00001682  6700 0106                408              BEQ         BIN_8
00001686                           409  
00001686  0C40 0009                410              CMPI.W      #9,D0               *check if it falls into 9 bin
0000168A  6700 0112                411              BEQ         BIN_9
0000168E                           412  
0000168E  0C40 000A                413              CMPI.W      #10,D0              *check if it falls into 10 bin
00001692  6700 010E                414              BEQ         BIN_10
00001696                           415  
00001696  0C40 000B                416              CMPI.W      #11,D0              *check if it falls into 11 bin
0000169A  6700 010A                417              BEQ         BIN_11
0000169E                           418  
0000169E  0C40 000C                419              CMPI.W      #12,D0              *check if it falls into 12 bin
000016A2  6700 0120                420              BEQ         BIN_12
000016A6                           421  
000016A6  0C40 000D                422              CMPI.W      #13,D0              *check if it falls into 12 bin
000016AA  6700 011C                423              BEQ         BIN_13
000016AE                           424  
000016AE  0C40 000E                425              CMPI.W      #14,D0              *check if it falls into 14 bin
000016B2  6700 0130                426              BEQ         BIN_14
000016B6                           427  
000016B6  0C40 000F                428              CMPI.W      #15,D0              *check if it falls into 15 bin
000016BA  6700 016E                429              BEQ         BIN_15
000016BE                           430  
000016BE  3015                     431  BIN_0       MOVE.W      (A5),D0             *reload opcode
000016C0  E048                     432              LSR.W       #8,D0               *shift bits to the right 8
000016C2  C07C 000F                433              AND.W       #$0F,D0             *Isolate the last 4 bits
000016C6                           434              
000016C6  0C40 000C                435              CMPI.W      #12,D0              *Check if the bit is C
000016CA  6700 0176                436              BEQ         CMPI                *if CMPI go to the subroutine
000016CE                           437              
000016CE  0C40 0000                438              CMPI.W      #0,D0               *Check if the bit is a 0
000016D2  6700 015A                439              BEQ         ORI                 *if ORI go to the subroutine
000016D6                           440              
000016D6  0C40 0008                441              CMPI.W      #8,D0               *Check if the bit is an 8
000016DA  6700 017E                442              BEQ         BCLR_IM             *if BCLR immediate go to subroutine
000016DE                           443              
000016DE  C07C 0001                444              AND.W       #$01,D0             *isolate the last bit
000016E2  0C40 0001                445              CMPI.W      #1,D0               *Check if the bit is a 1
000016E6  6700 018A                446              BEQ         BCLR_REG            *if BCLR register go to subroutine
000016EA                           447              
000016EA  6000 041C                448              BRA         DATA           
000016EE                           449  
000016EE  3015                     450  BIN_MOVE    MOVE.W      (A5),D0             *reload opcode
000016F0  EC48                     451              LSR.W       #6,D0               *shift bits to the right 6
000016F2  C07C 0007                452              AND.W       #$07,D0             *isolate the last 3 bits
000016F6  0C40 0001                453              CMPI.W      #1,D0               *check if the bits are 001
000016FA  6700 01AC                454              BEQ         MOVEA               *if MOVEA go to SUB
000016FE                           455              
000016FE  0C40 0007                456              CMPI.W      #7,D0               *check if the bits are 111
00001702  6700 0404                457              BEQ         DATA                *if 111 must be DATA
00001706  6000 0182                458              BRA         MOVE                *otherwise must be MOVE
0000170A                           459              
0000170A  3015                     460  BIN_4       MOVE.W      (A5),D0             *reload opcode
0000170C  0C40 4E71                461              CMPI.W      #$4E71,D0           *check for no-op value
00001710  6700 01CC                462              BEQ         NOP                 *if NOP go to SUB
00001714                           463              
00001714  0C40 4E75                464              CMPI.W      #$4E75,D0           *Compare with a constant value for RTS      
00001718  6700 01D4                465              BEQ         RTS                 *if RTS go to RTS subroutine
0000171C                           466              
0000171C  E848                     467              LSR.W       #4,D0               *shift right 4 bits
0000171E  E848                     468              LSR.W       #4,D0               *shift right 4 bits
00001720  C07C 000F                469              AND.W       #$0F,D0             *bitmask first 4 bits  
00001724  0C40 000E                470              CMPI.W      #$E,D0              *compare final masked bits
00001728  6700 0204                471              BEQ         JSR                 *if it equals E it is JSR
0000172C                           472              
0000172C  0C40 0004                473              CMPI.W      #$4,D0              *check for defining bits
00001730  6700 020A                474              BEQ         NEG                 *branch to NEG routine
00001734                           475              
00001734  C07C 0001                476              AND.W       #$1,D0
00001738  0C40 0001                477              CMPI.W      #1,D0
0000173C  6700 01C6                478              BEQ         LEA
00001740                           479              
00001740  0C40 0000                480              CMPI.W      #0,D0
00001744  6700 01CC                481              BEQ         MOVEM
00001748                           482              
00001748  6000 0206                483  BIN_5       BRA         SUBQ                *SUBQ is the only option for this bin so branch to SUB
0000174C                           484  
0000174C  3015                     485  BIN_6       MOVE.W      (A5),D0             *reload fresh op code
0000174E  E848                     486              LSR.W       #4,D0               *shift right 4
00001750  E848                     487              LSR.W       #4,D0               *shift right 4
00001752  C07C 000F                488              AND.W       #$0F,D0             *Finds the condition code of the branch statement through bitmask
00001756                           489              
00001756  0C40 0000                490              CMPI.W      #0,D0               *check if the 4 bits == 0000
0000175A  6700 0252                491              BEQ         BRA_SUB             *branch to BRA SUB
0000175E                           492              
0000175E  0C40 0004                493              CMPI.W      #4,D0
00001762  6700 022E                494              BEQ         BCC                 *branch to BCC code 
00001766                           495                                                                       
00001766  0C40 000D                496              CMPI.W      #$D,D0
0000176A  6700 0234                497              BEQ         BLT                 *branch to BLT SUB            
0000176E                           498                                                                   
0000176E  0C40 0008                499              CMPI.W      #8,D0
00001772  6700 0210                500              BEQ         BVC                 *branch to BVC code
00001776                           501              
00001776  0C40 0005                502              CMPI.W      #5,D0
0000177A  6700 01FA                503              BEQ         BCS                 *branch to BCS code
0000177E                           504              
0000177E  0C40 000C                505              CMPI.W      #$C,D0
00001782  6700 01E4                506              BEQ         BGE                 *branch to BGE code
00001786                           507  
00001786  6000 0380                508  BIN_7       BRA        DATA                *If it goes into this bin it is DATA
0000178A                           509  
0000178A  3015                     510  BIN_8       MOVE.W      (A5),D0
0000178C  EC48                     511              LSR.W       #6,D0
0000178E  C07C 0007                512              AND.W       #$07,D0   
00001792  0C40 0007                513              CMPI.W      #7,D0
00001796  6700 0224                514              BEQ         DIVS_W
0000179A                           515              
0000179A  6000 0238                516              BRA         OR  
0000179E                           517              
0000179E  6000 0244                518  BIN_9       BRA         SUB                 *SUB is the only option for this bin so branch to SUB
000017A2                           519  
000017A2  6000 0364                520  BIN_10      BRA         DATA                *If it goes into this bin it is DATA
000017A6                           521  
000017A6  3015                     522  BIN_11      MOVE.W      (A5),D0             *reload opcode into D0
000017A8  E848                     523              LSR.W       #4,D0               *shift bits to the right 4
000017AA  E848                     524              LSR.W       #4,D0               *Shift bits to the right 4
000017AC  C07C 0001                525              AND.W       #$01,D0             *isolate the last bit
000017B0  0C40 0001                526              CMPI.W      #1,D0               *check if the bit is a 1
000017B4  6700 0242                527              BEQ         EOR                 *if EOR go to the SUB
000017B8                           528              
000017B8  0C40 0000                529              CMPI.W      #0,D0               *check if the bit is a 0
000017BC  6700 024E                530              BEQ         CMP                 *if CMP go to the SUB
000017C0                           531              
000017C0  6000 0346                532              BRA         DATA                *if neither EOR or CMP must be DATA
000017C4                           533              
000017C4  6000 025A                534  BIN_12      BRA         MULS_W              *MULS is the only option for this bin so branch to SUB
000017C8                           535  
000017C8  3015                     536  BIN_13      MOVE.W      (A5),D0             *reload opcode into D0
000017CA  EC48                     537              LSR.W       #6,D0               *shift bits to the right 6
000017CC  C07C 0007                538              AND.W       #$07,D0             *isolate the last 3 bits
000017D0  0C40 0003                539              CMPI.W      #$3,D0              *check if the bits are 011
000017D4  6700 0276                540              BEQ         ADDA                *if ADDA go to SUB        
000017D8                           541              
000017D8  0C40 0007                542              CMPI.W      #$7,D0              *check if the bits are 111
000017DC  6700 026E                543              BEQ         ADDA                *if ADDA go to SUB 
000017E0                           544                                                          
000017E0  6000 0256                545              BRA         ADD                 *if bits are not ADDA must be ADD and go to SUB
000017E4                           546              
000017E4  3015                     547  BIN_14      MOVE.W      (A5),D0             *Reload the opcode
000017E6  E648                     548              LSR.W       #3,D0               *shift bits down
000017E8  C07C 0003                549              AND.W       #$03,D0             *mask bits
000017EC  0C40 0001                550              CMPI.W      #1,D0               *determin which kind of shift it is
000017F0  6700 026C                551              BEQ         LOGIC_REG           *bra to logic shift register mode
000017F4                           552              
000017F4  0C40 0000                553              CMPI.W      #0,D0
000017F8  6700 0280                554              BEQ         ARITH_REG           *bra to arthimetic shift register mode
000017FC                           555              
000017FC  0C40 0003                556              CMPI.W      #3,D0
00001800  6700 028E                557              BEQ         ROTATE_REG          *bra to rotate register mode  
00001804                           558  
00001804  3015                     559              MOVE.W      (A5),D0             *Reload the opcode
00001806  E848                     560              LSR.W       #4,D0               *shift bits down
00001808  EA48                     561              LSR.W       #5,D0               *shift bits a total of 9
0000180A  C07C 0007                562              AND.W       #$07,D0             *mask bits
0000180E  0C40 0001                563              CMPI.W      #1,D0               *determin which kind of shift it is
00001812  6700 0292                564              BEQ         LOGIC_MEM           *bra to logic shift memory mode
00001816                           565              
00001816  0C40 0000                566              CMPI.W      #0,D0
0000181A  6700 02A0                567              BEQ         ARITH_MEM           *bra to arthimetic shift memory mode
0000181E                           568              
0000181E  0C40 0003                569              CMPI.W      #3,D0
00001822  6700 02AE                570              BEQ         ROTATE_MEM          *bra to rotate MEM mode    
00001826                           571              
00001826  6000 02E0                572              BRA         DATA                *if not a shift must be DATA 
0000182A                           573                                                                  
0000182A                           574  
0000182A  6000 02DC                575  BIN_15      BRA        DATA                *IF it goes into this bin it is DATA
0000182E                           576                                                                                               
0000182E                           577  
0000182E                           578  
0000182E  18FC 004F                579  ORI         MOVE.B      #'O',(A4)+          *Load OPCODE string into (A4)
00001832  18FC 0052                580              MOVE.B      #'R',(A4)+
00001836  18FC 0049                581              MOVE.B      #'I',(A4)+
0000183A                           582              
0000183A  4EB9 00001B92            583              JSR         GET_SIZE_67
00001840                           584           
00001840  4E75                     585              RTS                             *Return to OutputBuilder file
00001842                           586              
00001842  18FC 0043                587  CMPI        MOVE.B      #'C',(A4)+          *Load OPCODE string into (A4)
00001846  18FC 004D                588              MOVE.B      #'M',(A4)+
0000184A  18FC 0050                589              MOVE.B      #'P',(A4)+
0000184E  18FC 0049                590              MOVE.B      #'I',(A4)+
00001852                           591              
00001852  4EB9 00001B92            592              JSR         GET_SIZE_67 
00001858                           593     
00001858  4E75                     594              RTS                             *Return to OutputBuilder file
0000185A                           595              
0000185A  18FC 0042                596  BCLR_IM     MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
0000185E  18FC 0043                597              MOVE.B      #'C',(A4)+
00001862  18FC 004C                598              MOVE.B      #'L',(A4)+
00001866  18FC 0052                599              MOVE.B      #'R',(A4)+
0000186A                           600              
0000186A  4EB9 00001C52            601              JSR         APPND_BYTE          *must be a byte if it is a BCLR on immediate data
00001870                           602              
00001870  4E75                     603              RTS                             *Return to OutputBuilder file
00001872                           604              
00001872  18FC 0042                605  BCLR_REG    MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001876  18FC 0043                606              MOVE.B      #'C',(A4)+
0000187A  18FC 004C                607              MOVE.B      #'L',(A4)+
0000187E  18FC 0052                608              MOVE.B      #'R',(A4)+
00001882                           609              
00001882  4EB9 00001C6A            610              JSR         APPND_LONG          *must be a long if it is a BCLR on a register
00001888                           611              
00001888  4E75                     612              RTS                             *Return to OutputBuilder file
0000188A                           613  
0000188A                           614  
0000188A  18FC 004D                615  MOVE        MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
0000188E  18FC 004F                616              MOVE.B      #'O',(A4)+
00001892  18FC 0056                617              MOVE.B      #'V',(A4)+
00001896  18FC 0045                618              MOVE.B      #'E',(A4)+
0000189A                           619              
0000189A  4EB9 00001BD2            620              JSR         MOVE_SIZE           *Append size
000018A0  4EB9 00001C76            621              JSR         DECODE_A            *Append Decode information
000018A6                           622              
000018A6  4E75                     623              RTS                             *Return to OutputBuilder file
000018A8                           624             
000018A8                           625              
000018A8  18FC 004D                626  MOVEA       MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
000018AC  18FC 004F                627              MOVE.B      #'O',(A4)+
000018B0  18FC 0056                628              MOVE.B      #'V',(A4)+
000018B4  18FC 0045                629              MOVE.B      #'E',(A4)+
000018B8  18FC 0041                630              MOVE.B      #'A',(A4)+
000018BC                           631              
000018BC  3015                     632              MOVE.W      (A5),D0             *reload OPCODE into D0
000018BE  E848                     633              LSR.W       #4,D0               *Isolate leftmost hex digit
000018C0  E848                     634              LSR.W       #4,D0
000018C2  E848                     635              LSR.W       #4,D0               *shift bits a total of 12 right
000018C4  C07C 0003                636              AND.W       #$03,D0             *isolate the last 2 bits
000018C8                           637              
000018C8  0C40 0001                638              CMPI.W      #1,D0               *If == 1, invalid OPCODE
000018CC  6700 023A                639              BEQ         DATA                *Operation not supported for MOVEA
000018D0                           640              
000018D0  4EB9 00001BD2            641              JSR         MOVE_SIZE           *Append size
000018D6  4EB9 00001C76            642              JSR         DECODE_A            *Append Decode information
000018DC                           643  
000018DC  4E75                     644              RTS                             *Return to OutputBuilder file
000018DE                           645  
000018DE  5447                     646  NOP         ADDI        #BYTE,D7            *NOP is 2 Bytes; Increment length var by 2
000018E0  18FC 004E                647              MOVE.B      #'N',(A4)+          *Load OPCODE string into (A4)
000018E4  18FC 004F                648              MOVE.B      #'O',(A4)+
000018E8  18FC 0050                649              MOVE.B      #'P',(A4)+
000018EC                           650              
000018EC  4E75                     651              RTS                             *Return to OutputBuilder file
000018EE                           652              
000018EE                           653              
000018EE  18FC 0052                654  RTS         MOVE.B      #'R',(A4)+          *Load OPCODE string into (A4)
000018F2  18FC 0054                655              MOVE.B      #'T',(A4)+
000018F6  18FC 0053                656              MOVE.B      #'S',(A4)+ 
000018FA                           657  
000018FA  1C3C 0004                658              MOVE.B      #WORD,D6            *Increment the size counter D6 by a WORD 
000018FE  1E3C 0004                659              MOVE.B      #WORD,D7            *Increment the size counter D7 by a WORD
00001902                           660              
00001902  4E75                     661              RTS                             *Return to OutputBuilder file
00001904                           662              
00001904  18FC 004C                663  LEA         MOVE.B      #'L',(A4)+          *Load OPCODE string into (A4)
00001908  18FC 0045                664              MOVE.B      #'E',(A4)+
0000190C  18FC 0041                665              MOVE.B      #'A',(A4)+   
00001910                           666          
00001910  4E75                     667              RTS                             *Return to OutputBuilder file
00001912                           668              
00001912  18FC 004D                669  MOVEM       MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
00001916  18FC 004F                670              MOVE.B      #'O',(A4)+
0000191A  18FC 0056                671              MOVE.B      #'V',(A4)+   
0000191E  18FC 0045                672              MOVE.B      #'E',(A4)+
00001922  18FC 004D                673              MOVE.B      #'M',(A4)+
00001926                           674  
00001926  4EB9 00001BB6            675              JSR         MOVEM_SIZE          *Append size
0000192C                           676              
0000192C  4E75                     677              RTS                             *Return to OutputBuilder file
0000192E                           678              
0000192E  18FC 004A                679  JSR         MOVE.B      #'J',(A4)+          *Load OPCODE string into (A4)
00001932  18FC 0053                680              MOVE.B      #'S',(A4)+
00001936  18FC 0052                681              MOVE.B      #'R',(A4)+   
0000193A                           682          
0000193A                           683  
0000193A  4E75                     684              RTS                             *Return to OutputBuilder file
0000193C                           685              
0000193C  18FC 004E                686  NEG         MOVE.B      #'N',(A4)+          *Load OPCODE string into (A4)
00001940  18FC 0045                687              MOVE.B      #'E',(A4)+
00001944  18FC 0047                688              MOVE.B      #'G',(A4)+   
00001948                           689          
00001948  4EB9 00001B92            690              JSR         GET_SIZE_67         *Append size
0000194E                           691              
0000194E  4E75                     692              RTS                             *Return to OutputBuilder file
00001950                           693               
00001950                           694              
00001950  18FC 0053                695  SUBQ        MOVE.B      #'S',(A4)+          *Load OPCODE string into (A4)
00001954  18FC 0055                696              MOVE.B      #'U',(A4)+
00001958  18FC 0042                697              MOVE.B      #'B',(A4)+   
0000195C  18FC 0051                698              MOVE.B      #'Q',(A4)+ 
00001960                           699                                         
00001960  4EB9 00001B92            700              JSR         GET_SIZE_67         *Append size
00001966                           701              
00001966  4E75                     702              RTS                             *Return to OutputBuilder file
00001968                           703             
00001968  18FC 0042                704  BGE         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
0000196C  18FC 0047                705              MOVE.B      #'G',(A4)+
00001970  18FC 0045                706              MOVE.B      #'E',(A4)+   
00001974                           707          
00001974  4E75                     708              RTS                             *Return to OutputBuilder file
00001976                           709              
00001976  18FC 0042                710  BCS         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
0000197A  18FC 0043                711              MOVE.B      #'C',(A4)+
0000197E  18FC 0053                712              MOVE.B      #'S',(A4)+   
00001982                           713          
00001982  4E75                     714              RTS                             *Return to OutputBuilder file
00001984                           715              
00001984  18FC 0042                716  BVC         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001988  18FC 0056                717              MOVE.B      #'V',(A4)+
0000198C  18FC 0043                718              MOVE.B      #'C',(A4)+   
00001990                           719          
00001990  4E75                     720              RTS                             *Return to OutputBuilder file
00001992                           721              
00001992  18FC 0042                722  BCC         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
00001996  18FC 0043                723              MOVE.B      #'C',(A4)+
0000199A  18FC 0043                724              MOVE.B      #'C',(A4)+   
0000199E                           725          
0000199E  4E75                     726              RTS                             *Return to OutputBuilder file
000019A0                           727              
000019A0  18FC 0042                728  BLT         MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
000019A4  18FC 004C                729              MOVE.B      #'L',(A4)+
000019A8  18FC 0054                730              MOVE.B      #'T',(A4)+   
000019AC                           731          
000019AC  4E75                     732              RTS                             *Return to OutputBuilder file
000019AE                           733  
000019AE  18FC 0042                734  BRA_SUB     MOVE.B      #'B',(A4)+          *Load OPCODE string into (A4)
000019B2  18FC 0052                735              MOVE.B      #'R',(A4)+
000019B6  18FC 0041                736              MOVE.B      #'A',(A4)+   
000019BA                           737          
000019BA  4E75                     738              RTS                             *Return to OutputBuilder file
000019BC                           739              
000019BC  18FC 0044                740  DIVS_W      MOVE.B      #'D',(A4)+          *Load OPCODE string into (A4)
000019C0  18FC 0049                741              MOVE.B      #'I',(A4)+
000019C4  18FC 0056                742              MOVE.B      #'V',(A4)+   
000019C8  18FC 0053                743              MOVE.B      #'S',(A4)+
000019CC                           744              
000019CC  4EB9 00001C5E            745              JSR         APPND_WORD
000019D2                           746          
000019D2  4E75                     747              RTS                             *Return to OutputBuilder file
000019D4                           748              
000019D4  18FC 004F                749  OR          MOVE.B      #'O',(A4)+          *Load OPCODE string into (A4)
000019D8  18FC 0052                750              MOVE.B      #'R',(A4)+
000019DC                           751             
000019DC  4EB9 00001BFA            752              JSR         SIZE_678            *Append size
000019E2                           753              
000019E2  4E75                     754              RTS                             *Return to OutputBuilder file
000019E4                           755              
000019E4  18FC 0053                756  SUB         MOVE.B      #'S',(A4)+          *Load OPCODE string into (A4)
000019E8  18FC 0055                757              MOVE.B      #'U',(A4)+
000019EC  18FC 0042                758              MOVE.B      #'B',(A4)+   
000019F0                           759  
000019F0  4EB9 00001BFA            760              JSR         SIZE_678            *Append size
000019F6                           761              
000019F6  4E75                     762              RTS                             *Return to OutputBuilder file
000019F8                           763              
000019F8  18FC 0045                764  EOR         MOVE.B      #'E',(A4)+          *Load OPCODE string into (A4)
000019FC  18FC 004F                765              MOVE.B      #'O',(A4)+
00001A00  18FC 0052                766              MOVE.B      #'R',(A4)+   
00001A04                           767  
00001A04  4EB9 00001B92            768              JSR         GET_SIZE_67         *Append size
00001A0A                           769              
00001A0A  4E75                     770              RTS                             *Return to OutputBuilder file
00001A0C                           771  
00001A0C  18FC 0043                772  CMP         MOVE.B      #'C',(A4)+          *Load OPCODE string into (A4)
00001A10  18FC 004D                773              MOVE.B      #'M',(A4)+
00001A14  18FC 0050                774              MOVE.B      #'P',(A4)+   
00001A18                           775  
00001A18  4EB9 00001B92            776              JSR         GET_SIZE_67         *Append size
00001A1E  4E75                     777              RTS                             *Return to OutputBuilder file
00001A20                           778  
00001A20  18FC 004D                779  MULS_W      MOVE.B      #'M',(A4)+          *Load OPCODE string into (A4)
00001A24  18FC 0055                780              MOVE.B      #'U',(A4)+
00001A28  18FC 004C                781              MOVE.B      #'L',(A4)+   
00001A2C  18FC 0053                782              MOVE.B      #'S',(A4)+
00001A30                           783              
00001A30  4EB9 00001C5E            784              JSR         APPND_WORD
00001A36                           785              
00001A36  4E75                     786              RTS                             *Return to OutputBuilder file
00001A38                           787              
00001A38  18FC 0041                788  ADD         MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
00001A3C  18FC 0044                789              MOVE.B      #'D',(A4)+
00001A40  18FC 0044                790              MOVE.B      #'D',(A4)+   
00001A44                           791              
00001A44  4EB9 00001BFA            792              JSR         SIZE_678            *Append size
00001A4A  4E75                     793              RTS                             *Return to OutputBuilder file
00001A4C                           794              
00001A4C                           795  
00001A4C                           796  
00001A4C  18FC 0041                797  ADDA        MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
00001A50  18FC 0044                798              MOVE.B      #'D',(A4)+
00001A54  18FC 0044                799              MOVE.B      #'D',(A4)+
00001A58  18FC 0041                800              MOVE.B      #'A',(A4)+   
00001A5C                           801                  
00001A5C  4E75                     802              RTS                             *Return to OutputBuilder file
00001A5E                           803       
00001A5E  18FC 004C                804  LOGIC_REG   MOVE.B      #'L',(A4)+          *Load OPCODE string into (A4)
00001A62  18FC 0053                805              MOVE.B      #'S',(A4)+
00001A66                           806                     
00001A66  4EB9 00001AE8            807              JSR         RIGHTORLEFT         *Append (L/R)
00001A6C  4EB9 00001B92            808              JSR         GET_SIZE_67         *Append Size
00001A72                           809              
00001A72  4EB9 00001CA0            810              JSR         DECODE_B
00001A78  4E75                     811              RTS                             *Return to OutputBuilder file           
00001A7A                           812  
00001A7A  18FC 0041                813  ARITH_REG   MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
00001A7E  18FC 0053                814              MOVE.B      #'S',(A4)+
00001A82                           815              
00001A82  4EB9 00001AE8            816              JSR         RIGHTORLEFT         *Append (L/R)
00001A88  4EB9 00001B92            817              JSR         GET_SIZE_67         *Append Size
00001A8E                           818  
00001A8E  4E75                     819              RTS         
00001A90                           820                  
00001A90  18FC 0052                821  ROTATE_REG  MOVE.B      #'R',(A4)+          *Load OPCODE string into (A4)
00001A94  18FC 004F                822              MOVE.B      #'O',(A4)+
00001A98                           823            
00001A98  4EB9 00001AE8            824              JSR         RIGHTORLEFT         *Append (L/R)
00001A9E  4EB9 00001B92            825              JSR         GET_SIZE_67         *Append Size
00001AA4                           826              
00001AA4  4E75                     827              RTS
00001AA6                           828              
00001AA6  18FC 004C                829  LOGIC_MEM   MOVE.B      #'L',(A4)+          *Load OPCODE string into (A4)
00001AAA  18FC 0053                830              MOVE.B      #'S',(A4)+
00001AAE                           831                     
00001AAE  4EB9 00001AE8            832              JSR         RIGHTORLEFT         *Append (L/R)
00001AB4  4EB9 00001C5E            833              JSR         APPND_WORD          *only supports word sized operations on memory
00001ABA                           834              
00001ABA  4E75                     835              RTS                             *Return to OutputBuilder file           
00001ABC                           836  
00001ABC  18FC 0041                837  ARITH_MEM   MOVE.B      #'A',(A4)+          *Load OPCODE string into (A4)
00001AC0  18FC 0053                838              MOVE.B      #'S',(A4)+
00001AC4                           839              
00001AC4  4EB9 00001AE8            840              JSR         RIGHTORLEFT         *Append (L/R)
00001ACA  4EB9 00001C5E            841              JSR         APPND_WORD          *only supports word sized operations on memory
00001AD0                           842  
00001AD0  4E75                     843              RTS         
00001AD2                           844                  
00001AD2  18FC 0052                845  ROTATE_MEM  MOVE.B      #'R',(A4)+          *Load OPCODE string into (A4)
00001AD6  18FC 004F                846              MOVE.B      #'O',(A4)+
00001ADA                           847            
00001ADA  4EB9 00001AE8            848              JSR         RIGHTORLEFT         *Append (L/R)
00001AE0  4EB9 00001C5E            849              JSR         APPND_WORD          *only supports word sized operations on memory
00001AE6                           850              
00001AE6  4E75                     851              RTS
00001AE8                           852                
00001AE8  3010                     853  RIGHTORLEFT MOVE.W      (A0),D0             *reload op
00001AEA  E148                     854              LSL.W       #8,D0               *shift until dr bit is reached
00001AEC  B07C 0000                855              CMP.W       #0,D0               *check if left
00001AF0  6700 000A                856              BEQ         LEFT
00001AF4                           857              
00001AF4  B07C 0001                858              CMP.W       #1,D0               *check if right
00001AF8  6700 0008                859              BEQ         RIGHT  
00001AFC                           860                                                
00001AFC  18FC 004C                861  LEFT        MOVE.B      #'L',(A4)+          *Load directional string 'L' into (A4)
00001B00  4E75                     862              RTS                      
00001B02                           863                       
00001B02  18FC 0052                864  RIGHT       MOVE.B      #'R',(A4)+          *Load directional string 'R' into (A4)
00001B06  4E75                     865              RTS
00001B08                           866                                    
00001B08  18FC 0044                867  DATA        MOVE.B      #'D',(A4)+          *Write DATA into string
00001B0C  18FC 0041                868              MOVE.B      #'A',(A4)+          
00001B10  18FC 0054                869              MOVE.B      #'T',(A4)+          
00001B14  18FC 0041                870              MOVE.B      #'A',(A4)+         
00001B18  18FC 0009                871              MOVE.B      #09,(A4)+           *Write a tab into string
00001B1C                           872              
00001B1C  1C3C 0004                873              MOVE.B      #WORD,D6            *Increment the size counter D6 by a WORD 
00001B20  1E3C 0004                874              MOVE.B      #WORD,D7            *Increment the size counter D7 by a WORD 
00001B24  4EB9 00001B3C            875              JSR         WRITE_DATA          *Write D7 worth of OPCODE data that couldn't be decoded
00001B2A                           876                                    
00001B2A  4E75                     877              RTS                             *Return program flow back to Dissasembler file
00001B2C                           878              
00001B2C  5507                     879  P_OPERAND   SUBI.B      #2,D7               *Subtract 2 from D7 size counter to account for and skip OPCODE's data 
00001B2E  544D                     880              ADDA        #2,A5               *Increment current address pointer to skip over OPCODE
00001B30  4EB9 00001B3C            881              JSR         WRITE_DATA          *WRITE_DATA writes everything after the OPCODE to (A4)
00001B36                           882              
00001B36  5407                     883              ADDI.B      #2,D7               *Add the 2 back to D7 size counter
00001B38  554D                     884              SUBA        #2,A5               *Decrement current address point to point to the start of opcode again
00001B3A                           885              
00001B3A  4E75                     886              RTS
00001B3C                           887              
00001B3C  2607                     888  WRITE_DATA  MOVE.L      D7,D3               *D3 is counter var. Same size as the length specified in D7
00001B3E  0C03 0000                889  WRITE_LOOP  CMPI.B      #0,D3               *is D3 == 0?
00001B42  6700 004A                890              BEQ         WRITE_DONE          *then we are done writing the string 
00001B46                           891              
00001B46  5543                     892              SUBI        #BYTE,D3            *Decrement counter var by 1 byte                       
00001B48                           893  
00001B48  1415                     894              MOVE.B      (A5),D2             *Move 1 byte of OPCODE/OPERAND data into D2                   
00001B4A  E84A                     895              LSR.W       #4,D2               *Isolate left 4 bits of first byte in D1             
00001B4C  4EB9 00001B62            896              JSR         WRITE_DIGIT         *Save the left 4 bits in the byte as an ascii char
00001B52                           897          
00001B52  1415                     898              MOVE.B      (A5),D2             *Move 1 byte of OPCODE/OPERAND data into D2   
00001B54  0202 000F                899              ANDI.B      #$0F,D2             *Isolate right 4 of the first byte in D2                                     
00001B58  4EB9 00001B62            900              JSR         WRITE_DIGIT         *Save the right 4 bits in the byte as an ascii char
00001B5E                           901              
00001B5E  524D                     902              ADDA        #1,A5               *Increment A5
00001B60                           903              
00001B60  60DC                     904              BRA         WRITE_LOOP          *Go to start of loop, and write the next bytes worth of digits          
00001B62                           905                     
00001B62  B43C 0009                906  WRITE_DIGIT CMP.B       #$09,D2             *Is D2 alphabet or number?
00001B66  6E00 0006                907              BGT         W_ALPHA             *If D2 > #$09, it's alphabet
00001B6A  6000 000A                908              BRA         W_NUM               *Else its numeric             
00001B6E                           909              
00001B6E  4EB9 00001B7E            910  W_ALPHA     JSR         CNVRT_ALPHA         *Convert the half byte to ascii, and write to string
00001B74  4E75                     911              RTS                             *Go back to write_loop
00001B76                           912  
00001B76  4EB9 00001B7E            913  W_NUM       JSR         CNVRT_ALPHA         *Convert the half byte to ascii, and write to string
00001B7C  4E75                     914              RTS                             *Go back to write_loop           
00001B7E                           915              
00001B7E  0602 0037                916  CNVRT_ALPHA ADDI.B      #$37,D2             *Convert to ASCII
00001B82  18C2                     917              MOVE.B      D2,(A4)+            *Write to string
00001B84  4E75                     918              RTS
00001B86                           919  
00001B86  0602 0030                920  CNVRT_NUM   ADDI.B      #$30,D2             *Convert to ASCII
00001B8A  18C2                     921              MOVE.B      D2,(A4)+            *Write to string
00001B8C  4E75                     922              RTS           
00001B8E                           923              
00001B8E  9AC7                     924  WRITE_DONE  SUB.W       D7,A5               *Bring A5 pointer back to where it was before writing the DATA
00001B90  4E75                     925              RTS                             *Finished writing       
00001B92                           926  
00001B92                           927  
00001B92  3015                     928  GET_SIZE_67 MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001B94  EC48                     929              LSR.W       #6,D0               *shift bits right 6
00001B96  C07C 0003                930              AND.W       #$03,D0             *Isolate last 2 bits
00001B9A  0C40 0000                931              CMPI.W      #0,D0
00001B9E  6700 00B2                932              BEQ         APPND_BYTE          *Is a Byte operation
00001BA2  0C40 0001                933              CMPI.W      #1,D0
00001BA6  6700 00B6                934              BEQ         APPND_WORD          *Is a Word operation
00001BAA  0C40 0002                935              CMPI.W      #2,D0
00001BAE  6700 00BA                936              BEQ         APPND_LONG          *Is a Long operation
00001BB2  6000 FF54                937              BRA         DATA                *Not a valid size must be data 
00001BB6                           938  
00001BB6  3015                     939  MOVEM_SIZE  MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001BB8  EC48                     940              LSR.W       #6,D0               *shift bits right 6
00001BBA  C07C 0001                941              AND.W       #$01,D0             *isolate last bit
00001BBE  0C40 0000                942              CMPI.W      #0,D0
00001BC2  6700 009A                943              BEQ         APPND_WORD          *is a word operation
00001BC6  0C40 0001                944              CMPI.W      #1,D0
00001BCA  6700 009E                945              BEQ         APPND_LONG          *is a long operation
00001BCE  6000 FF38                946              BRA         DATA
00001BD2                           947              
00001BD2  3015                     948  MOVE_SIZE   MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001BD4  E848                     949              LSR.W       #4,D0               *shift bits right 4
00001BD6  E848                     950              LSR.W       #4,D0
00001BD8  E848                     951              LSR.W       #4,D0               *shift bits a total of 12 right
00001BDA  C07C 0003                952              AND.W       #$03,D0             *isolate the last 2 bits
00001BDE  0C40 0001                953              CMPI.W      #1,D0               
00001BE2  6700 006E                954              BEQ         APPND_BYTE          *is a byte operation
00001BE6  0C40 0003                955              CMPI.W      #3,D0               
00001BEA  6700 0072                956              BEQ         APPND_WORD          *is a word operation
00001BEE  0C40 0002                957              CMPI.W      #2,D0               
00001BF2  6700 0076                958              BEQ         APPND_LONG          *is a long operation
00001BF6  6000 FF10                959              BRA         DATA
00001BFA                           960              
00001BFA  3015                     961  SIZE_678    MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001BFC  EC48                     962              LSR.W       #6,D0               *shift the bits right 6
00001BFE  C07C 0007                963              AND.W       #$07,D0             *isolate the last 3 bits
00001C02  0C40 0000                964              CMPI.W      #0,D0               
00001C06  6700 004A                965              BEQ         APPND_BYTE          *is a byte operation
00001C0A  0C40 0004                966              CMPI.W      #4,D0
00001C0E  6700 0042                967              BEQ         APPND_BYTE          *is a byte operation
00001C12  0C40 0001                968              CMPI.W      #1,D0               
00001C16  6700 0046                969              BEQ         APPND_WORD          *is a word operation
00001C1A  0C40 0005                970              CMPI.W      #5,D0               
00001C1E  6700 003E                971              BEQ         APPND_WORD          *is a word operation
00001C22  0C40 0002                972              CMPI.W      #2,D0
00001C26  6700 0042                973              BEQ         APPND_LONG          *is a long operation
00001C2A  0C40 0006                974              CMPI.W      #6,D0
00001C2E  6700 003A                975              BEQ         APPND_LONG          *is a long operation
00001C32  6000 FED4                976              BRA         DATA                *is not one of the supported sizes
00001C36                           977              
00001C36  3015                     978  ADDA_SIZE   MOVE.W      (A5),D0             *reload OPCODE into (A5)
00001C38  EC48                     979              LSR.W       #6,D0               *shift the bits right 6
00001C3A  C07C 0007                980              AND.W       #$07,D0             *isolate the last 3 bits
00001C3E  0C40 0003                981              CMPI.W      #3,D0
00001C42  6700 001A                982              BEQ         APPND_WORD          *is a word operation
00001C46  0C40 0007                983              CMPI.W      #7,D0
00001C4A  6700 001E                984              BEQ         APPND_LONG          *is a long operation
00001C4E  6000 FEB8                985              BRA         DATA                *is not one of the supported sizes
00001C52                           986                     
00001C52                           987  
00001C52  18FC 002E                988  APPND_BYTE  MOVE.B      #'.',(A4)+
00001C56  18FC 0042                989              MOVE.B      #'B',(A4)+          *load size into (A4)
00001C5A  5407                     990              ADDI.B      #2,D7               *add OPCODE length to D7
00001C5C  4E75                     991              RTS
00001C5E                           992  
00001C5E  18FC 002E                993  APPND_WORD  MOVE.B      #'.',(A4)+
00001C62  18FC 0057                994              MOVE.B      #'W',(A4)+          *load size into (A4)
00001C66  5807                     995              ADDI.B      #4,D7               *add OPCODE length to D7
00001C68  4E75                     996              RTS
00001C6A                           997  
00001C6A  18FC 002E                998  APPND_LONG  MOVE.B      #'.',(A4)+
00001C6E  18FC 004C                999              MOVE.B      #'L',(A4)+          *load size into (A4)
00001C72  5007                    1000              ADDI.B      #8,D7               *add OPCODE length to D7
00001C74  4E75                    1001              RTS                
00001C76                          1002              
00001C76                          1003              INCLUDE     'TeamVisualBasic_OP_Decoder.X68'    ;Helper file for jump table
00001C76                          1004  
00001C76                          1005  
00001C76                          1006  
00001C76  18FC 0009               1007  DECODE_A    MOVE.B      #9,(A4)+          *tab after op code
00001C7A  3C3C 0002               1008              MOVE.W      #2,D6               *Initilize opcode length to 2
00001C7E  3415                    1009              MOVE.W      (A5),D2             *Copy OPCODE into D2
00001C80  E64A                    1010              LSR.W       #3,D2               *Shift right 3 - isolate Src Mode
00001C82  C47C 0007               1011              AND.W       #$0007,D2           *Mask out other bits
00001C86  4EB9 00001E3A           1012              JSR         GET_SRCMODE         *Append SRC string to (A4)          
00001C8C  18FC 002C               1013              MOVE.B      #',',(A4)+
00001C90                          1014              
00001C90  3415                    1015              MOVE.W      (A5),D2             *Recopy OPCODE into D2  
00001C92  EC4A                    1016              LSR.W       #6,D2               *Shift right 6 - isolate Dest Mode
00001C94  C47C 0007               1017              AND.W       #$0007,D2           *Mask out other bits
00001C98  4EB9 00001E7A           1018              JSR         GET_DSTMODE         *Append DST string to (A4)
00001C9E                          1019              
00001C9E  4E75                    1020              RTS                             *Return back to jump table
00001CA0                          1021  
00001CA0                          1022                 
00001CA0  18FC 0009               1023  DECODE_B    MOVE.B      #9,(A4)+          *tab after op code
00001CA4  3C3C 0002               1024              MOVE.W      #2,D6             *Initilize opcode length to 2
00001CA8  3415                    1025              MOVE.W      (A5),D2           *reload op code
00001CAA  EC4A                    1026              LSR.W       #6,D2              
00001CAC  C47C 0003               1027              AND.W       #$0003,D2
00001CB0  B47C 0003               1028              CMP.W       #3,D2
00001CB4  6700 001C               1029              BEQ         B_ADDMODE
00001CB8  3A15                    1030              MOVE.W      (A5),D5             
00001CBA  EA4D                    1031              LSR.W       #5,D5              *logical shift left to get i/r
00001CBC  CA7C 0001               1032              AND.W       #$0001,D5           
00001CC0  BA7C 0000               1033              CMP.W       #0,D5
00001CC4  6700 002A               1034              BEQ         B_SCOUNT
00001CC8  BA7C 0001               1035              CMP.W       #1,D5
00001CCC  6700 0040               1036              BEQ         B_DATAREG           
00001CD0  4E75                    1037              RTS
00001CD2                          1038  
00001CD2                          1039  B_ADDMODE
00001CD2  3415                    1040             MOVE.W       (A5),D2
00001CD4  E64A                    1041             LSR.W        #3,D2
00001CD6  C47C 0007               1042             AND.W        #$0007,D2
00001CDA  4EB9 00001E7A           1043             JSR          GET_DSTMODE
00001CE0  3415                    1044             MOVE.W       (A5),D2
00001CE2  C47C 0007               1045             AND.W        #$0007,D2
00001CE6  3A02                    1046             MOVE.W       D2,D5
00001CE8  4EB9 0000206C           1047             JSR          PrintD5Num
00001CEE  4E75                    1048             RTS
00001CF0                          1049              
00001CF0                          1050              
00001CF0                          1051  
00001CF0  3415                    1052  B_SCOUNT    MOVE.W      (A5),D2
00001CF2  EC4A                    1053              LSR.W       #6,D2
00001CF4  E64A                    1054              LSR.W       #3,D2
00001CF6  C47C 0007               1055              AND.W       #$0007,D2
00001CFA  3A02                    1056              MOVE.W      D2,D5
00001CFC  18FC 0023               1057              MOVE.B      #'#',(A4)+
00001D00  4EB9 0000206C           1058              JSR         PrintD5Num
00001D06  4EB9 00001D26           1059              JSR         B_SRC_DMODE
00001D0C  4E75                    1060              RTS
00001D0E                          1061     
00001D0E  18FC 0044               1062  B_DATAREG   MOVE.B      #'D',(A4)+
00001D12  3415                    1063              MOVE.W      (A5),D2
00001D14  EC4A                    1064              LSR.W       #6,D2
00001D16  E64A                    1065              LSR.W       #3,D2
00001D18  C47C 0007               1066              AND.W       #$0007,D2
00001D1C  3A02                    1067              MOVE.W      D2,D5
00001D1E  4EB9 0000206C           1068              JSR         PrintD5Num
00001D24  4E75                    1069              RTS
00001D26  3415                    1070  B_SRC_DMODE MOVE.W      (A5),D2             *reload op
00001D28  18FC 002C               1071              MOVE.B      #',',(A4)+          *add comma to printer
00001D2C  18FC 0044               1072              MOVE.B      #'D',(A4)+          *D for data register
00001D30  C47C 0007               1073              AND.W       #0007,D2            *mask out other bits
00001D34  3A02                    1074              MOVE.W      D2,D5               *move register number to d5
00001D36  4EB9 0000206C           1075              JSR         Printd5Num          *print register numebr
00001D3C  4E75                    1076              RTS
00001D3E                          1077    
00001D3E  18FC 0009               1078  DECODE_C    MOVE.B      #9,(A4)+          *tab after op code
00001D42  3C3C 0002               1079              MOVE.W      #2,D6               *Initilize opcode length to 2
00001D46  3415                    1080              MOVE.W      (A5),D2
00001D48                          1081              *ENTER PRINT DATA CODE HERE
00001D48  4EB9 00001D4E           1082              JSR         C_SRC
00001D4E                          1083              
00001D4E                          1084  
00001D4E                          1085  
00001D4E                          1086  
00001D4E  3415                    1087  C_SRC       MOVE.W      (A5),D2
00001D50  E64A                    1088              LSR.W       #3,D2
00001D52  C47C 0007               1089              AND.W       #$0007,D2
00001D56  4EB9 00001E7A           1090              JSR         GET_DSTMODE
00001D5C  3415                    1091              MOVE.W      (A5),D2
00001D5E  C47C 0007               1092              AND.W       #$0007,D2
00001D62  4EB9 00001E3A           1093              JSR         GET_SRCMODE
00001D68  4E75                    1094              RTS
00001D6A                          1095  
00001D6A                          1096  
00001D6A                          1097     
00001D6A  18FC 0009               1098  DECODE_D    MOVE.B      #9,(A4)+          *tab after op code
00001D6E  3C3C 0002               1099              MOVE.W      #2,D6               *Initilize opcode length to 2   
00001D72  1C3C 0023               1100              MOVE.B      #'#',D6
00001D76  1C3C 0024               1101              MOVE.B      #'$',D6     
00001D7A  343C 0002               1102              MOVE.W      #2,D2               *move counter to 2 since only 2 HEX values used
00001D7E  E14A                    1103              LSL.W       #8,D2               *set up data for printers
00001D80  4EB9 000020B4           1104              JSR         GD_LOOP             *print hex the 2 bits
00001D86  4E75                    1105              RTS
00001D88                          1106  
00001D88                          1107    
00001D88  18FC 0039               1108  DECODE_E    MOVE.B      #'9',(A4)+          *tab after op code
00001D8C  3C3C 0002               1109              MOVE.W      #2,D6               *Initilize opcode length to 2
00001D90  3415                    1110              MOVE.W      (A5),D2
00001D92  E74A                    1111              LSL.W       #3,D2               *GRAB SOURCE MODE BITS
00001D94  C47C 0007               1112              AND.W       #$0007,D2           *Mask out other bits
00001D98  4EB9 00001E3A           1113              JSR         GET_SRCMODE         *Append SRC string to (A4)          
00001D9E  18FC 002C               1114              MOVE.B      #',',(A4)+          *Addd comma for out put
00001DA2  3415                    1115              MOVE.W      (A5),D2
00001DA4  ED4A                    1116              LSL.W       #6,D2               *logical shift left to get data bits to d2
00001DA6  E74A                    1117              LSL.W       #3,D2
00001DA8  C478 0007               1118              AND.W       $0007,D2            *mask out other bits
00001DAC  18FC 0044               1119              MOVE.B      #'D',(A4)+          *Push D into register
00001DB0  3A02                    1120              MOVE.W      D2,D5
00001DB2  4EB9 0000206C           1121              JSR         PrintD5Num          *print register number
00001DB8                          1122                    
00001DB8                          1123  
00001DB8                          1124  
00001DB8                          1125    
00001DB8  3C3C 0002               1126  DECODE_F    MOVE.W      #2,D6               *Initilize opcode length to 2
00001DBC  3415                    1127              MOVE.W      (A5),D2             *Copy opcode into d2
00001DBE  ED4A                    1128              LSL.W       #6,D2               *Shift to grab op mode
00001DC0  C47C 0007               1129              AND.W       #$0007,D2           *Mask other bits
00001DC4  4EB9 00001DD8           1130              JSR         F_OPMODE
00001DCA  3415                    1131              MOVE.W      (A5),D2             *Recopy OPCODE into D2  
00001DCC  EC4A                    1132              LSR.W       #6,D2               *Shift right 6 - isolate Dest Mode
00001DCE  C47C 0007               1133              AND.W       #$0007,D2           *Mask out other bits
00001DD2  4EB9 00001E7A           1134              JSR         GET_DSTMODE         *Append DST string to (A4)
00001DD8                          1135  
00001DD8                          1136  
00001DD8                          1137             *Check for the size of the OPCODE
00001DD8                          1138              
00001DD8                          1139  F_OPMODE
00001DD8                          1140  
00001DD8                          1141  
00001DD8  3C3C 0002               1142  D_MOVEQ     MOVE.W      #2,D6               *Initilize opcode length to 2
00001DDC  3015                    1143              MOVE.W      (A5),D0             *grab op code from a5
00001DDE  18FC 0023               1144              MOVE.B      #'#',(A4)+          *preload source string for literal
00001DE2  18FC 0024               1145              MOVE.B      #'$',(A4)+          *preload source string for hex
00001DE6  343C 0002               1146              MOVE.W      #2,D2               *move 8 to counter since this si long data 8 hex values are required
00001DEA  E14A                    1147              LSL.W       #8,D2               *shift over 8 so bits in high order for print
00001DEC  4EB9 000020B4           1148              JSR         GD_LOOP
00001DF2  4EB8 1D0E               1149              JSR         B_DATAREG           *grabs and prints data reg 
00001DF6  4E75                    1150              RTS
00001DF8                          1151  
00001DF8  3C3C 0002               1152  D_ADDQ      MOVE.W      #2,D6               *Initilize opcode length to 2
00001DFC  3015                    1153              MOVE.W      (A5),D0             *grab op code from a5
00001DFE  18FC 0023               1154              MOVE.B      #'#',(A4)+          *preload source string for literal
00001E02  18FC 0024               1155              MOVE.B      #'$',(A4)+          *preload source string for hex
00001E06  343C 0001               1156              MOVE.W      #1,D2               *move counter to 1 since only 1 bit is used
00001E0A  E54A                    1157              LSL.W       #2,D2               *set up data for printer
00001E0C  0642 C000               1158              ADD.W       #$C000,D2           *mask out first bits
00001E10  4EB9 000020B4           1159              JSR         GD_LOOP             *print hex the 2 bits
00001E16  3415                    1160              MOVE.W      (A5),D2             *reload op code from a5
00001E18  E74A                    1161              LSL.W       #3,D2               *shift so source mode is in LSBs  
00001E1A  C47C 0007               1162              AND.W       #$0007,D2           *mask out other bits
00001E1E  4EB9 00001E3A           1163              JSR         GET_SRCMODE         *print source mode
00001E24  4E75                    1164              RTS
00001E26                          1165              
00001E26  3C3C 0002               1166  D_JSR       MOVE.W      #2,D6               *Initilize opcode length to 2
00001E2A  3415                    1167              MOVE.W      (A5),D2             *reload op code from a5
00001E2C  E74A                    1168              LSL.W       #3,D2               *shift so source mode is in LSBs  
00001E2E  C47C 0007               1169              AND.W       #$0007,D2           *mask out other bits
00001E32  4EB9 00001E3A           1170              JSR         GET_SRCMODE         *print source mode
00001E38  4E75                    1171              RTS
00001E3A                          1172  
00001E3A                          1173  
00001E3A                          1174              
00001E3A                          1175              
00001E3A                          1176            
00001E3A                          1177              
00001E3A                          1178               
00001E3A                          1179  
00001E3A                          1180  
00001E3A  B47C 0000               1181  GET_SRCMODE CMP.W       #0,D2
00001E3E  6700 007A               1182              BEQ         SregMode        *register mode: Dn
00001E42  B47C 0001               1183              CMP.W       #1,D2
00001E46  6700 0084               1184              BEQ         SaddMode        *address mode ---An
00001E4A  B47C 0002               1185              CMP.W       #2,D2
00001E4E  6700 008E               1186              BEQ         SaddINmode      *addres indirect mode ---(An)
00001E52  B47C 0003               1187              CMP.W       #3,D2
00001E56  6700 00A0               1188              BEQ         SaddINpre       *addess indirect pre dec ----(An)
00001E5A  B47C 0004               1189              CMP.W       #4,D2
00001E5E  6700 00B6               1190              BEQ         SaddINpost      *address indirect post inc --- (An)+
00001E62  B47C 0005               1191              CMP.W       #5,D2
00001E66  6700 00CC               1192              BEQ         S16An           *source number of word size --- (d16,An)
00001E6A  B47C 0006               1193              CMP.W       #6,D2
00001E6E  6700 00C4               1194              BEQ         S8AnXn          *source number byte size --- (d8,An,Xn)
00001E72  B47C 0007               1195              CMP.W       #7,D2
00001E76  6700 00BC               1196              BEQ         S_DATA_MODE     *immediate data
00001E7A                          1197      
00001E7A                          1198  
00001E7A  B47C 0000               1199  GET_DSTMODE CMP.W       #0,D2
00001E7E  6700 00F6               1200              BEQ         DregMode        *register mode ---Dn
00001E82  B47C 0001               1201              CMP.W       #1,D2
00001E86  6700 0100               1202              BEQ         DaddMode        *address mode ---An
00001E8A  B47C 0002               1203              CMP.W       #2,D2
00001E8E  6700 010A               1204              BEQ         DaddINmode      *addres indirect mode ---(An)
00001E92  B47C 0003               1205              CMP.W       #3,D2
00001E96  6700 011C               1206              BEQ         DaddINpre       *addess indirect pre dec ----(An)
00001E9A  B47C 0004               1207              CMP.W       #4,D2
00001E9E  6700 0132               1208              BEQ         DaddINpost      *address indirect post inc --- (An)+
00001EA2  B47C 0005               1209              CMP.W       #5,D2
00001EA6  6700 0148               1210              BEQ         D16An           *source number of word size --- (d16,An)
00001EAA  B47C 0006               1211              CMP.W       #6,D2
00001EAE  6700 0140               1212              BEQ         D8AnXn          *source number byte size --- (d8,An,Xn)
00001EB2  B47C 0007               1213              CMP.W       #7,D2           
00001EB6  6700 0138               1214              BEQ         D_DATA_MODE     *Source is immediate data following the opcode
00001EBA                          1215      
00001EBA                          1216   
00001EBA  18FC 0044               1217  SregMode    MOVE.B      #'D',(A4)+
00001EBE  4EB9 00002054           1218              JSR         T1_GrabSreg
00001EC4  4EB9 0000206C           1219              JSR         PrintD5Num   
00001ECA  4E75                    1220              RTS  
00001ECC                          1221          
00001ECC  18FC 0041               1222  SaddMode    MOVE.B      #'A',(A4)+
00001ED0  4EB9 00002054           1223              JSR         T1_GrabSreg
00001ED6  4EB9 0000206C           1224              JSR         PrintD5Num
00001EDC  4E75                    1225              RTS
00001EDE                          1226      
00001EDE                          1227      
00001EDE                          1228      
00001EDE  18FC 0028               1229  SaddInMode  MOVE.B      #'(',(A4)+
00001EE2  18FC 0041               1230              MOVE.B      #'A',(A4)+
00001EE6  4EB9 00002054           1231              JSR         T1_GrabSreg
00001EEC  4EB9 0000206C           1232              JSR         PrintD5Num
00001EF2  18FC 0029               1233              MOVE.B      #')',(A4)+
00001EF6  4E75                    1234              RTS
00001EF8                          1235      
00001EF8  18FC 002D               1236  SaddINpre   MOVE.B      #'-',(A4)+
00001EFC  18FC 0028               1237              MOVE.B      #'(',(A4)+
00001F00  18FC 0041               1238              MOVE.B      #'A',(A4)+
00001F04  4EB9 00002054           1239              JSR         T1_GrabSreg
00001F0A  4EB9 0000206C           1240              JSR         PrintD5Num
00001F10  18FC 0029               1241              MOVE.B      #')',(A4)+
00001F14  4E75                    1242              RTS
00001F16                          1243      
00001F16  18FC 0028               1244  SaddINpost  MOVE.B      #'(',(A4)+
00001F1A  18FC 0041               1245              MOVE.B      #'A',(A4)+
00001F1E  4EB9 00002054           1246              JSR         T1_GrabSreg
00001F24  4EB9 0000206C           1247              JSR         PrintD5Num
00001F2A  18FC 0029               1248              MOVE.B      #')',(A4)+
00001F2E  18FC 002B               1249              MOVE.B      #'+',(A4)+
00001F32  4E75                    1250              RTS
00001F34                          1251      
00001F34                          1252  S16An
00001F34                          1253  S8AnXn
00001F34  4EB9 0000205E           1254  S_DATA_MODE JSR         T1_GrabDreg
00001F3A  0C45 0001               1255              CMPI.W      #1,D5
00001F3E  6700 00CA               1256              BEQ         LONG_DATA
00001F42  0C45 0002               1257              CMPI.W      #2,D5
00001F46  6700 00C2               1258              BEQ         LONG_DATA
00001F4A  BA7C 0000               1259              CMP.W       #0,D5  
00001F4E  6700 00D2               1260              BEQ         WORD_DATA
00001F52  BA7C 0004               1261              CMP.W       #4,D5
00001F56  6700 0002               1262              BEQ         IMMEDIATE_D
00001F5A                          1263              
00001F5A  18FC 0023               1264  IMMEDIATE_D MOVE.B      #'#',(A4)+              *add the # to data string to immediate data
00001F5E                          1265              
00001F5E  BE7C 0008               1266              CMP.W       #8,D7
00001F62  6700 00BE               1267              BEQ         WORD_DATA               *means the immediate data is a word value
00001F66                          1268              
00001F66  BE7C 000C               1269              CMP.W       #12,D7       
00001F6A  6700 009E               1270              BEQ         LONG_DATA               *means the immediate data is a long value
00001F6E                          1271              
00001F6E  BE7C 0006               1272              CMP.W       #6,D7
00001F72  6700 00C6               1273              BEQ         BYTE_DATA             *means the immediate data is a long value
00001F76                          1274              
00001F76                          1275               
00001F76  18FC 0044               1276  DregMode    MOVE.B      #'D',(A4)+
00001F7A  4EB9 0000205E           1277              JSR         T1_GrabDreg
00001F80  4EB9 0000206C           1278              JSR         PrintD5Num   
00001F86  4E75                    1279              RTS
00001F88                          1280           
00001F88  18FC 0041               1281  DaddMode    MOVE.B      #'A',(A4)+
00001F8C  4EB9 0000205E           1282              JSR         T1_GrabDreg
00001F92  4EB9 0000206C           1283              JSR         PrintD5Num
00001F98  4E75                    1284              RTS
00001F9A                          1285      
00001F9A                          1286      
00001F9A                          1287      
00001F9A  18FC 0028               1288  DaddInMode  MOVE.B      #'(',(A4)+
00001F9E  18FC 0041               1289              MOVE.B      #'A',(A4)+
00001FA2  4EB9 0000205E           1290              JSR         T1_GrabDreg
00001FA8  4EB9 0000206C           1291              JSR         PrintD5Num
00001FAE  18FC 0029               1292              MOVE.B      #')',(A4)+
00001FB2  4E75                    1293              RTS
00001FB4                          1294      
00001FB4  18FC 002D               1295  DaddINpre   MOVE.B      #'-',(A4)+
00001FB8  18FC 0028               1296              MOVE.B      #'(',(A4)+
00001FBC  18FC 0041               1297              MOVE.B      #'A',(A4)+
00001FC0  4EB9 0000205E           1298              JSR         T1_GrabDreg
00001FC6  4EB9 0000206C           1299              JSR         PrintD5Num
00001FCC  18FC 0029               1300              MOVE.B      #')',(A4)+
00001FD0  4E75                    1301              RTS
00001FD2                          1302      
00001FD2  18FC 0028               1303  DaddINpost  MOVE.B      #'(',(A4)+
00001FD6  18FC 0041               1304              MOVE.B      #'A',(A4)+
00001FDA  4EB9 0000205E           1305              JSR         T1_GrabDreg
00001FE0  4EB9 0000206C           1306              JSR         PrintD5Num
00001FE6  18FC 0029               1307              MOVE.B      #')',(A4)+
00001FEA  18FC 002B               1308              MOVE.B      #'+',(A4)+
00001FEE  4E75                    1309              RTS
00001FF0                          1310      
00001FF0                          1311  D16An
00001FF0                          1312              
00001FF0                          1313  D8AnXn
00001FF0                          1314  
00001FF0  4EB9 0000205E           1315  D_DATA_MODE JSR         T1_GrabDreg
00001FF6  0C45 0001               1316              CMPI.W      #1,D5
00001FFA  6700 000E               1317              BEQ         LONG_DATA
00001FFE  0C45 0000               1318              CMPI.W      #0,D5
00002002  6700 001E               1319              BEQ         WORD_DATA
00002006  0C45 0007               1320              CMPI.W      #7,D5
0000200A                          1321              *BEQ         DATA_SIZE
0000200A                          1322              
0000200A                          1323  
0000200A                          1324  
0000200A  18FC 0024               1325  LONG_DATA   MOVE.B      #'$',(A4)+       *prepare the string for a long hex value
0000200E  264D                    1326              MOVE.L      A5,A3
00002010                          1327      
00002010  D7C6                    1328              ADD.L       D6,A3           *Add opcode data length this increments the address past the op code and existing data
00002012  2013                    1329              MOVE.L      (A3),D0
00002014                          1330              
00002014  343C 0008               1331              MOVE.W      #8,D2           *move 8 to counter since this si long data 8 hex values are required
00002018  4EB9 000020B4           1332              JSR         GD_LOOP
0000201E  5846                    1333              ADD.W       #4,D6           *since it is long data increment the address by 4 bits *d6 is opcode length counter
00002020  4E75                    1334              RTS
00002022                          1335  
00002022  18FC 0024               1336  WORD_DATA   MOVE.B      #'$',(A4)+       *prepare the string for a long hex value
00002026  264D                    1337              MOVE.L      A5,A3    
00002028                          1338              
00002028  D7C6                    1339              ADD.L       D6,A3           *Add opcode data length to incement past opcode and data
0000202A  2013                    1340              MOVE.L      (A3),D0         *Add correct data into d0 register for printing
0000202C                          1341              
0000202C  343C 0004               1342              MOVE.W      #4,D2           *move 4 to counter since this it word data 4 hex values are required
00002030                          1343              
00002030  4EB9 000020B4           1344              JSR         GD_LOOP
00002036  5446                    1345              ADD.W       #2,D6           *since it is long data increment the address by 4 bits *d6 is opcode length counter
00002038  4E75                    1346              RTS
0000203A                          1347  
0000203A  18FC 0024               1348  BYTE_DATA   MOVE.B      #'$',(A4)+       *prepare the string for a long hex value
0000203E  264D                    1349              MOVE.L      A5,A3    
00002040                          1350              
00002040  D7C6                    1351              ADD.L       D6,A3           *Add opcode data length to incement past opcode and data
00002042  2013                    1352              MOVE.L      (A3),D0         *Add correct data into d0 register for printing
00002044                          1353              
00002044  343C 0002               1354              MOVE.W      #2,D2           *move 2 to counter since this is byte data 2 hex values are required
00002048  E188                    1355              LSL.L       #8,D0           *shift data over 4 bits so beginning of byte is in the highest order
0000204A  4EB9 000020B4           1356              JSR         GD_LOOP
00002050  5446                    1357              ADD.W       #2,D6           *since it is long data increment the address by 4 bits *d6 is opcode length counter
00002052  4E75                    1358              RTS
00002054                          1359              
00002054                          1360              
00002054  3415                    1361  T1_GrabSreg MOVE.W      (A5),D2         *recopy op code
00002056  C47C 0007               1362              AND.W       #$0007,D2       *mask other bits
0000205A  3A02                    1363              MOVE.W      D2,D5           *copy D2 to D5
0000205C  4E75                    1364              RTS
0000205E                          1365      
0000205E  3415                    1366  T1_GrabDreg MOVE.W      (A5),D2         *type one grab register bits
00002060  EC4A                    1367              LSR.W       #6,D2           *shift bits over
00002062  E64A                    1368              LSR.W       #3,D2           
00002064  C47C 0007               1369              AND.W       #$0007,D2       *mask so only relevent bits left
00002068  3A02                    1370              MOVE.W      D2,D5           *move to d5 for printing
0000206A  4E75                    1371              RTS
0000206C                          1372      
0000206C  BA3C 0000               1373  PrintD5Num  CMP.B       #0,D5           *print the numeber in d5
00002070  6700 0050               1374              BEQ         PRINT0
00002074  BA3C 0001               1375              CMP.B       #1,D5
00002078  6700 004E               1376              BEQ         PRINT1
0000207C  BA3C 0002               1377              CMP.B       #2,D5
00002080  6700 004C               1378              BEQ         PRINT2
00002084  BA3C 0003               1379              CMP.B       #3,D5
00002088  6700 004A               1380              BEQ         PRINT3
0000208C  BA3C 0004               1381              CMP.B       #4,D5
00002090  6700 0048               1382              BEQ         PRINT4
00002094  BA3C 0005               1383              CMP.B       #5,D5
00002098  6700 0046               1384              BEQ         PRINT5
0000209C  BA3C 0006               1385              CMP.B       #6,D5
000020A0  6700 0044               1386              BEQ         PRINT6
000020A4  BA3C 0007               1387              CMP.B       #7,D5
000020A8  6700 0042               1388              BEQ         PRINT7
000020AC  BA3C 0008               1389              CMP.B       #8,D5
000020B0  6700 0040               1390              BEQ         PRINT8  
000020B4                          1391  
000020B4  4EB8 160E               1392  GD_LOOP     JSR         HEX_2_ASCII
000020B8  5342                    1393              SUBI        #1,D2
000020BA  B43C 0000               1394              CMP.B       #0,D2
000020BE  6EF4                    1395              BGT         GD_LOOP
000020C0  4E75                    1396              RTS
000020C2                          1397  
000020C2                          1398  
000020C2                          1399  
000020C2                          1400      
000020C2  18FC 0030               1401  PRINT0      MOVE.B      #'0',(A4)+
000020C6  4E75                    1402              RTS
000020C8                          1403      
000020C8  18FC 0031               1404  PRINT1      MOVE.B      #'1',(A4)+
000020CC  4E75                    1405              RTS
000020CE                          1406      
000020CE  18FC 0032               1407  PRINT2      MOVE.B      #'2',(A4)+
000020D2  4E75                    1408              RTS
000020D4                          1409      
000020D4  18FC 0033               1410  PRINT3      MOVE.B      #'3',(A4)+
000020D8  4E75                    1411              RTS
000020DA                          1412      
000020DA  18FC 0034               1413  PRINT4      MOVE.B      #'4',(A4)+
000020DE  4E75                    1414              RTS
000020E0                          1415      
000020E0  18FC 0035               1416  PRINT5      MOVE.B      #'5',(A4)+
000020E4  4E75                    1417              RTS
000020E6                          1418  
000020E6  18FC 0036               1419  PRINT6      MOVE.B      #'6',(A4)+
000020EA  4E75                    1420              RTS
000020EC                          1421      
000020EC  18FC 0037               1422  PRINT7      MOVE.B      #'7',(A4)+
000020F0  4E75                    1423              RTS  
000020F2                          1424         
000020F2  18FC 0038               1425  PRINT8      MOVE.B      #'8',(A4)+
000020F6  4E75                    1426              RTS
000020F8                          1427      
000020F8                          1428  
000020F8                          1429  
000020F8                          1430  
000020F8                          1431  
000020F8                          1432  
000020F8                          1433  
000020F8                          1434  
000020F8                          1435  
000020F8                          1436  
000020F8                          1437  
000020F8                          1438  
000020F8                          1439  
000020F8                          1440  
000020F8                          1441  -------------------- end include --------------------
000020F8                          1442              
000020F8                          1443  
000020F8                          1444  
000020F8                          1445  
000020F8                          1446  
000020F8                          1447  
000020F8                          1448  
000020F8                          1449  
000020F8                          1450  
000020F8                          1451  
000020F8                          1452  
000020F8                          1453  
000020F8                          1454  
000020F8                          1455  
000020F8                          1456  
000020F8                          1457  
000020F8                          1458  
000020F8                          1459  
000020F8                          1460  
000020F8                          1461  
000020F8                          1462  -------------------- end include --------------------
000020F8                          1463              
000020F8                          1464              END         START               ;last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1A38
ADDA                1A4C
ADDA_SIZE           1C36
APPND_ALPHA         1622
APPND_BYTE          1C52
APPND_LONG          1C6A
APPND_NUM           162A
APPND_WORD          1C5E
ARITH_MEM           1ABC
ARITH_REG           1A7A
BCC                 1992
BCLR_IM             185A
BCLR_REG            1872
BCS                 1976
BGE                 1968
BIN_0               16BE
BIN_10              17A2
BIN_11              17A6
BIN_12              17C4
BIN_13              17C8
BIN_14              17E4
BIN_15              182A
BIN_4               170A
BIN_5               1748
BIN_6               174C
BIN_7               1786
BIN_8               178A
BIN_9               179E
BIN_MOVE            16EE
BLT                 19A0
BRA_SUB             19AE
BUILD_STR           15D4
BVC                 1984
BYTE                2
BYTE_DATA           203A
B_ADDMODE           1CD2
B_DATAREG           1D0E
B_SCOUNT            1CF0
B_SRC_DMODE         1D26
CMP                 1A0C
CMPI                1842
CNVRT_ADDR          1474
CNVRT_ALPHA         1B7E
CNVRT_DONE          1510
CNVRT_NUM           1B86
CR                  D
C_ALPHA_L           1506
C_ALPHA_U           14FC
C_ERR1              154A
C_ERR2              155E
C_ERR3              1572
C_ERR4              1586
C_ERR_BASE1         159A
C_ERR_BASE2         15C6
C_INVALID           1540
C_IS_LC             14DE
C_LOOP              149E
C_NUMERIC           14F2
C_SRC               1D4E
C_VALIDATE          151A
D16AN               1FF0
D8ANXN              1FF0
DADDINMODE          1F9A
DADDINPOST          1FD2
DADDINPRE           1FB4
DADDMODE            1F88
DATA                1B08
DECODE_A            1C76
DECODE_B            1CA0
DECODE_C            1D3E
DECODE_D            1D6A
DECODE_E            1D88
DECODE_F            1DB8
DISP_INTRO          1016
DISP_WAIT           1024
DIVS_W              19BC
DREGMODE            1F76
DSMBL_DONE          1086
D_ADDQ              1DF8
D_DATA_MODE         1FF0
D_JSR               1E26
D_MOVEQ             1DD8
END                 10E2
END_ADDR            1106
EOR                 19F8
F_OPMODE            1DD8
GA_LOOP             15FA
GD_LOOP             20B4
GET_ADDR            15F2
GET_DSTMODE         1E7A
GET_SIZE_67         1B92
GET_SRCMODE         1E3A
HEX_2_ASCII         160E
IMMEDIATE_D         1F5A
INPUT_ADDR          143A
JSR                 192E
JT_START            1632
LEA                 1904
LEFT                1AFC
LF                  A
LOGIC_MEM           1AA6
LOGIC_REG           1A5E
LONG                8
LONG_DATA           200A
LOOP_COND           1066
MAIN_LOOP           1042
MOVE                188A
MOVEA               18A8
MOVEM               1912
MOVEM_SIZE          1BB6
MOVE_SIZE           1BD2
MULS_W              1A20
M_DONE              142E
M_ERR_ADDR1         1347
M_ERR_ADDR2         136A
M_ERR_ADDR3         13AC
M_ERR_ADDR4         13C5
M_ERR_GEN           141B
M_INPUT_E           12D6
M_INPUT_S           1296
M_INTRO             1142
M_INV_INPUT         1317
M_IN_RULES          11A6
M_NEWLINE           1436
M_NPROMPT           13DC
M_WAIT              12FA
NEG                 193C
NEXT_OP             104A
NOP                 18DE
OP_ADDR             1124
OR                  19D4
ORI                 182E
PREPARE_OP          15EC
PRINT0              20C2
PRINT1              20C8
PRINT2              20CE
PRINT3              20D4
PRINT4              20DA
PRINT5              20E0
PRINT6              20E6
PRINT7              20EC
PRINT8              20F2
PRINTD5NUM          206C
PRINT_OP            1070
PROMPT_NEW          1098
P_OPERAND           1B2C
P_RESTART           10DA
RIGHT               1B02
RIGHTORLEFT         1AE8
ROTATE_MEM          1AD2
ROTATE_REG          1A90
RTS                 18EE
S16AN               1F34
S8ANXN              1F34
SADDINMODE          1EDE
SADDINPOST          1F16
SADDINPRE           1EF8
SADDMODE            1ECC
SIZE_678            1BFA
SREGMODE            1EBA
START               1000
START_ADDR          10E8
SUB                 19E4
SUBQ                1950
S_DATA_MODE         1F34
T1_GRABDREG         205E
T1_GRABSREG         2054
WORD                4
WORD_DATA           2022
WRITE_DATA          1B3C
WRITE_DIGIT         1B62
WRITE_DONE          1B8E
WRITE_LOOP          1B3E
W_ALPHA             1B6E
W_NUM               1B76
