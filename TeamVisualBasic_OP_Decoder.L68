00000000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/12/2018 11:15:38 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Team Visual Basic's Disassembler
00000000                             3  * Written by :  Henry Hong, Dylan Desmond, Austin Abeyta
00000000                             4  * Date       :  3/4/2018
00000000                             5  * Description:  CSS422 Final Project
00000000                             6  *               Machine code to Motorola 68000 Assembly
00000000                             7  *               OP Decoder File
00000000                             8  *               Using different opcode type, deconstructs the op code 
00000000                             9  *               and prints the register or addr
00000000                            10  *-----------------------------------------------------------
00000000                            11  
00000000                            12  *-----------------------------------------------------------
00000000                            13  *-Starting Point: Branch into one of many OPCODE Types 
00000000                            14  *-Size bits are not handled here, that is handled in the jump table
00000000                            15  *-
00000000                            16  *-Bit Format:
00000000                            17  *-15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
00000000                            18  *-Most Significant    Least Significant   
00000000                            19  *-----------------------------------------------------------
00000000                            20  
00000000                            21  *-OPCODE Decode Type A--------------------------------------
00000000                            22  *-OPCODEs: MOVE,MOVEA,
00000000                            23  *-xxxx Dest Reg(3) Dest Mode(3) Src Mode(3) Src Reg(3)  
00000000                            24  
00000000  18FC 0009                 25  DECODE_A    MOVE.B      #9,(A4)+          *tab after op code
00000004  3C3C 0002                 26              MOVE.W      #2,D6               *Initilize opcode length to 2
00000008  3415                      27              MOVE.W      (A5),D2             *Copy OPCODE into D2
0000000A  E64A                      28              LSR.W       #3,D2               *Shift right 3 - isolate Src Mode
0000000C  C47C 0007                 29              AND.W       #$0007,D2           *Mask out other bits
00000010  4EB9 000001C0             30              JSR         GET_SRCMODE         *Append SRC string to (A4)          
00000016  18FC 002C                 31              MOVE.B      #',',(A4)+
0000001A                            32              
0000001A  3415                      33              MOVE.W      (A5),D2             *Recopy OPCODE into D2  
0000001C  EC4A                      34              LSR.W       #6,D2               *Shift right 6 - isolate Dest Mode
0000001E  C47C 0007                 35              AND.W       #$0007,D2           *Mask out other bits
00000022  4EB9 00000200             36              JSR         GET_DSTMODE         *Append DST string to (A4)
00000028                            37              
00000028  4E75                      38              RTS                             *Return back to jump table
0000002A                            39  
0000002A                            40  *-OPCODE Decode Type B--------------------------------------
0000002A                            41  *-OPCODEs: LSL/LSR,ASL/ASR,ROL/ROR
0000002A                            42  *-xxxx Register(3) OP Mode(3) EA Mode(3) EA Reg(3)  
0000002A                            43                 
0000002A  18FC 0009                 44  DECODE_B    MOVE.B      #9,(A4)+          *tab after op code
0000002E  3C3C 0002                 45              MOVE.W      #2,D6             *Initilize opcode length to 2
00000032  3415                      46              MOVE.W      (A5),D2           *reload op code
00000034  EC4A                      47              LSR.W       #6,D2              
00000036  C47C 0003                 48              AND.W       #$0003,D2
0000003A  B47C 0003                 49              CMP.W       #3,D2
0000003E  6700 0022                 50              BEQ         B_ADDMODE
00000042  3415                      51              MOVE.W      (A5),D2             
00000044  EA4A                      52              LSR.W       #5,D2              *logical shift left to get i/r
00000046  C47C 0001                 53              AND.W       #$0001,D2           
0000004A  B47C 0000                 54              CMP.W       #0,D2
0000004E  6700 0030                 55              BEQ         B_SCOUNT
00000052  B47C 0001                 56              CMP.W       #1,D2
00000056  6700 0040                 57              BEQ         B_DATAREG           
0000005A  4EB9 000000B0             58              JSR         B_SRC_DMODE
00000060  4E75                      59              RTS
00000062                            60  
00000062                            61  *-------------------------------------------------------
00000062                            62  *Shift on address is occuring    
00000062                            63  *print address by using EA Mode and EA Reg bits at end of op       
00000062                            64  B_ADDMODE
00000062  3415                      65             MOVE.W       (A5),D2
00000064  E64A                      66             LSR.W        #3,D2
00000066  C47C 0007                 67             AND.W        #$0007,D2
0000006A  4EB9 00000200             68             JSR          GET_DSTMODE
00000070  3415                      69             MOVE.W       (A5),D2
00000072  C47C 0007                 70             AND.W        #$0007,D2
00000076  3A02                      71             MOVE.W       D2,D5
00000078  4EB9 000003F2             72             JSR          PrintD5Num
0000007E  4E75                      73             RTS
00000080                            74              
00000080                            75              
00000080                            76  *-----------------------------------------------------------
00000080                            77  *-OPTYPE_B HELPER FUNCTIONS
00000080                            78  *Helps determine the size of shifts or registers
00000080                            79  *-----------------------------------------------------------
00000080                            80  
00000080                            81  *-----------------------------------------------------------
00000080                            82  *Value stored in cont/reg is a number of bits to shift
00000080                            83  *Display as #number
00000080  3415                      84  B_SCOUNT    MOVE.W      (A5),D2
00000082  EC4A                      85              LSR.W       #6,D2
00000084  E64A                      86              LSR.W       #3,D2
00000086  C47C 0007                 87              AND.W       #$0007,D2
0000008A  3A02                      88              MOVE.W      D2,D5
0000008C  18FC 0023                 89              MOVE.B      #'#',(A4)+
00000090  4EB9 000003F2             90              JSR         PrintD5Num
00000096  4E75                      91              RTS
00000098                            92     
00000098                            93  *------------------------------------------------------------
00000098                            94  *Display proper register number found at the 12 - 9 bits
00000098  18FC 0044                 95  B_DATAREG   MOVE.B      #'D',(A4)+
0000009C  3415                      96              MOVE.W      (A5),D2
0000009E  EC4A                      97              LSR.W       #6,D2
000000A0  E64A                      98              LSR.W       #3,D2
000000A2  C47C 0007                 99              AND.W       #$0007,D2
000000A6  3A02                     100              MOVE.W      D2,D5
000000A8  4EB9 000003F2            101              JSR         PrintD5Num
000000AE  4E75                     102              RTS
000000B0                           103  *---------------------------------------------------------
000000B0                           104  *display the register number 
000000B0  3415                     105  B_SRC_DMODE MOVE.W      (A5),D2             *reload op
000000B2  18FC 002C                106              MOVE.B      #',',(A4)+          *add comma to printer
000000B6  C47C 0007                107              AND.W       #0007,D2            *mask out other bits
000000BA  3A02                     108              MOVE.W      D2,D5               *move register number to d5
000000BC  4EB9 000003F2            109              JSR         Printd5Num          *print register numebr
000000C2  4E75                     110              RTs
000000C4                           111  *-OPCODE Decode Type C--------------------------------------
000000C4                           112  *-OPCODEs: ADDI, SUBI, NEG, ORI, CMPI, ADDI 
000000C4                           113  *-xxxxxxxx Size2, Ea mode(3) Ea Reg(3)
000000C4                           114  *STILL NEED TO PRINT DATA THAT FOLLOWS FIRST       
000000C4                           115    
000000C4  18FC 0009                116  DECODE_C    MOVE.B      #9,(A4)+          *tab after op code
000000C8  3C3C 0002                117              MOVE.W      #2,D6               *Initilize opcode length to 2
000000CC  3415                     118              MOVE.W      (A5),D2
000000CE                           119              *ENTER PRINT DATA CODE HERE
000000CE  4EB9 000000D4            120              JSR         C_SRC
000000D4                           121              
000000D4                           122  
000000D4                           123  
000000D4                           124  *-----------------------------------------------------------
000000D4                           125  *-OPTYPE_c HELPER FUNCTIONS
000000D4                           126  *Helps print second argument
000000D4                           127  *-----------------------------------------------------------
000000D4                           128  
000000D4  3415                     129  C_SRC       MOVE.W      (A5),D2
000000D6  E64A                     130              LSR.W       #3,D2
000000D8  C47C 0007                131              AND.W       #$0007,D2
000000DC  4EB9 00000200            132              JSR         GET_DSTMODE
000000E2  3415                     133              MOVE.W      (A5),D2
000000E4  C47C 0007                134              AND.W       #$0007,D2
000000E8  4EB9 000001C0            135              JSR         GET_SRCMODE
000000EE  4E75                     136              RTS
000000F0                           137  
000000F0                           138  
000000F0                           139  *-OPCODE Decode Type D--------------------------------------
000000F0                           140  *-OPCODEs: 
000000F0                           141  *-xxxx Register(3) x Size(2) EA Mode(3) EA Reg(3)       
000000F0                           142     
000000F0  18FC 0009                143  DECODE_D    MOVE.B      #9,(A4)+          *tab after op code
000000F4  3C3C 0002                144              MOVE.W      #2,D6               *Initilize opcode length to 2   
000000F8  1C3C 0023                145              MOVE.B      #'#',D6
000000FC  1C3C 0024                146              MOVE.B      #'$',D6     
00000100  343C 0002                147              MOVE.W      #2,D2               *move counter to 2 since only 2 HEX values used
00000104  E14A                     148              LSL.W       #8,D2               *set up data for printers
00000106  4EB9 0000043A            149              JSR         GD_LOOP             *print hex the 2 bits
0000010C  4E75                     150              RTS
0000010E                           151  
0000010E                           152  *-OPCODE Decode Type E--------------------------------------
0000010E                           153  *-OPCODEs: 
0000010E                           154  *-xxxx Condition(4) 8 Bit Displacement       
0000010E                           155    
0000010E  18FC 0039                156  DECODE_E    MOVE.B      #'9',(A4)+          *tab after op code
00000112  3C3C 0002                157              MOVE.W      #2,D6               *Initilize opcode length to 2
00000116  3415                     158              MOVE.W      (A5),D2
00000118  E74A                     159              LSL.W       #3,D2               *GRAB SOURCE MODE BITS
0000011A  C47C 0007                160              AND.W       #$0007,D2           *Mask out other bits
0000011E  4EB9 000001C0            161              JSR         GET_SRCMODE         *Append SRC string to (A4)          
00000124  18FC 002C                162              MOVE.B      #',',(A4)+          *Addd comma for out put
00000128  3415                     163              MOVE.W      (A5),D2
0000012A  ED4A                     164              LSL.W       #6,D2               *logical shift left to get data bits to d2
0000012C  E74A                     165              LSL.W       #3,D2
0000012E  C478 0007                166              AND.W       $0007,D2            *mask out other bits
00000132  18FC 0044                167              MOVE.B      #'D',(A4)+          *Push D into register
00000136  3A02                     168              MOVE.W      D2,D5
00000138  4EB9 000003F2            169              JSR         PrintD5Num          *print register number
0000013E                           170                    
0000013E                           171  
0000013E                           172  
0000013E                           173  *-OPCODE Decode Type F--------------------------------------
0000013E                           174  *-OPCODEs: 
0000013E                           175  *-xxxx Reg(3) OPMode(3) EAMode(3) EAReg(3)       
0000013E                           176    
0000013E  3C3C 0002                177  DECODE_F    MOVE.W      #2,D6               *Initilize opcode length to 2
00000142  3415                     178              MOVE.W      (A5),D2             *Copy opcode into d2
00000144  ED4A                     179              LSL.W       #6,D2               *Shift to grab op mode
00000146  C47C 0007                180              AND.W       #$0007,D2           *Mask other bits
0000014A  4EB9 0000015E            181              JSR         F_OPMODE
00000150  3415                     182              MOVE.W      (A5),D2             *Recopy OPCODE into D2  
00000152  EC4A                     183              LSR.W       #6,D2               *Shift right 6 - isolate Dest Mode
00000154  C47C 0007                184              AND.W       #$0007,D2           *Mask out other bits
00000158  4EB9 00000200            185              JSR         GET_DSTMODE         *Append DST string to (A4)
0000015E                           186  
0000015E                           187  *-OPCODE Decode Type G---------------------------------------
0000015E                           188  *-OPCODEs: NEG, ORI, CMPI, ADDI
0000015E                           189  *-xxxxxxxx Size(2) EAMode(3) EAReg(3)
0000015E                           190  
0000015E                           191  *DECODE_G   MOVE.W       #2,D6               *Initialize OPCODE length to 2
0000015E                           192             *Check for the size of the OPCODE
0000015E                           193              
0000015E                           194  *-----------------------------------------------------------
0000015E                           195  *-OPTYPE_F HELPER FUNCTIONS
0000015E                           196  *Helps determine the OPTYPE
0000015E                           197  *-----------------------------------------------------------
0000015E                           198  F_OPMODE
0000015E                           199  
0000015E                           200  *-OPS WITHOUT TYPE------------------------------------------
0000015E                           201  *-OPCODES: MOVEQ
0000015E                           202  
0000015E  3C3C 0002                203  D_MOVEQ     MOVE.W      #2,D6               *Initilize opcode length to 2
00000162  3015                     204              MOVE.W      (A5),D0             *grab op code from a5
00000164  18FC 0023                205              MOVE.B      #'#',(A4)+          *preload source string for literal
00000168  18FC 0024                206              MOVE.B      #'$',(A4)+          *preload source string for hex
0000016C  343C 0002                207              MOVE.W      #2,D2               *move 8 to counter since this si long data 8 hex values are required
00000170  E14A                     208              LSL.W       #8,D2               *shift over 8 so bits in high order for print
00000172  4EB9 0000043A            209              JSR         GD_LOOP
00000178  4EB8 0098                210              JSR         B_DATAREG           *grabs and prints data reg 
0000017C  4E75                     211              RTS
0000017E                           212  
0000017E  3C3C 0002                213  D_ADDQ      MOVE.W      #2,D6               *Initilize opcode length to 2
00000182  3015                     214              MOVE.W      (A5),D0             *grab op code from a5
00000184  18FC 0023                215              MOVE.B      #'#',(A4)+          *preload source string for literal
00000188  18FC 0024                216              MOVE.B      #'$',(A4)+          *preload source string for hex
0000018C  343C 0001                217              MOVE.W      #1,D2               *move counter to 1 since only 1 bit is used
00000190  E54A                     218              LSL.W       #2,D2               *set up data for printer
00000192  0642 C000                219              ADD.W       #$C000,D2           *mask out first bits
00000196  4EB9 0000043A            220              JSR         GD_LOOP             *print hex the 2 bits
0000019C  3415                     221              MOVE.W      (A5),D2             *reload op code from a5
0000019E  E74A                     222              LSL.W       #3,D2               *shift so source mode is in LSBs  
000001A0  C47C 0007                223              AND.W       #$0007,D2           *mask out other bits
000001A4  4EB9 000001C0            224              JSR         GET_SRCMODE         *print source mode
000001AA  4E75                     225              RTS
000001AC                           226              
000001AC  3C3C 0002                227  D_JSR       MOVE.W      #2,D6               *Initilize opcode length to 2
000001B0  3415                     228              MOVE.W      (A5),D2             *reload op code from a5
000001B2  E74A                     229              LSL.W       #3,D2               *shift so source mode is in LSBs  
000001B4  C47C 0007                230              AND.W       #$0007,D2           *mask out other bits
000001B8  4EB9 000001C0            231              JSR         GET_SRCMODE         *print source mode
000001BE  4E75                     232              RTS
000001C0                           233  
000001C0                           234  
000001C0                           235              
000001C0                           236              
000001C0                           237            
000001C0                           238              
000001C0                           239               
000001C0                           240  
000001C0                           241  *-SRC_MODE--------------------------------------------------
000001C0                           242  *-Determines SRC Mode from bits 5,4,3, and branch to appropriate subroutine
000001C0                           243  *-Assumption is that the SRC Mode bits are pre-isolated in D2
000001C0                           244  
000001C0  B47C 0000                245  GET_SRCMODE CMP.W       #0,D2
000001C4  6700 007A                246              BEQ         SregMode        *register mode: Dn
000001C8  B47C 0001                247              CMP.W       #1,D2
000001CC  6700 0084                248              BEQ         SaddMode        *address mode ---An
000001D0  B47C 0002                249              CMP.W       #2,D2
000001D4  6700 008E                250              BEQ         SaddINmode      *addres indirect mode ---(An)
000001D8  B47C 0003                251              CMP.W       #3,D2
000001DC  6700 00A0                252              BEQ         SaddINpre       *addess indirect pre dec ----(An)
000001E0  B47C 0004                253              CMP.W       #4,D2
000001E4  6700 00B6                254              BEQ         SaddINpost      *address indirect post inc --- (An)+
000001E8  B47C 0005                255              CMP.W       #5,D2
000001EC  6700 00CC                256              BEQ         S16An           *source number of word size --- (d16,An)
000001F0  B47C 0006                257              CMP.W       #6,D2
000001F4  6700 00C4                258              BEQ         S8AnXn          *source number byte size --- (d8,An,Xn)
000001F8  B47C 0007                259              CMP.W       #7,D2
000001FC  6700 00BC                260              BEQ         S_DATA_MODE     *immediate data
00000200                           261      
00000200                           262  *-DST_MODE--------------------------------------------------
00000200                           263  *-Determines DST Mode from bits 8,7,6, and branch to appropriate subroutine
00000200                           264  *-Assumption is that the DST Mode bits are pre-isolated in D2
00000200                           265  
00000200  B47C 0000                266  GET_DSTMODE CMP.W       #0,D2
00000204  6700 00F6                267              BEQ         DregMode        *register mode ---Dn
00000208  B47C 0001                268              CMP.W       #1,D2
0000020C  6700 0100                269              BEQ         DaddMode        *address mode ---An
00000210  B47C 0002                270              CMP.W       #2,D2
00000214  6700 010A                271              BEQ         DaddINmode      *addres indirect mode ---(An)
00000218  B47C 0003                272              CMP.W       #3,D2
0000021C  6700 011C                273              BEQ         DaddINpre       *addess indirect pre dec ----(An)
00000220  B47C 0004                274              CMP.W       #4,D2
00000224  6700 0132                275              BEQ         DaddINpost      *address indirect post inc --- (An)+
00000228  B47C 0005                276              CMP.W       #5,D2
0000022C  6700 0148                277              BEQ         D16An           *source number of word size --- (d16,An)
00000230  B47C 0006                278              CMP.W       #6,D2
00000234  6700 0140                279              BEQ         D8AnXn          *source number byte size --- (d8,An,Xn)
00000238  B47C 0007                280              CMP.W       #7,D2           
0000023C  6700 0138                281              BEQ         D_DATA_MODE     *Source is immediate data following the opcode
00000240                           282      
00000240                           283   
00000240                           284  *----------------------------------------------------------- 
00000240                           285  *-Source Helper Functions
00000240                           286  *-Adds Source Register numbers to (A4) string
00000240                           287  *-----------------------------------------------------------
00000240  18FC 0044                288  SregMode    MOVE.B      #'D',(A4)+
00000244  4EB9 000003DA            289              JSR         T1_GrabSreg
0000024A  4EB9 000003F2            290              JSR         PrintD5Num   
00000250  4E75                     291              RTS  
00000252                           292          
00000252  18FC 0041                293  SaddMode    MOVE.B      #'A',(A4)+
00000256  4EB9 000003DA            294              JSR         T1_GrabSreg
0000025C  4EB9 000003F2            295              JSR         PrintD5Num
00000262  4E75                     296              RTS
00000264                           297      
00000264                           298      
00000264                           299      
00000264  18FC 0028                300  SaddInMode  MOVE.B      #'(',(A4)+
00000268  18FC 0041                301              MOVE.B      #'A',(A4)+
0000026C  4EB9 000003DA            302              JSR         T1_GrabSreg
00000272  4EB9 000003F2            303              JSR         PrintD5Num
00000278  18FC 0029                304              MOVE.B      #')',(A4)+
0000027C  4E75                     305              RTS
0000027E                           306      
0000027E  18FC 002D                307  SaddINpre   MOVE.B      #'-',(A4)+
00000282  18FC 0028                308              MOVE.B      #'(',(A4)+
00000286  18FC 0041                309              MOVE.B      #'A',(A4)+
0000028A  4EB9 000003DA            310              JSR         T1_GrabSreg
00000290  4EB9 000003F2            311              JSR         PrintD5Num
00000296  18FC 0029                312              MOVE.B      #')',(A4)+
0000029A  4E75                     313              RTS
0000029C                           314      
0000029C  18FC 0028                315  SaddINpost  MOVE.B      #'(',(A4)+
000002A0  18FC 0041                316              MOVE.B      #'A',(A4)+
000002A4  4EB9 000003DA            317              JSR         T1_GrabSreg
000002AA  4EB9 000003F2            318              JSR         PrintD5Num
000002B0  18FC 0029                319              MOVE.B      #')',(A4)+
000002B4  18FC 002B                320              MOVE.B      #'+',(A4)+
000002B8  4E75                     321              RTS
000002BA                           322      
000002BA                           323  S16An
000002BA                           324  S8AnXn
000002BA  4EB9 000003E4            325  S_DATA_MODE JSR         T1_GrabDreg
000002C0  0C45 0001                326              CMPI.W      #1,D5
000002C4  6700 00CA                327              BEQ         LONG_DATA
000002C8  0C45 0002                328              CMPI.W      #2,D5
000002CC  6700 00C2                329              BEQ         LONG_DATA
000002D0  BA7C 0000                330              CMP.W       #0,D5  
000002D4  6700 00D2                331              BEQ         WORD_DATA
000002D8  BA7C 0004                332              CMP.W       #4,D5
000002DC  6700 0002                333              BEQ         IMMEDIATE_D
000002E0                           334              
000002E0                           335  *---------------IMMEDIATE_DATA-------------------------            
000002E0                           336  *Reached when an opcode has immediate data afterwards
000002E0                           337  *The length of this immedite data depends on the opcode length
000002E0                           338  *That value is stored in the d7 register by the jump table            
000002E0  18FC 0023                339  IMMEDIATE_D MOVE.B      #'#',(A4)+              *add the # to data string to immediate data
000002E4                           340              
000002E4  BE7C 0008                341              CMP.W       #8,D7
000002E8  6700 00BE                342              BEQ         WORD_DATA               *means the immediate data is a word value
000002EC                           343              
000002EC  BE7C 000C                344              CMP.W       #12,D7       
000002F0  6700 009E                345              BEQ         LONG_DATA               *means the immediate data is a long value
000002F4                           346              
000002F4  BE7C 0006                347              CMP.W       #6,D7
000002F8  6700 00C6                348              BEQ         BYTE_DATA             *means the immediate data is a long value
000002FC                           349              
000002FC                           350               
000002FC                           351  *----------------------------------------------------------- 
000002FC                           352  *-Destination Helper Functions
000002FC                           353  *-Adds Destination Register numbers to (A4) string
000002FC                           354  *-----------------------------------------------------------
000002FC  18FC 0044                355  DregMode    MOVE.B      #'D',(A4)+
00000300  4EB9 000003E4            356              JSR         T1_GrabDreg
00000306  4EB9 000003F2            357              JSR         PrintD5Num   
0000030C  4E75                     358              RTS
0000030E                           359           
0000030E  18FC 0041                360  DaddMode    MOVE.B      #'A',(A4)+
00000312  4EB9 000003E4            361              JSR         T1_GrabDreg
00000318  4EB9 000003F2            362              JSR         PrintD5Num
0000031E  4E75                     363              RTS
00000320                           364      
00000320                           365      
00000320                           366      
00000320  18FC 0028                367  DaddInMode  MOVE.B      #'(',(A4)+
00000324  18FC 0041                368              MOVE.B      #'A',(A4)+
00000328  4EB9 000003E4            369              JSR         T1_GrabDreg
0000032E  4EB9 000003F2            370              JSR         PrintD5Num
00000334  18FC 0029                371              MOVE.B      #')',(A4)+
00000338  4E75                     372              RTS
0000033A                           373      
0000033A  18FC 002D                374  DaddINpre   MOVE.B      #'-',(A4)+
0000033E  18FC 0028                375              MOVE.B      #'(',(A4)+
00000342  18FC 0041                376              MOVE.B      #'A',(A4)+
00000346  4EB9 000003E4            377              JSR         T1_GrabDreg
0000034C  4EB9 000003F2            378              JSR         PrintD5Num
00000352  18FC 0029                379              MOVE.B      #')',(A4)+
00000356  4E75                     380              RTS
00000358                           381      
00000358  18FC 0028                382  DaddINpost  MOVE.B      #'(',(A4)+
0000035C  18FC 0041                383              MOVE.B      #'A',(A4)+
00000360  4EB9 000003E4            384              JSR         T1_GrabDreg
00000366  4EB9 000003F2            385              JSR         PrintD5Num
0000036C  18FC 0029                386              MOVE.B      #')',(A4)+
00000370  18FC 002B                387              MOVE.B      #'+',(A4)+
00000374  4E75                     388              RTS
00000376                           389      
00000376                           390  D16An
00000376                           391              
00000376                           392  D8AnXn
00000376                           393  
00000376  4EB9 000003E4            394  D_DATA_MODE JSR         T1_GrabDreg
0000037C  0C45 0001                395              CMPI.W      #1,D5
00000380  6700 000E                396              BEQ         LONG_DATA
00000384  0C45 0000                397              CMPI.W      #0,D5
00000388  6700 001E                398              BEQ         WORD_DATA
0000038C  0C45 0007                399              CMPI.W      #7,D5
00000390                           400              *BEQ         DATA_SIZE
00000390                           401              
00000390                           402  *D_SIZE      
00000390                           403  
00000390                           404  
00000390                           405  *----------------------------------------------------------- 
00000390                           406  *-Assorted(?) Helper Functions
00000390                           407  *-add Description here
00000390                           408  *-----------------------------------------------------------
00000390  18FC 0024                409  LONG_DATA   MOVE.B      #'$',(A4)+       *prepare the string for a long hex value
00000394  264D                     410              MOVE.L      A5,A3
00000396                           411      
00000396  D7C6                     412              ADD.L       D6,A3           *Add opcode data length this increments the address past the op code and existing data
00000398  2013                     413              MOVE.L      (A3),D0
0000039A                           414              
0000039A  343C 0008                415              MOVE.W      #8,D2           *move 8 to counter since this si long data 8 hex values are required
0000039E  4EB9 0000043A            416              JSR         GD_LOOP
000003A4  5846                     417              ADD.W       #4,D6           *since it is long data increment the address by 4 bits *d6 is opcode length counter
000003A6  4E75                     418              RTS
000003A8                           419  
000003A8  18FC 0024                420  WORD_DATA   MOVE.B      #'$',(A4)+       *prepare the string for a long hex value
000003AC  264D                     421              MOVE.L      A5,A3    
000003AE                           422              
000003AE  D7C6                     423              ADD.L       D6,A3           *Add opcode data length to incement past opcode and data
000003B0  2013                     424              MOVE.L      (A3),D0         *Add correct data into d0 register for printing
000003B2                           425              
000003B2  343C 0004                426              MOVE.W      #4,D2           *move 4 to counter since this it word data 4 hex values are required
000003B6                           427              
000003B6  4EB9 0000043A            428              JSR         GD_LOOP
000003BC  5446                     429              ADD.W       #2,D6           *since it is long data increment the address by 4 bits *d6 is opcode length counter
000003BE  4E75                     430              RTS
000003C0                           431  
000003C0  18FC 0024                432  BYTE_DATA   MOVE.B      #'$',(A4)+       *prepare the string for a long hex value
000003C4  264D                     433              MOVE.L      A5,A3    
000003C6                           434              
000003C6  D7C6                     435              ADD.L       D6,A3           *Add opcode data length to incement past opcode and data
000003C8  2013                     436              MOVE.L      (A3),D0         *Add correct data into d0 register for printing
000003CA                           437              
000003CA  343C 0002                438              MOVE.W      #2,D2           *move 2 to counter since this is byte data 2 hex values are required
000003CE  E188                     439              LSL.L       #8,D0           *shift data over 4 bits so beginning of byte is in the highest order
000003D0  4EB9 0000043A            440              JSR         GD_LOOP
000003D6  5446                     441              ADD.W       #2,D6           *since it is long data increment the address by 4 bits *d6 is opcode length counter
000003D8  4E75                     442              RTS
000003DA                           443              
000003DA                           444              
000003DA  3415                     445  T1_GrabSreg MOVE.W      (A5),D2         *recopy op code
000003DC  C47C 0007                446              AND.W       #$0007,D2       *mask other bits
000003E0  3A02                     447              MOVE.W      D2,D5           *copy D2 to D5
000003E2  4E75                     448              RTS
000003E4                           449      
000003E4  3415                     450  T1_GrabDreg MOVE.W      (A5),D2         *type one grab register bits
000003E6  EC4A                     451              LSR.W       #6,D2           *shift bits over
000003E8  E64A                     452              LSR.W       #3,D2           
000003EA  C47C 0007                453              AND.W       #$0007,D2       *mask so only relevent bits left
000003EE  3A02                     454              MOVE.W      D2,D5           *move to d5 for printing
000003F0  4E75                     455              RTS
000003F2                           456      
000003F2  BA3C 0000                457  PrintD5Num  CMP.B       #0,D5           *print the numeber in d5
000003F6  6700 0052                458              BEQ         PRINT0
000003FA  BA3C 0001                459              CMP.B       #1,D5
000003FE  6700 0050                460              BEQ         PRINT1
00000402  BA3C 0002                461              CMP.B       #2,D5
00000406  6700 004E                462              BEQ         PRINT2
0000040A  BA3C 0003                463              CMP.B       #3,D5
0000040E  6700 004C                464              BEQ         PRINT3
00000412  BA3C 0004                465              CMP.B       #4,D5
00000416  6700 004A                466              BEQ         PRINT4
0000041A  BA3C 0005                467              CMP.B       #5,D5
0000041E  6700 0048                468              BEQ         PRINT5
00000422  BA3C 0006                469              CMP.B       #6,D5
00000426  6700 0046                470              BEQ         PRINT6
0000042A  BA3C 0007                471              CMP.B       #7,D5
0000042E  6700 0044                472              BEQ         PRINT7
00000432  BA3C 0008                473              CMP.B       #8,D5
00000436  6700 0042                474              BEQ         PRINT8  
0000043A                           475  
0000043A                           476  *Used to print data to a hex value from bits
0000043A                           477  *----Requires a preload---------------------------------------------------------------
0000043A                           478  *D0 =  must be loaded with bits to be printed, starts from highest order bit
0000043A                           479  *D2 = how many bits it will convert to hex starting with the highest order bit in d0
0000043A                           480  *Therefore bits wanting to be printed should be shifter or rotated to the highest order in d0
0000043A                           481  *HEX_2_ASCII exists in the Print builder file
0000043A                           482  *------------------------------------------------------------------------------------------    
Line 483 ERROR: Undefined symbol
0000043A  4EB9 004DBB8E            483  GD_LOOP     JSR         HEX_2_ASCII
00000440  5342                     484              SUBI        #1,D2
00000442  B43C 0000                485              CMP.B       #0,D2
00000446  6EF2                     486              BGT         GD_LOOP
00000448  4E75                     487              RTS
0000044A                           488  
0000044A                           489  
0000044A                           490  
0000044A                           491      
0000044A  18FC 0030                492  PRINT0      MOVE.B      #'0',(A4)+
0000044E  4E75                     493              RTS
00000450                           494      
00000450  18FC 0031                495  PRINT1      MOVE.B      #'1',(A4)+
00000454  4E75                     496              RTS
00000456                           497      
00000456  18FC 0032                498  PRINT2      MOVE.B      #'2',(A4)+
0000045A  4E75                     499              RTS
0000045C                           500      
0000045C  18FC 0033                501  PRINT3      MOVE.B      #'3',(A4)+
00000460  4E75                     502              RTS
00000462                           503      
00000462  18FC 0034                504  PRINT4      MOVE.B      #'4',(A4)+
00000466  4E75                     505              RTS
00000468                           506      
00000468  18FC 0035                507  PRINT5      MOVE.B      #'5',(A4)+
0000046C  4E75                     508              RTS
0000046E                           509  
0000046E  18FC 0036                510  PRINT6      MOVE.B      #'6',(A4)+
00000472  4E75                     511              RTS
00000474                           512      
00000474  18FC 0037                513  PRINT7      MOVE.B      #'7',(A4)+
00000478  4E75                     514              RTS  
0000047A                           515         
0000047A  18FC 0038                516  PRINT8      MOVE.B      #'8',(A4)+
0000047E  4E75                     517              RTS
00000480                           518      
00000480                           519  
00000480                           520  
00000480                           521  
00000480                           522  
00000480                           523  
00000480                           524  
00000480                           525  
00000480                           526  
00000480                           527  
00000480                           528  
Line 529 WARNING: END directive missing, starting address not set

1 error detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BYTE_DATA           3C0
B_ADDMODE           62
B_DATAREG           98
B_SCOUNT            80
B_SRC_DMODE         B0
C_SRC               D4
D16AN               376
D8ANXN              376
DADDINMODE          320
DADDINPOST          358
DADDINPRE           33A
DADDMODE            30E
DECODE_A            0
DECODE_B            2A
DECODE_C            C4
DECODE_D            F0
DECODE_E            10E
DECODE_F            13E
DREGMODE            2FC
D_ADDQ              17E
D_DATA_MODE         376
D_JSR               1AC
D_MOVEQ             15E
F_OPMODE            15E
GD_LOOP             43A
GET_DSTMODE         200
GET_SRCMODE         1C0
IMMEDIATE_D         2E0
LONG_DATA           390
PRINT0              44A
PRINT1              450
PRINT2              456
PRINT3              45C
PRINT4              462
PRINT5              468
PRINT6              46E
PRINT7              474
PRINT8              47A
PRINTD5NUM          3F2
S16AN               2BA
S8ANXN              2BA
SADDINMODE          264
SADDINPOST          29C
SADDINPRE           27E
SADDMODE            252
SREGMODE            240
S_DATA_MODE         2BA
T1_GRABDREG         3E4
T1_GRABSREG         3DA
WORD_DATA           3A8
